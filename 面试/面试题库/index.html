<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>面试题库 | 游戏开发笔记</title><meta name="author" content="wqx"><meta name="copyright" content="wqx"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="C#相关 1. 装箱和拆箱是指什么？  解析查看  1.装箱——把栈中内容迁移到堆中去（值转引用） 2.装箱——把堆中内容迁移到栈中去（引用转值） 3.如果问到值类型和引用类型同样，要引申这个    2. 值和引用类型在变量赋值时的区别是什么？  解析查看  1.值类型在赋值时只是把数据值复制过去，值类型数据值具有独立性 2.引用类型在赋值时复制的是引用（地址），一这意味着两个变量指向同一个对象，">
<meta property="og:type" content="article">
<meta property="og:title" content="面试题库">
<meta property="og:url" content="http://wqxblog.top/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/index.html">
<meta property="og:site_name" content="游戏开发笔记">
<meta property="og:description" content="C#相关 1. 装箱和拆箱是指什么？  解析查看  1.装箱——把栈中内容迁移到堆中去（值转引用） 2.装箱——把堆中内容迁移到栈中去（引用转值） 3.如果问到值类型和引用类型同样，要引申这个    2. 值和引用类型在变量赋值时的区别是什么？  解析查看  1.值类型在赋值时只是把数据值复制过去，值类型数据值具有独立性 2.引用类型在赋值时复制的是引用（地址），一这意味着两个变量指向同一个对象，">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://skymirror-1316984539.cos.ap-beijing.myqcloud.com/Typoramimi.jpg">
<meta property="article:published_time" content="2025-05-10T07:30:06.000Z">
<meta property="article:modified_time" content="2025-08-19T17:46:29.874Z">
<meta property="article:author" content="wqx">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://skymirror-1316984539.cos.ap-beijing.myqcloud.com/Typoramimi.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "面试题库",
  "url": "http://wqxblog.top/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/",
  "image": "https://skymirror-1316984539.cos.ap-beijing.myqcloud.com/Typoramimi.jpg",
  "datePublished": "2025-05-10T07:30:06.000Z",
  "dateModified": "2025-08-19T17:46:29.874Z",
  "author": [
    {
      "@type": "Person",
      "name": "wqx",
      "url": "http://wqxblog.top/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://wqxblog.top/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '面试题库',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background: linear-gradient(135deg,#1a1a1a 0%,#2c3e50 25%,#34495e 45%,#2980b9 80%,#1a1a1a 100%);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="https://skymirror-1316984539.cos.ap-beijing.myqcloud.com/Typoramimi.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">27</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">21</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background: linear-gradient(135deg,#1a1a1a 0%,#2c3e50 40%,#34495e 60%,#2980b9 80%,#1a1a1a 100%);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">游戏开发笔记</span></a><a class="nav-page-title" href="/"><span class="site-name">面试题库</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">面试题库</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-05-10T07:30:06.000Z" title="发表于 2025-05-10 15:30:06">2025-05-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-08-19T17:46:29.874Z" title="更新于 2025-08-20 01:46:29">2025-08-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">22.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>71分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="C-相关"><a href="#C-相关" class="headerlink" title="C#相关"></a>C#相关</h1><hr>
<h2 id="1-装箱和拆箱是指什么？"><a href="#1-装箱和拆箱是指什么？" class="headerlink" title="1. 装箱和拆箱是指什么？"></a>1. 装箱和拆箱是指什么？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">1.装箱——把栈中内容迁移到堆中去（值转引用）</span>
<span style="color: red;">2.装箱——把堆中内容迁移到栈中去（引用转值）</span>
3.如果问到值类型和引用类型同样，要引申这个
</code></pre>
</details></blockquote>
<hr>
<h2 id="2-值和引用类型在变量赋值时的区别是什么？"><a href="#2-值和引用类型在变量赋值时的区别是什么？" class="headerlink" title="2. 值和引用类型在变量赋值时的区别是什么？"></a>2. 值和引用类型在变量赋值时的区别是什么？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">1.值类型在赋值时只是把数据值复制过去，值类型数据值具有独立性</span>
<span style="color: red;">2.引用类型在赋值时复制的是引用（地址），一这意味着两个变量指向同一个对象，对其中一个变量进行修改也会影响到另外一个变量。</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="3-委托和事件在使用上的区别是什么？"><a href="#3-委托和事件在使用上的区别是什么？" class="headerlink" title="3.  委托和事件在使用上的区别是什么？"></a>3.  委托和事件在使用上的区别是什么？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">1.委托可以在外部调用，但是事件不能在外部直接调用，只能通过+=或者-=来取消/订阅事件</span>
<span style="color: red;">2.想要调用必须在类内部再封装一个方法来调用事件</span>
<span style="color: red;">3.事件不能在外部直接赋值，但是委托可以</span>
</code></pre>
</details></blockquote>
<blockquote>
<details>
<summary>代码查看</summary>
<pre><code>
public class Publisher 
&#123;
public event NotificationHandler Notify; // 封装为事件
public void SendMessage(string msg)
 &#123;
    Notify?.Invoke(msg); // 安全触发事件
&#125;
&#125;
// 外部代码只能订阅/取消订阅
var publisher = new Publisher();
publisher.Notify += (msg) => &#123; Console.WriteLine(msg); &#125;;
publisher.Notify -= ...; // 无法直接清空事件
</code></pre>
</details></blockquote>
<hr>
<h2 id="4-有两个接口IA和IB，他们中有一个同名方法Test-一个类同时继承这两个接口，应该如何处理他们的同名方法？"><a href="#4-有两个接口IA和IB，他们中有一个同名方法Test-一个类同时继承这两个接口，应该如何处理他们的同名方法？" class="headerlink" title="4. 有两个接口IA和IB，他们中有一个同名方法Test()一个类同时继承这两个接口，应该如何处理他们的同名方法？"></a>4. 有两个接口IA和IB，他们中有一个同名方法Test()一个类同时继承这两个接口，应该如何处理他们的同名方法？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">显示实现接口
IA.Test()
IB.Test()</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="5-请说明C-中的List是如何扩容的"><a href="#5-请说明C-中的List是如何扩容的" class="headerlink" title="5. 请说明C#中的List是如何扩容的"></a>5. 请说明C#中的List是如何扩容的</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">List的底层实现是使用数组</span>
<span style="color: red;">当List容量不足的时候，他会重新再开辟一个大内存，数组大小通常会扩大一倍，并将现有元素复制到新数组</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="6-请说说你认为C-中-和-Equals-的区别是什么？"><a href="#6-请说说你认为C-中-和-Equals-的区别是什么？" class="headerlink" title="6.请说说你认为C#中 &#x3D;&#x3D; 和 Equals 的区别是什么？"></a>6.请说说你认为C#中 &#x3D;&#x3D; 和 Equals 的区别是什么？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">1. == 是运算符，Equals是万物之父Object中的虚方法，子类可以重写</span>
<span style="color: red;">2.Equals 一般再子类中重写后用于比较两个对象中的内容是否相同
	==在没有运算符重载的前提下时
	引用类型用于比较地址；值类型用于比较值是否相同
3.运算效率不同，一般Equals没有==效率高，因为一般Equals比较的内容比==读多
</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="7-浅拷贝和深拷贝的区别？"><a href="#7-浅拷贝和深拷贝的区别？" class="headerlink" title="7. 浅拷贝和深拷贝的区别？"></a>7. 浅拷贝和深拷贝的区别？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">浅拷贝：
	只是复制对象的引用地址
</span><span style="color: red;">深拷贝：
	计算机在内存上重新开辟了一个空间，把对象的引用地址和值圈复制过来，两个对象是独立存在的。
</span>举例：
	比如引用对象A和引用对象B
	让A = B，就是浅拷贝，此时A、B的引用地址相同，改A中内容，B也变
	如果想要深拷贝，简单处理就是new（包括对象中的成员）
</code></pre>
</details></blockquote>
<hr>
<h2 id="8-上面两种获10000个数的方式，哪种效率更高？为什么"><a href="#8-上面两种获10000个数的方式，哪种效率更高？为什么" class="headerlink" title="8. 上面两种获10000个数的方式，哪种效率更高？为什么"></a>8. 上面两种获10000个数的方式，哪种效率更高？为什么</h2><blockquote>
<p><img src="https://skymirror-1316984539.cos.ap-beijing.myqcloud.com/Typoraimage-20250731202257832.png" alt="image-20250731202257832"></p>
</blockquote>
<blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">方式2的效率更高
因为List本质是数组，我们通过Add往List中添加元素时，会不断的触发扩容
扩容会带来内存和性能上的消耗
内存方面：每次扩容会产生垃圾，还会造成GC的触发
性能方面：每次扩容会进行“搬家”（老数组中内容存入新数组中）</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="9-请说出以上代码：1-A处和B处谁先打印？-2-A、B出打印的i值分别是多少？"><a href="#9-请说出以上代码：1-A处和B处谁先打印？-2-A、B出打印的i值分别是多少？" class="headerlink" title="9. 请说出以上代码：1.A处和B处谁先打印？ 2. A、B出打印的i值分别是多少？"></a>9. 请说出以上代码：1.A处和B处谁先打印？ 2. A、B出打印的i值分别是多少？</h2><blockquote>
<img src="https://skymirror-1316984539.cos.ap-beijing.myqcloud.com/Typoraimage-20250731202607327.png" alt="image-20250731202607327" style="zoom: 67%;" /></blockquote>
<blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
1.B处先打印，A处后打印
2.A处 i = 10，B处 i = 11</span>
<span style="color: red;">解析：
try → catch（如果有异常） → finally
</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="10-泛型的约束有哪几种？"><a href="#10-泛型的约束有哪几种？" class="headerlink" title="10.泛型的约束有哪几种？"></a>10.泛型的约束有哪几种？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
1.值类型约束 T:struct
2.引用类型约束 T:class
3.公共无参构造约束 T:new()
4.类约束 T:类名
5.接口约束 T:接口名
6.另一个泛型约束 T:U</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="11-什么是闭包？可以举例说明"><a href="#11-什么是闭包？可以举例说明" class="headerlink" title="11 . 什么是闭包？可以举例说明"></a>11 . 什么是闭包？可以举例说明</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">闭包是指有权访问另一个函数作用域中的变量的函数
所以闭包一般都是指的一个函数
创建这种特殊闭包函数的方式往往是在一个函数中创建另一个函数</span>
</code></pre>
</details></blockquote>
<h2 id="12-内存泄漏指什么？常见的内存泄漏有哪些？"><a href="#12-内存泄漏指什么？常见的内存泄漏有哪些？" class="headerlink" title="12 . 内存泄漏指什么？常见的内存泄漏有哪些？"></a>12 . 内存泄漏指什么？常见的内存泄漏有哪些？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">内存泄漏是指某些对象废弃了，不想使用了，但是不能被GC垃圾回收，一直占用者内存</span>
<span style="color: red;">常见的内存泄漏有：
1.静态引用
2.不使用的引用对象没有置null，一直被引用
3.文件操作时，没有使用using或者没有进行Dispose()
4.委托或事件注册后没有解除注册（有加就有减）</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="13-序列化是什么？常见的序列化方式有哪些？什么时候我们会用到序列化？"><a href="#13-序列化是什么？常见的序列化方式有哪些？什么时候我们会用到序列化？" class="headerlink" title="13. 序列化是什么？常见的序列化方式有哪些？什么时候我们会用到序列化？"></a>13. 序列化是什么？常见的序列化方式有哪些？什么时候我们会用到序列化？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
	序列化是将程序中数据对象转换为可以存储或传输的形式 的过程。
举例：
比如我们常见的序列化方式 xml、Json、2进制等。就是将内存中的数据按照我们自己定义的规则进行序列化，序列化之后就可以用于存储和传输，当读取和接受数据时，只需要按照对应规则进行反序列化便可得到原始数据
所谓的存储读取和传输接受，其实一般指的就是数据持久化和网络通讯
所以我们经常会在这两块知识点看到序列化反序列化这两个关键词</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="14-请说明以下三者的区别"><a href="#14-请说明以下三者的区别" class="headerlink" title="14. 请说明以下三者的区别"></a>14. 请说明以下三者的区别</h2><blockquote>
<p>string str &#x3D; null<br>string str &#x3D; “”<br>string str &#x3D; string.Empty</p>
</blockquote>
<blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
str = null 在堆中没有分配内存地址
str = "" 和 string.Empty 一样都是在堆内存中分配了空间，里面存储的是空字符串
而string.Empty是一个静态只读变量</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="15-C-重载运算符，重载-和-以及-万物之父Object基类中的虚方法-virtual-bool-Equals-Object-obj-对于我们的意义是什么？"><a href="#15-C-重载运算符，重载-和-以及-万物之父Object基类中的虚方法-virtual-bool-Equals-Object-obj-对于我们的意义是什么？" class="headerlink" title="15. C#重载运算符，重载 &#x3D;&#x3D; 和 !&#x3D; 以及 万物之父Object基类中的虚方法 virtual bool Equals(Object obj)对于我们的意义是什么？"></a>15. C#重载运算符，重载 &#x3D;&#x3D; 和 !&#x3D; 以及 万物之父Object基类中的虚方法 virtual bool Equals(Object obj)对于我们的意义是什么？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">1.重载== 和！=
	因为默认== 和！=对于引用类型是判断对象引用是否相等
	重写这个可以自定义判断对象里面的值，而不是引用
</span>
<span style="color: red;">2.重载 Equals
	如果想保留判断引用地址（保留==）相等，就重写Equals
</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="16-在开发时，对string和StringBuilder我们应该如何选择"><a href="#16-在开发时，对string和StringBuilder我们应该如何选择" class="headerlink" title="16.在开发时，对string和StringBuilder我们应该如何选择"></a>16.在开发时，对string和StringBuilder我们应该如何选择</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
string在每次拼接时都会产生垃圾
而StringBuilder在拼接时，是在原空间中进行修改，不会产生垃圾，会自动帮助我们扩容
所以当字符串需要频繁修改拼接时，我们使用StringBuilder</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="17-请简要说明-Net跨语言原理"><a href="#17-请简要说明-Net跨语言原理" class="headerlink" title="17. 请简要说明.Net跨语言原理"></a>17. 请简要说明.Net跨语言原理</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
.Net制定了了CLI公共语言基础结构的规则
只要是按照该规则设计的语言在进行.Net相关开发时
编译器会将源代码（C#、VB等等）编译为CIL通用中间代码。
也就是说不管什么语言进行开发，最终都会统一规范变为中间代码
最终通过CLR（公共语言运行时或者称为.Net虚拟）将中间代码翻译为对应操作系统的原生代码（机器码）
在操作系统（Windows）上运行</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="18-请简要说明-Net跨平台原理"><a href="#18-请简要说明-Net跨平台原理" class="headerlink" title="18. 请简要说明.Net跨平台原理"></a>18. 请简要说明.Net跨平台原理</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
由于.Net Framework中利用CLI和CLR实现了跨语言，CLR主要起到一个翻译、运行、管理中间代码的作用
.Net Core和Mono就是利用了CLR的这一特点，为不同操作系统实现对应CLR（公共语言运行时或.Net虚拟机）
那么不同操作系统对应的CLR就会将IL中间代码翻译为对应系统可以执行的原生代码（机器码）
达到跨平台的目的</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="19-数组和链表的区别是什么？"><a href="#19-数组和链表的区别是什么？" class="headerlink" title="19. 数组和链表的区别是什么？"></a>19. 数组和链表的区别是什么？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
1.存储结构不同
数组是顺序存储结构，在内存中是连续存储的
链表是链式存储结构，在内存中是非连续存储的
-----------------------------------------------------------
2.访问效率不同
数组由于是顺序存储，通过下标访问，访问效率高
链表由于是非连续存储，我们想要获取其中某一元素，需要从头或尾遍历，效率低
------------------------------------------------------------
3.插入、删除效率不同
数组由于是顺序存储，在插入和删除时，需要整体移动数组中的大部分元素，效率低
链表由于是链式存储，在插入和删除时，效率高
---------------------------------------------------------------
4.越界问题
数组由于是顺序存储，声明时容量是固定的，如果不处理扩容逻辑，存在越界风险
链表由于是链式存储，无越界风险</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="20-C-中的Action和Func是什么？Unity-中的UnityAction是什么？他们有什么区别？"><a href="#20-C-中的Action和Func是什么？Unity-中的UnityAction是什么？他们有什么区别？" class="headerlink" title="20. C# 中的Action和Func是什么？Unity 中的UnityAction是什么？他们有什么区别？"></a>20. C# 中的Action和Func是什么？Unity 中的UnityAction是什么？他们有什么区别？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
Action和Func是System命名空间下 C#为我们提供的两个写好的委托
Action本身是一个无参无返回值的委托
对应的Action<>泛型委托支持最多16个参数
-------------------------------------------
Func本身是一个无参有返回值的委托
对应的Func<>泛型委托支持最多16个参数，并且有返回值
------------------------------------------------
UnityAction是UnityEngine.Events命名空间下 Unity为我们提供的写好的委托
UnityAction本身是一个无参无返回值的委托
对应的UnityAction<>泛型委托支持最多4个参数</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="21-（结构体中的引用类型）请问最终得到打印结果是什么？？"><a href="#21-（结构体中的引用类型）请问最终得到打印结果是什么？？" class="headerlink" title="21. （结构体中的引用类型）请问最终得到打印结果是什么？？"></a>21. （结构体中的引用类型）请问最终得到打印结果是什么？？</h2><blockquote>
<img src="https://skymirror-1316984539.cos.ap-beijing.myqcloud.com/Typoraimage-20250731223017846.png" alt="image-20250731223017846" style="zoom: 50%;" />

<img src="https://skymirror-1316984539.cos.ap-beijing.myqcloud.com/Typoraimage-20250731223029521.png" alt="image-20250731223029521" style="zoom:50%;" />

<img src="https://skymirror-1316984539.cos.ap-beijing.myqcloud.com/Typoraimage-20250731223037047.png" alt="image-20250731223037047" style="zoom: 50%;" /></blockquote>
<blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
0-Alice-7
考点：
1.值和引用的区别
2.特殊引用类型string
3.结构体中的引用成员</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="22-C-中如何让自定义容器类能够使用for循环遍历？（通过-类对象-索引-的形式遍历）"><a href="#22-C-中如何让自定义容器类能够使用for循环遍历？（通过-类对象-索引-的形式遍历）" class="headerlink" title="22. C#中如何让自定义容器类能够使用for循环遍历？（通过 类对象[索引] 的形式遍历）"></a>22. C#中如何让自定义容器类能够使用for循环遍历？（通过 类对象[索引] 的形式遍历）</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
通过在类中实现索引器实现</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="23-C-中如何让自定义容器类能够使用foreach循环遍历？"><a href="#23-C-中如何让自定义容器类能够使用foreach循环遍历？" class="headerlink" title="23. C#中如何让自定义容器类能够使用foreach循环遍历？"></a>23. C#中如何让自定义容器类能够使用foreach循环遍历？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
通过为该类实现迭代器可以让其使用foreach遍历
传统方式：
继承IEnumerator、IEnumerable两个接口
实现其中的 
1.GetEnumerator方法
2.Current属性
3.MoveNext方法
语法糖方式：
利用yield return语法糖，实现GetEnumerator方法即可完成迭代器的实现</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="24-C-中接口的作用是什么？说说你的理解"><a href="#24-C-中接口的作用是什么？说说你的理解" class="headerlink" title="24. C#中接口的作用是什么？说说你的理解"></a>24. C#中接口的作用是什么？说说你的理解</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
用于建立行为的继承关系，而不是对象
不同对象，有相同行为时，我们可以利用接口对不同对象的行为进行整合（里氏替换原则）</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="25-请问以上这三行代码，运行后，在堆上会分配几个“房间”"><a href="#25-请问以上这三行代码，运行后，在堆上会分配几个“房间”" class="headerlink" title="25. 请问以上这三行代码，运行后，在堆上会分配几个“房间”"></a>25. 请问以上这三行代码，运行后，在堆上会分配几个“房间”</h2><blockquote>
<img src="https://skymirror-1316984539.cos.ap-beijing.myqcloud.com/Typoraimage-20250731224718174.png" alt="image-20250731224718174" style="zoom:33%;" /></blockquote>
<blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
2个房间
"123"一个房间
"1234"一个房间</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="26-C-中如何让一个类不能再被其他类所继承？"><a href="#26-C-中如何让一个类不能再被其他类所继承？" class="headerlink" title="26. C#中如何让一个类不能再被其他类所继承？"></a>26. C#中如何让一个类不能再被其他类所继承？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
使用密封关键字sealed修饰该类</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="27-C-中元组对于我们的作用是什么？"><a href="#27-C-中元组对于我们的作用是什么？" class="headerlink" title="27. C#中元组对于我们的作用是什么？"></a>27. C#中元组对于我们的作用是什么？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
可以在不用写数据结构类的情况下
利用元组处理多返回值，或者临时数据的集合</span>
</code></pre>
</details></blockquote>
<blockquote>
<p><img src="https://skymirror-1316984539.cos.ap-beijing.myqcloud.com/Typoraimage-20250802114754726.png" alt="image-20250802114754726"></p>
</blockquote>
<hr>
<h2 id="28-C-中使用泛型的好处是什么？"><a href="#28-C-中使用泛型的好处是什么？" class="headerlink" title="28. C#中使用泛型的好处是什么？"></a>28. C#中使用泛型的好处是什么？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
1.可以为不同类型对象的相同行为进行通用处理，提升代码复用率
2.避免装箱拆箱，提升性能</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="29-请说明Thread、ThreadPool、Task分别是什么？并简单说明彼此的区别"><a href="#29-请说明Thread、ThreadPool、Task分别是什么？并简单说明彼此的区别" class="headerlink" title="29. 请说明Thread、ThreadPool、Task分别是什么？并简单说明彼此的区别"></a>29. 请说明Thread、ThreadPool、Task分别是什么？并简单说明彼此的区别</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
Thread是线程，可以使用他开启线程处理复杂逻辑，避免主线程卡顿
ThreadPool是线程池，他是C#为线程实现的缓存池，主要用于减少线程的创建，减少GC触发
Task是任务，他是基于线程池的优化，让我们可以更方便的控制线程
ThreadPool无法控制线程池中线程的执行顺序,并且无法得到当前线程的执行状态。Task的优化的点就在这</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="30-请简述GC（垃圾回收）产生的原因，并至少说出避免GC发生的三种方式？"><a href="#30-请简述GC（垃圾回收）产生的原因，并至少说出避免GC发生的三种方式？" class="headerlink" title="30.请简述GC（垃圾回收）产生的原因，并至少说出避免GC发生的三种方式？"></a>30.请简述GC（垃圾回收）产生的原因，并至少说出避免GC发生的三种方式？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">GC产生的原因是，当我们不使用的堆内存占用达到一个上限时，将会使用算法对垃圾进行回收，不同的语言垃圾回收机制是不一样的
Unity:BoehmGC(贝母垃圾回收器，这个主要是IL2CPP下的算法，现在大部分游戏的编译方法都是这个)
	贝母会调用一个第三方库，那个库在进行垃圾回收的时候，会停止正在运行的程序，在完成所有工作之后才会执行。
	所以就会导致程序可能突然就会延迟执行，游戏也就会掉帧。所以为了优化，贝母把CG的工作平均分配给n帧
	就是怕所有GC都集中在几帧上，出现严重掉帧。
	他主要是渐进式的GC模式，把GC的工作分配到多个帧上来减少GC尖峰破坏动画的流畅性。
Lua采用基于标记-清除（Mark-and-Sweep）的垃圾回收机制，核心通过三色增量标记算法实现低开销回收。标记阶段从根对象出发，递归标记存活对象（黑色），未访问对象为白色，灰色对象表示待处理；通过分步执行（如每次执行一步GC并交还控制权），避免长时间停顿，适合实时性要求高的场景（如游戏脚本）。但标记-清除不移动对象，易产生内存碎片，需依赖内部碎片整理或手动触发紧凑阶段缓解。
------------------------------------------
C#采用分代回收（Generational GC）策略，将对象分为三代（0代、1代、2代），年轻代（0代）使用复制算法快速回收短生命周期对象，老年代（2代）通过标记-整理（Mark-and-Compact）消除碎片并压缩内存。
具体如下：
https://www.cnblogs.com/zblade/p/11357203.html
--------------------------------------------------------------
避免GC的方式：
	1.避免大量对象的重复创建，尽量复用对象（对象池）
	2.用StringBuilder替换String，避免字符串拼接时产生的垃圾
	3.尽量避免拆装箱
	4.公共对象用静态声明
</span>
<span style="color: red;">2.装箱——把堆中内容迁移到栈中去（引用转值）</span>
3.如果问到值类型和引用类型同样，要引申这个
</code></pre>
</details></blockquote>
<hr>
<h2 id="31-如果我们想为Unity中的Transform类添加一个自定义的方法，应该如何处理？"><a href="#31-如果我们想为Unity中的Transform类添加一个自定义的方法，应该如何处理？" class="headerlink" title="31. 如果我们想为Unity中的Transform类添加一个自定义的方法，应该如何处理？"></a>31. 如果我们想为Unity中的Transform类添加一个自定义的方法，应该如何处理？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
使用C#扩展方法
1.扩展方法需包含在 static 修饰类中。
2.扩展实现需是静态形式。
3.扩展方法第一个参数 前缀为 this , 表示需要扩展类对象，从第二个参数开始，为扩展方法参数列表。</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="32-请说出using关键字的两个作用"><a href="#32-请说出using关键字的两个作用" class="headerlink" title="32. 请说出using关键字的两个作用"></a>32. 请说出using关键字的两个作用</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
1.引入命名空间
2.安全使用引用对象</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="33-C-中Dictionary不支持相同键存储如果想要一个键对应多个值如何处理？"><a href="#33-C-中Dictionary不支持相同键存储如果想要一个键对应多个值如何处理？" class="headerlink" title="33. C#中Dictionary不支持相同键存储如果想要一个键对应多个值如何处理？"></a>33. C#中Dictionary不支持相同键存储如果想要一个键对应多个值如何处理？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
一个键，对于一个对象容器
比如：<键，泛型列表>，<键，数组>，<键，栈>
</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="34-请问上面代码的最终打印结果是什么？为什么？"><a href="#34-请问上面代码的最终打印结果是什么？为什么？" class="headerlink" title="34. 请问上面代码的最终打印结果是什么？为什么？"></a>34. 请问上面代码的最终打印结果是什么？为什么？</h2><blockquote>
<img src="https://skymirror-1316984539.cos.ap-beijing.myqcloud.com/Typoraimage-20250802143030518.png" alt="image-20250802143030518" style="zoom:33%;" /></blockquote>
<blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
全是10
当委托最终执行时，他们使用的i，都是for循环中声明的i，此时的i已经变成了10</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="35-上题中的代码，如果我们希望打印出0-9，应该如何修改代码？"><a href="#35-上题中的代码，如果我们希望打印出0-9，应该如何修改代码？" class="headerlink" title="35.上题中的代码，如果我们希望打印出0~9，应该如何修改代码？"></a>35.上题中的代码，如果我们希望打印出0~9，应该如何修改代码？</h2><blockquote>
<img src="https://skymirror-1316984539.cos.ap-beijing.myqcloud.com/Typoraimage-20250802143711028.png" alt="image-20250802143711028" style="zoom:25%;" /></blockquote>
<hr>
<h2 id="36-内存中，堆和栈的区别是什么？"><a href="#36-内存中，堆和栈的区别是什么？" class="headerlink" title="36. 内存中，堆和栈的区别是什么？"></a>36. 内存中，堆和栈的区别是什么？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
堆和栈是操作系统堆进程占用的内存空间的两种管理方式
-----------------------------------------------
栈：由操作系统自动分配释放，存放函数的参数值，局部变量值，栈中数据的生命周期随着函数的执行完成而结束
-------------------------------------------------------
堆：一般由程序员分配释放，如果开发人员不释放，程序结束时由操作系统回收
（在C#中 托管堆内存 会由 C#帮助我们管理，存在GC垃圾回收机制）</span>
<span style="color: red;">2.装箱——把堆中内容迁移到栈中去（引用转值）</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="37-TCP协议和UDP协议的区别"><a href="#37-TCP协议和UDP协议的区别" class="headerlink" title="37.TCP协议和UDP协议的区别"></a>37.TCP协议和UDP协议的区别</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
连接方面：TCP面向连接，UDP无连接
是否可靠：TCP可靠（无差错、不丢失、不重复、按顺序），UDP不可靠
传输效率：TCP相对UDP较低
连接对象：TCP一对一，UDP n对n</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="38-TCP协议的可靠性是如何达到的？"><a href="#38-TCP协议的可靠性是如何达到的？" class="headerlink" title="38. TCP协议的可靠性是如何达到的？"></a><code>38</code>. TCP协议的可靠性是如何达到的？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
TCP协议是通过 检验和、确认应答信号、重发机制、连接管理、流量控制、拥塞控制等手段达到可靠的
具体的一些理论知识，可以浏览该文章
http://www.360doc.com/content/22/1111/20/78411425_1055522293.shtml</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="39-内存抖动指什么？如何避免内存抖动"><a href="#39-内存抖动指什么？如何避免内存抖动" class="headerlink" title="39. 内存抖动指什么？如何避免内存抖动"></a>39. 内存抖动指什么？如何避免内存抖动</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
内存抖动指短时间内有大量的对象被创建或者被回收的现象
频繁的内存抖动会造成 GC 频繁运行，造成卡顿
避免方式：
对象池
享元模式
等</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="40-文件中保存了文本信息，但是打开后却是乱码，一般是什么原因造成的？"><a href="#40-文件中保存了文本信息，但是打开后却是乱码，一般是什么原因造成的？" class="headerlink" title="40. 文件中保存了文本信息，但是打开后却是乱码，一般是什么原因造成的？"></a>40. 文件中保存了文本信息，但是打开后却是乱码，一般是什么原因造成的？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
序列化和反序列化字符串时使用的编码格式不统一
比如：序列化时使用UTF—8，反序列化时使用Unicode</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="41-C-中new关键字的作用（至少说出3种）"><a href="#41-C-中new关键字的作用（至少说出3种）" class="headerlink" title="41. C#中new关键字的作用（至少说出3种）"></a>41. C#中new关键字的作用（至少说出3种）</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
1. 创建新对象
2. 子类函数声明时加上new关键字，可以隐藏掉父类方法
3. 泛型约束中使用new关键词，表示需要无参构造</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="42-同步方法和异步方法的区别是什么？异步编程是什么意思？"><a href="#42-同步方法和异步方法的区别是什么？异步编程是什么意思？" class="headerlink" title="42. 同步方法和异步方法的区别是什么？异步编程是什么意思？"></a>42. 同步方法和异步方法的区别是什么？异步编程是什么意思？</h2><p>对于我们来说，什么时候需要使用异步编程？（至少说出3种）</p>
<blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
同步方法：
当一个方法被调用时，调用者需要等待该方法执行完毕后返回才能继续执行
--------------------------------------------------------------
异步方法：
当一个方法被调用时立即返回，并获取一个线程执行该方法内部的逻辑，调用者不用等待该方法执行完毕
------------------------------------------------------------------------------
异步编程：
在日常开发时把一些不需要立即得到结果且耗时的逻辑设置为异步执行，这样可以提高程序的运行效率，避免由于复杂逻辑带来的的线程阻塞
-------------------------------------------------------------
什么时候需要使用异步编程：
1.复杂逻辑计算时，比如寻路算法等
2.网络下载、网路通讯
3.资源加载时
等</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="43-回调函数指什么？一般在什么时候使用？（至少说出3种使用场景）"><a href="#43-回调函数指什么？一般在什么时候使用？（至少说出3种使用场景）" class="headerlink" title="43. 回调函数指什么？一般在什么时候使用？（至少说出3种使用场景）"></a>43. 回调函数指什么？一般在什么时候使用？（至少说出3种使用场景）</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
回调函数指在程序设计中，将一个函数作为参数传递给另一个函数，并在另一个函数执行完毕后被调用的函数，在C#中，一般以委托形式出现
------------------------------------------------------------------
什么时候使用：
1.异步编程：异步逻辑执行完毕后，再执行回调函数
2.事件中心
3.UI界面中的空间逻辑回调，比如按钮点击
等等</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="44-如何用一个int变量，记录32种状态？（注意：状态可以并存）"><a href="#44-如何用一个int变量，记录32种状态？（注意：状态可以并存）" class="headerlink" title="44. 如何用一个int变量，记录32种状态？（注意：状态可以并存）"></a>44. 如何用一个int变量，记录32种状态？（注意：状态可以并存）</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
int在C#中占4个字节，共32位
我们可以按位记录状态，每一位代表一个状态，1为存在，0为不存在</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="45-csharp里面有一个常用的接口叫做IDispose，它的作用是？"><a href="#45-csharp里面有一个常用的接口叫做IDispose，它的作用是？" class="headerlink" title="45. csharp里面有一个常用的接口叫做IDispose，它的作用是？"></a>45. csharp里面有一个常用的接口叫做IDispose，它的作用是？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
IDispose接口是 C# 中用于手动释放资源的机制
通过显式调用 Dispose() 方法来实现资源的释放，避免资源泄漏和浪费
它允许对象在不再需要时显式地释放资源，而不依赖于垃圾回收器的自动内存管理</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="46-上一题追问：csharp有垃圾回收机制，把一个对象设置为空的时候，系统会帮我们回收，它和接口IDispose有什么关系吗？为什么会存在两个做析构事情的东西呢？"><a href="#46-上一题追问：csharp有垃圾回收机制，把一个对象设置为空的时候，系统会帮我们回收，它和接口IDispose有什么关系吗？为什么会存在两个做析构事情的东西呢？" class="headerlink" title="46. 上一题追问：csharp有垃圾回收机制，把一个对象设置为空的时候，系统会帮我们回收，它和接口IDispose有什么关系吗？为什么会存在两个做析构事情的东西呢？"></a>46. 上一题追问：csharp有垃圾回收机制，把一个对象设置为空的时候，系统会帮我们回收，它和接口IDispose有什么关系吗？为什么会存在两个做析构事情的东西呢？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
C#中的垃圾回收机制，只会回收托管堆上分配的对象。
对于非托管资源以及其它需要显示释放的资源，垃圾回收是无法自动处理的，因为这些资源不属于托管堆，因此垃圾回收器无法自动识别和回收。这种情况下我们就需要显示的手动释放这些资源了。
而IDispose接口就提供了一种通用的机制来进行资源清理，主要用于释放非托管资源。
----------------------------------------------------------------
非托管资源：
1.文件句柄，在操作系统中打开的文件等
2.数据库链接，与数据库服务器简历的链接
3.网络链接：比如Socket的连接对象
4.unsafe关键词中使用的指针
等等</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="47-C-中哪些变量类型是值类型（至少说出13种），哪些是引用该类型（至少说出5种）"><a href="#47-C-中哪些变量类型是值类型（至少说出13种），哪些是引用该类型（至少说出5种）" class="headerlink" title="47. C#中哪些变量类型是值类型（至少说出13种），哪些是引用该类型（至少说出5种）"></a>47. C#中哪些变量类型是值类型（至少说出13种），哪些是引用该类型（至少说出5种）</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
值类型：
int、float、double、byte、short、long、uint、ulong、uint、sbyte、decimal、char、bool、自定义结构体
----------------------------------------------------------------------------
引用类型：
自定义类、数组、字符串、委托、接口、Object</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="48-在自定义类中声明的成员变量，类型为int，该int变量存储在栈上还是堆上？在自定义结构体中声明的成员变量，类型为string，该string变量存储在栈上还是堆上？"><a href="#48-在自定义类中声明的成员变量，类型为int，该int变量存储在栈上还是堆上？在自定义结构体中声明的成员变量，类型为string，该string变量存储在栈上还是堆上？" class="headerlink" title="48. 在自定义类中声明的成员变量，类型为int，该int变量存储在栈上还是堆上？在自定义结构体中声明的成员变量，类型为string，该string变量存储在栈上还是堆上？"></a>48. 在自定义类中声明的成员变量，类型为int，该int变量存储在栈上还是堆上？<code>在自定义结构体中声明的成员变量，类型为string，该string变量存储在栈上还是堆上</code>？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
1.堆上
自定义类中声明的成员变量，无论什么类型，都会存储在堆上。
类（引用类型）的实例本身存储在堆上，而成员变量也存储在该实例所指向的内存区域（堆上）
---------------------------------------------------------------------------
2.堆上
在结构体变量中的引用类型成员实际上会存储在堆上。虽然结构体本身是值类型，存储在栈上，但是如果结构体的成员包含引用类型，那么引用类型的对象会存储在堆上，而结构体的实例内部会包含对这些堆上对象的引用。</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="49-C-中在什么情况下会选择使用接口，什么情况下会选择使用抽象类？"><a href="#49-C-中在什么情况下会选择使用接口，什么情况下会选择使用抽象类？" class="headerlink" title="49.C#中在什么情况下会选择使用接口，什么情况下会选择使用抽象类？"></a>49.C#中在什么情况下会选择使用接口，什么情况下会选择使用抽象类？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
接口：
1.不同对象的共同行为
2.需要多继承时
---------------------------------------------------
抽象类：
1.同类对象的共同行为
2.共享成员变量</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="50-C-中什么是托管内存和非托管内存？"><a href="#50-C-中什么是托管内存和非托管内存？" class="headerlink" title="50. C#中什么是托管内存和非托管内存？"></a>50. C#中什么是托管内存和非托管内存？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
托管内存：
托管内存是由.NET运行时（CLR，Common Language Runtime）进行管理的内存
C#中大部分对象都是托管内存，它们的内存分配、回收和资源管理都由CLR负责
。CLR提供了自动垃圾回收机制（GC），可以自动检测不再使用的对象并释放它们占用的内存，从而避免了内存泄漏问题。
--------
比如我们平时声明的引用类型的变量都属于托管内存
--------------------------------------------------------------------------
非托管内存：
非托管内存是由应用程序自己负责管理的内存，它通常是通过调用本机API或与外部系统进行交互时使用的。非托管内存可能不受CLR的管理，这意味着它不会受到垃圾回收的影响。但是，这也意味着开发人员需要自己负责内存的分配和释放，否则可能会导致内存泄漏或者访问无效内存的问题。
----------------
比如我们平时声明的 unsafe语句块中的指针成员，数据库链接对象，Socket通讯对象，文件流等对象都存在非托管内存，需要我们自己释放</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="51-请问什么是线程安全？如何在C-中实现线程安全操作？"><a href="#51-请问什么是线程安全？如何在C-中实现线程安全操作？" class="headerlink" title="51. 请问什么是线程安全？如何在C#中实现线程安全操作？"></a>51. 请问什么是线程安全？如何在C#中实现线程安全操作？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
什么是线程安全？
是指在多线程环境中，对共享资源（如数据、变量、对象等）进行操作时，不会产生不正确的结果或不可预期的行为。在多线程程序中，由于多个线程可以同时访问和修改共享资源，如果没有适当的同步机制，就可能会导致数据损坏、竞态条件（Race Condition）和其他错误
---------------------------------------
数据损坏：数据损坏是指数据在存储、传输或处理过程中发生错误，导致数据的内容或结构出现不一致、不正确或不完整的情况
------------------------------------------
竞态条件：多个线程试图同时访问和修改共享资源（如变量、数据结构、文件等），从而导致程序的行为出现不确定性或不正确的结果。竞态条件可能会导致程序的运行结果与预期不符，产生难以预测和复现的错误
---------------------------------------
如何在C#中实现线程安全操作？
使用锁（Lock）、异步编程（async、await）等方式</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="52-C-中属性-Property-和字段-Field-的区别是什么？"><a href="#52-C-中属性-Property-和字段-Field-的区别是什么？" class="headerlink" title="52. C#中属性(Property)和字段(Field)的区别是什么？"></a>52. C#中属性(Property)和字段(Field)的区别是什么？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
属性一般可以用来封装字段
-----------------------------------------
属性相对字段来说，属性具有封装性，允许对字段进行封装，提供更多的控制和逻辑。
相比直接访问字段来说，属性允许我们在字段访问的过程汇总添加验证、计算等逻辑
------------------------------------------
属性还可以在其中对set和get设置不同的访问级别，使得字段的读取和写入可以收到更精细的控制</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="53-请解释一下C-中的异步编程模型（Async-Await），它是用来做什么的？"><a href="#53-请解释一下C-中的异步编程模型（Async-Await），它是用来做什么的？" class="headerlink" title="53. 请解释一下C#中的异步编程模型（Async&#x2F;Await），它是用来做什么的？"></a>53. 请解释一下C#中的异步编程模型（Async&#x2F;Await），它是用来做什么的？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
C#中的异步编程模型是一种用于处理并发任务的技术
允许在执行异步操作时，让程序继续执行其他任务，而不会阻塞主线程。这对于处理诸如网络请求、文件读写、长时间计算等耗时操作非常有用</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="54-抽象类中的虚函数和抽象函数，是否必须在子类中重写？"><a href="#54-抽象类中的虚函数和抽象函数，是否必须在子类中重写？" class="headerlink" title="54. 抽象类中的虚函数和抽象函数，是否必须在子类中重写？"></a>54. 抽象类中的虚函数和抽象函数，是否必须在子类中重写？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
子类中
虚函数的重写是可选的，当需要在子类中修改逻辑时可以选择重写
抽象函数必须重写</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="55-当我们使用里式替换原则，用父类容器装载子类对象时我们通过该父类容器调用其中的一个虚函数，执行的逻辑是父类中的还是子类中的逻辑呢？"><a href="#55-当我们使用里式替换原则，用父类容器装载子类对象时我们通过该父类容器调用其中的一个虚函数，执行的逻辑是父类中的还是子类中的逻辑呢？" class="headerlink" title="55. 当我们使用里式替换原则，用父类容器装载子类对象时我们通过该父类容器调用其中的一个虚函数，执行的逻辑是父类中的还是子类中的逻辑呢？"></a>55. 当我们使用里式替换原则，用父类容器装载子类对象时我们通过该父类容器调用其中的一个虚函数，执行的逻辑是父类中的还是子类中的逻辑呢？</h2><blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Father  Eat</span><br><span class="line">Son ：Father</span><br><span class="line">Son Eat</span><br><span class="line"></span><br><span class="line">Father f = <span class="keyword">new</span> Son();</span><br><span class="line">f.Eat();</span><br></pre></td></tr></table></figure></blockquote>
<blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：  
1.若子类没有重写虚函数，那么执行的逻辑会是父类中的逻辑
2.若子类重写了虚函数，那么执行的逻辑会是子类中的逻辑（是否执行父类中逻辑，主要看子类重写时是否利用了base执行父类逻辑）
vob</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="56-我们在游戏开发时，想要获取系统时间，应该如何获取？"><a href="#56-我们在游戏开发时，想要获取系统时间，应该如何获取？" class="headerlink" title="56. 我们在游戏开发时，想要获取系统时间，应该如何获取？"></a>56. 我们在游戏开发时，想要获取系统时间，应该如何获取？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
利用C#中提供的DateTime类（System命名空间中）
DateTime中的 DateTime.Now 静态成员
可以获取到当前的系统时间</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="57-C-使用var声明临时变量相比用指定变量类型声明临时变量，在最终执行时是否会增加性能消耗？"><a href="#57-C-使用var声明临时变量相比用指定变量类型声明临时变量，在最终执行时是否会增加性能消耗？" class="headerlink" title="57. C#使用var声明临时变量相比用指定变量类型声明临时变量，在最终执行时是否会增加性能消耗？"></a>57. C#使用var声明临时变量相比用指定变量类型声明临时变量，在最终执行时是否会增加性能消耗？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
不会，var在编译时会被推断为正确的类型，所以在运行时不会引入额外的性能开销。
相当于在编译阶段var就会被翻译为指定的类型。
----------------------------------------------
var声明临时变量只会影响代码的可读性和可维护性(双刃剑)</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="58-我们知道，上述代码b改为20后，a还是10。（值类型的特点）我们是否可以简单修改以上代码，让b变成20后，a跟着一起变。"><a href="#58-我们知道，上述代码b改为20后，a还是10。（值类型的特点）我们是否可以简单修改以上代码，让b变成20后，a跟着一起变。" class="headerlink" title="58. 我们知道，上述代码b改为20后，a还是10。（值类型的特点）我们是否可以简单修改以上代码，让b变成20后，a跟着一起变。"></a>58. 我们知道，上述代码b改为20后，a还是10。（值类型的特点）我们是否可以简单修改以上代码，让b变成20后，a跟着一起变。</h2><p>请说出修改方案</p>
<blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">int</span> b = a;</span><br><span class="line">b = <span class="number">20</span>;</span><br></pre></td></tr></table></figure></blockquote>
<blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
C#7中加入了ref的新用法，使用ref修饰临时变量和函数返回值，可以让赋值变为引用传递
Unity 2018.3及其以上支持C# 7 
---------------------------------------------
int a = 10;
ref int b =ref  a;
b = 20;</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="59-我们可以使用C-中的迭代器来做什么？至少说出两点"><a href="#59-我们可以使用C-中的迭代器来做什么？至少说出两点" class="headerlink" title="59. 我们可以使用C#中的迭代器来做什么？至少说出两点"></a>59. 我们可以使用C#中的迭代器来做什么？至少说出两点</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
1.foreach
2.协同程序</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="60-面向对象的七大原则分别是什么？并选择其中一个原则说明它的意思"><a href="#60-面向对象的七大原则分别是什么？并选择其中一个原则说明它的意思" class="headerlink" title="60. 面向对象的七大原则分别是什么？并选择其中一个原则说明它的意思"></a>60. 面向对象的七大原则分别是什么？并选择其中一个原则说明它的意思</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
单一职责原则：
一个类只处理自己应该处理的内容，不应该啥都写在一起
--------------------------------------------
开闭原则：
对拓展开放，对修改封闭。新加功能尽量是加处理而不是改代码
------------------------------------------------
里氏替换原则：
任何地方子类都能替代父类，父类容器装子类
-------------------------------------------------
依赖倒转原则：
不要依赖具体的实现，要依赖抽象（接口）
-------------------------------------------------
迪米特法则：
又称最少知识原则，一个类要尽量减少对别的类的了解，尽量少用别的类和自己关联
-------------------------------------------------------
接口隔离原则：
不应该强迫别人依赖他们不需要使用的方法
一个接口不需要提供太多的行为，一个接口应该尽量只提供一个对外的功能，让别人去选择需要实现什么样的行为，而不是把所有的行为都封装到一个接口当中
-----------------------------------------------------------------
合成复用原则：
尽量使用对象组合，而不是继承来达到复用的目的
继承关系是强耦合，组合关系是低耦合
除非设计上需要继承，否则尽量用组合复用的形式</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="61-为什么单例模式在游戏开发中很常用？至少说出3个优点"><a href="#61-为什么单例模式在游戏开发中很常用？至少说出3个优点" class="headerlink" title="61. 为什么单例模式在游戏开发中很常用？至少说出3个优点"></a>61. 为什么单例模式在游戏开发中很常用？至少说出3个优点</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
1.全局数据共享
2.确保唯一性
3.方便管理资源
4.方便管理对象
5.访问简单化
6.便于扩展
等等</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="62-工厂模式在游戏开发中一般用来做什么？"><a href="#62-工厂模式在游戏开发中一般用来做什么？" class="headerlink" title="62. 工厂模式在游戏开发中一般用来做什么？"></a>62. 工厂模式在游戏开发中一般用来做什么？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：  
对象实例化
对于需要频繁创建的对象，比如角色、敌人、道具、特效、音效等等，工厂模式可以将实例化逻辑封装到一个工厂类中，提供统一方法给外部调用</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="63-观察者设计模式在游戏开发中有什么作用？"><a href="#63-观察者设计模式在游戏开发中有什么作用？" class="headerlink" title="63. 观察者设计模式在游戏开发中有什么作用？"></a>63. 观察者设计模式在游戏开发中有什么作用？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
它可以让游戏系统之间松耦合，提高代码的可维护性和拓展性
比如在成就系统、任务系统中，我们可以利用观察者模式在不同系统中进行事件监听和分发
-----------------------------------------------------
一般都是建立的一对多的依赖关系，当一个对象状态改变时，依赖（监听）它的对象会得到通知进行逻辑执行（委托或事件执行）</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="64-C-中如何在函数中返回多个返回值？（至少说出3种方法）"><a href="#64-C-中如何在函数中返回多个返回值？（至少说出3种方法）" class="headerlink" title="64. C#中如何在函数中返回多个返回值？（至少说出3种方法）"></a>64. C#中如何在函数中返回多个返回值？（至少说出3种方法）</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
1.数组等容器
2.结构体或类自定义数据结构
3.out参数
4.元组</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="65-在游戏开发中，我们可以利用数据结构中的树参与哪些功能的制作？（至少说出3点）"><a href="#65-在游戏开发中，我们可以利用数据结构中的树参与哪些功能的制作？（至少说出3点）" class="headerlink" title="65. 在游戏开发中，我们可以利用数据结构中的树参与哪些功能的制作？（至少说出3点）"></a>65. 在游戏开发中，我们可以利用数据结构中的树参与哪些功能的制作？（至少说出3点）</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
1.场景中对象的关系，比如Unity中场景上的对象通过树形结构建立父子关系
可以方便我们查找对象，确定对象的层级关系等等
--------------------------------------------------------
2.行为树AI
--------------------------------------------------------
3.资源管理，资源之间的层级结构可以靠树建立
--------------------------------------------------------
4.技能系统，比如技能树的表现
--------------------------------------------------------
5.随机地图生成，比如“肉鸽”游戏中的随机地图，地图中的关系可以用树建立
--------------------------------------------------------
6.任务系统，比如游戏中的任务面板中的任务清单
--------------------------------------------------------
7.碰撞检测，碰撞检测的底层一般会采用四叉树或八叉树来加速碰撞检测
--------------------------------------------------------
等等</span>
<span style="color: red;">2.装箱——把堆中内容迁移到栈中去（引用转值）</span>
3.如果问到值类型和引用类型同样，要引申这个
</code></pre>
</details></blockquote>
<hr>
<h2 id="66-父类中定义了一个静态成员属性，有两个子类都继承该父类"><a href="#66-父类中定义了一个静态成员属性，有两个子类都继承该父类" class="headerlink" title="66. 父类中定义了一个静态成员属性，有两个子类都继承该父类"></a><code>66</code>. 父类中定义了一个静态成员属性，有两个子类都继承该父类</h2><p>请问打印结果是什么？为什么？</p>
<blockquote>
<img src="https://skymirror-1316984539.cos.ap-beijing.myqcloud.com/Typoraimage-20250808104133580.png" alt="image-20250808104133580" style="zoom: 25%;" />

<img src="https://skymirror-1316984539.cos.ap-beijing.myqcloud.com/Typoraimage-20250808104155576.png" alt="image-20250808104155576" style="zoom:33%;" /></blockquote>
<blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">30
30
30
答案：
因为静态成员属于类而不是实例</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="67-泛型父类中定义了一个静态成员属性，有两个子类都继承该泛型父类"><a href="#67-泛型父类中定义了一个静态成员属性，有两个子类都继承该泛型父类" class="headerlink" title="67. 泛型父类中定义了一个静态成员属性，有两个子类都继承该泛型父类"></a>67. 泛型父类中定义了一个静态成员属性，有两个子类都继承该泛型父类</h2><p>请问打印结果是什么？为什么？？</p>
<blockquote>
<img src="https://skymirror-1316984539.cos.ap-beijing.myqcloud.com/Typoraimage-20250808104700959.png" alt="image-20250808104700959" style="zoom:25%;" />

<img src="https://skymirror-1316984539.cos.ap-beijing.myqcloud.com/Typoraimage-20250808104711317.png" alt="image-20250808104711317" style="zoom:25%;" /></blockquote>
<blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">0，20，20，30
答案：
因为静态成员属于类而不是实例
泛型T的变化，会让父类"类型"变化
不同类型的泛型实例，它们的静态成员 static_I 是分别存在的，不会相互影响</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="68-使用C-制作游戏存档功能，请问有几种做法？（至少说出三种）"><a href="#68-使用C-制作游戏存档功能，请问有几种做法？（至少说出三种）" class="headerlink" title="68. 使用C#制作游戏存档功能，请问有几种做法？（至少说出三种）"></a>68. 使用C#制作游戏存档功能，请问有几种做法？（至少说出三种）</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
xml
json
2进制
自定义文档结构
数据库
等等</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="69-C-中是否可以通过反射获取到类内部的私有成员？"><a href="#69-C-中是否可以通过反射获取到类内部的私有成员？" class="headerlink" title="69. C#中是否可以通过反射获取到类内部的私有成员？"></a>69. C#中是否可以通过反射获取到类内部的私有成员？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
可以
在获取成员的相关方法中，可以通过传入参数，指定获取非公共的成员
----------------------------------------------------
其中的关键知识是，利用BindingFlags 枚举
常用枚举类型
Public (BindingFlags.Public): 包括公共成员。
NonPublic (BindingFlags.NonPublic): 包括非公共成员。
Instance (BindingFlags.Instance): 包括实例成员。
Static (BindingFlags.Static): 包括静态成员。
FlattenHierarchy (BindingFlags.FlattenHierarchy): 在层次结构中查找成员，包括继承的成员。
IgnoreCase (BindingFlags.IgnoreCase): 忽略成员名称的大小写
------------------------------------------------------------
BindingFlags.NonPublic | BindingFlags.Instance</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="70-在制作游戏存档功能时C-中反射主要可以发挥出哪些作用（至少说出三点）"><a href="#70-在制作游戏存档功能时C-中反射主要可以发挥出哪些作用（至少说出三点）" class="headerlink" title="70. 在制作游戏存档功能时C#中反射主要可以发挥出哪些作用（至少说出三点）"></a><code>70.</code> 在制作游戏存档功能时C#中反射主要可以发挥出哪些作用（至少说出三点）</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：  
1.序列化时：动态获取数据结构类信息，可以动态获取字段用于存储
2.反序列化时：可以通过反射实例化对象，写入数据
3.结构发生变化时：我们可以利用反射机制进行判断，多的数据抛弃，少的数据自定义初始化</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="71（坑）-请问上面这段代码的打印结果是多少？"><a href="#71（坑）-请问上面这段代码的打印结果是多少？" class="headerlink" title="71（坑）. 请问上面这段代码的打印结果是多少？"></a>71（坑）. 请问上面这段代码的打印结果是多少？</h2><blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">float</span> f = <span class="number">10.4</span>;</span><br><span class="line"><span class="built_in">int</span> i = f / <span class="number">2</span>;</span><br><span class="line">Console.WriteLine(i);</span><br></pre></td></tr></table></figure></blockquote>
<blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
会报错
代码片段中存在两个错误
应该改为
1.float f = 10.4f
2.int i = (int)(f/2)</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="72-在C-当中，我们想要用一个字典容器存储场景中的所有敌对对象。比如-怪物、Boss、可被攻击的场景物件等等。应该如何存储"><a href="#72-在C-当中，我们想要用一个字典容器存储场景中的所有敌对对象。比如-怪物、Boss、可被攻击的场景物件等等。应该如何存储" class="headerlink" title="72. 在C#当中，我们想要用一个字典容器存储场景中的所有敌对对象。比如 怪物、Boss、可被攻击的场景物件等等。应该如何存储"></a>72. 在C#当中，我们想要用一个字典容器存储场景中的所有敌对对象。比如 怪物、Boss、可被攻击的场景物件等等。应该如何存储</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
在父类（或接口）写一个唯一的实例ID，用来当键
值就用里式替换原则
父类容器装载子类对象
---------------------
在父类里面可以再存储类型，然后通过这个就可以as出来</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="73-在C-中，给你一个数字，表示有n秒请问如何在不改变这个数字的前提下"><a href="#73-在C-中，给你一个数字，表示有n秒请问如何在不改变这个数字的前提下" class="headerlink" title="73. 在C#中，给你一个数字，表示有n秒请问如何在不改变这个数字的前提下"></a>73. 在C#中，给你一个数字，表示有n秒请问如何在不改变这个数字的前提下</h2><p>将它转换成格式为  __ 小时__ 分__ 秒</p>
<blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
int h = n / 3600;
int m = (n % 3600) / 60;
int s = n % 60;</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="74（坑）-请问执行以上代码后，List中还存在哪些内容？"><a href="#74（坑）-请问执行以上代码后，List中还存在哪些内容？" class="headerlink" title="74（坑）. 请问执行以上代码后，List中还存在哪些内容？"></a><code>74（坑）</code>. 请问执行以上代码后，List中还存在哪些内容？</h2><blockquote>
<img src="https://skymirror-1316984539.cos.ap-beijing.myqcloud.com/Typoraimage-20250808112719063.png" alt="image-20250808112719063" style="zoom:50%;" /></blockquote>
<blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
2 4 6 8 10
第1次：i = 0 移除了 1，后面往前放 2,3,4,5,6,7,8,9,10
第2次：i = 1 移除了 3，后面往前放 2,4,5,6,7,8,9,10
第3次：i = 2 移除了 5，后面往前放 2,4,6,7,8,9,10
第4次：i = 3 移除了 7，后面往前放 2,4,6,8,9,10
第5次：i = 4 移除了 9，后面往前放 2,4,6,8,10
结束
注意：
	调用RemoveAt删除项时，将重新编号列表中的其余项以替换已删除的项。例如，如果删除索引3处的项，则索引4处的项将移动到第3个位置。此外，列表中的Count属性表示项数将减少1。
--------------------------------------------------------------------------------------------
这个方法是O(n)操作，其中n是从索引位置到列表末尾的元素数量。</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="75-假设游戏中有一个怪物管理器管理所有怪物。那么在开发时，为了避免内存泄漏，我们需要注意什么？"><a href="#75-假设游戏中有一个怪物管理器管理所有怪物。那么在开发时，为了避免内存泄漏，我们需要注意什么？" class="headerlink" title="75. 假设游戏中有一个怪物管理器管理所有怪物。那么在开发时，为了避免内存泄漏，我们需要注意什么？"></a>75. 假设游戏中有一个怪物管理器管理所有怪物。那么在开发时，为了避免内存泄漏，我们需要注意什么？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：  
当某一怪物真正需要移除时
我们需要清除怪物管理器对该怪物的引用</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="76-重载和重写的区别"><a href="#76-重载和重写的区别" class="headerlink" title="76. 重载和重写的区别"></a>76. 重载和重写的区别</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">1.位置不同：重载在同类中，重写在父子类中
2.定义方式不同：重载方法名相同参数列表不同，重写方法名和参数列表都相同
3.调用方式不同：重载使用相同对象以不同参数调用，重写是不同对象相同参数调用</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="77-ArrayList和List的主要区别"><a href="#77-ArrayList和List的主要区别" class="headerlink" title="77. ArrayList和List的主要区别"></a>77. ArrayList和List的主要区别</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">最大的区别就是ArrayList不支持泛型，List支持泛型
这就会导致一系列的问题。
由于ArrayList不带泛型  会导致数据类型丢失因为都会转换为Object
并且还会导致拆装箱。
</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="78-LinkedList-和List的区别"><a href="#78-LinkedList-和List的区别" class="headerlink" title="78. LinkedList 和List的区别"></a>78. LinkedList 和List的区别</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">LinkedList底层是链表，List是数组
因为List添加或删除元素会重写分配内存，所以插入或删除肯会导致性能下降。
List主要适用于随机访问元素的场景。
LinkedList因为是链表  插入删除元素的时候  只需要 调整节点指针内配一块内存即可
但是访问某一元素时，要从头节点开始遍历。
</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="79-请描述Interface（接口）与抽象类之间的不同"><a href="#79-请描述Interface（接口）与抽象类之间的不同" class="headerlink" title="79.请描述Interface（接口）与抽象类之间的不同"></a><code>79.</code>请描述Interface（接口）与抽象类之间的不同</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">1.接口不是类，不能实例化。抽象类可以间接实例化</span>
<span style="color: red;">2.接口是完全抽象，抽象类是部分抽象
3.接口可以多继承，抽象类只能单继承
-----------------------------------------------------------
1. 接口不是类，不能实例化。抽象类可以间接实例化
接口（Interface）：
接口是纯抽象的契约，只定义方法/属性/事件的签名（如 void DoSomething()），不包含任何实现。
不能直接实例化：new IInterface() 是非法的。
使用方式：通过类实现接口（class MyClass : IInterface），然后实例化该类。
抽象类（Abstract Class）：
抽象类可以包含已实现的方法和抽象方法（如 abstract void DoSomething()）。
不能直接实例化：new AbstractClass() 是非法的。
间接实例化：通过继承抽象类的子类实例化（class MyClass : AbstractClass → new MyClass()）。
----------------------------------------------------------------
2.接口是完全抽象，抽象类是部分抽象
接口：
在C# 8.0之前，接口所有成员都是抽象的（无实现）。
C# 8.0+ 支持默认实现（如 void DoSomething() &#123; ... &#125;），但接口的核心目的仍是定义行为契约。
本质：接口是“能做什么”的规范。
抽象类：
可以包含具体实现的方法（如 public void Eat() &#123; ... &#125;）和抽象方法。
本质：抽象类是“部分通用功能 + 部分待实现功能”的模板。
--------------------------------------------------------------------
3.接口可以多继承，抽象类只能单继承
很好理解了
接口：
一个类可以实现多个接口（多继承行为）。
接口之间也可以继承多个父接口（interface ICombined : I1, I2）。
抽象类：
C# 不支持多重类继承，一个类只能继承一个抽象类（或普通类）
</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="80-构造函数是否能被重写？？"><a href="#80-构造函数是否能被重写？？" class="headerlink" title="80. 构造函数是否能被重写？？"></a>80. 构造函数是否能被重写？？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">构造函数Constructor不能被继承，因此不能重写，但是可以重载</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="81-静态成员和非静态成员的区别"><a href="#81-静态成员和非静态成员的区别" class="headerlink" title="81. 静态成员和非静态成员的区别"></a>81. 静态成员和非静态成员的区别</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">1.类成员用static声明，类被第一次加载到内存时创建，通过类访问
2.不带static的变量，非静态变量，在对象被实例化时创建，通过对象进行访问
3.静态方法里不能使用非静态成员（只能使用静态成员），非静态方法可以使用静态成员
4.静态成员是属于类的，而不属于对象</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="82-C-中ref和out关键字有什么区别？？"><a href="#82-C-中ref和out关键字有什么区别？？" class="headerlink" title="82.  C#中ref和out关键字有什么区别？？"></a>82.  C#中ref和out关键字有什么区别？？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">1.ref修饰引用参数。参数必须赋值，带回返回值，又进又出。
2.out修饰输出参数。参数可以不赋值，带回值之前必须明确赋值。
3.引用参数和输出参数不会创建新的存储位置。
4.如果ref参数值引用类型，方法里重新赋值后，原对象堆中数据回改变。
  如果对引用类型再次创建新对象并赋值给ref参数，引用地址回重新指向新对象堆数据
</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="83-字符串中string-str-null-和-string-str-“”-和string-str-string-Empty的区别？？"><a href="#83-字符串中string-str-null-和-string-str-“”-和string-str-string-Empty的区别？？" class="headerlink" title="83. 字符串中string str &#x3D; null 和 string str &#x3D; “” 和string  str &#x3D; string.Empty的区别？？"></a>83. 字符串中string str &#x3D; null 和 string str &#x3D; “” 和string  str &#x3D; string.Empty的区别？？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">1.Empty是一个静态只读的字段
2. str ="" 初始化对象，并分配一个空字符串的内存空间
3. str = null ，只是声明了个变量，没有分配内存空间
</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="84-const和readonly-有什么区别？？"><a href="#84-const和readonly-有什么区别？？" class="headerlink" title="84. const和readonly 有什么区别？？"></a>84. const和readonly 有什么区别？？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">1.初始化位置不同。
const必须在声明的同时赋值；readonly即可以在声明处赋值，也可以构造函数里赋值
2.const是编译时常量，在编译时确定该值
  readonly是运行时常量，在运行时确定该值
3.const默认是静态的；
  而readonly如果设置成静态需要显示声明
4.修饰引用类型时不同
  const只能修饰string或值为null的其他引用类型；
  readonly可以修饰任何类型；
</span>
<span style="color: red;">2.装箱——把堆中内容迁移到栈中去（引用转值）</span>
3.如果问到值类型和引用类型同样，要引申这个
</code></pre>
</details></blockquote>
<hr>
<h2 id="85-String-s-new-String-“XYZ”-创建了几个String-Object"><a href="#85-String-s-new-String-“XYZ”-创建了几个String-Object" class="headerlink" title="85. String s &#x3D; new String(“XYZ”);创建了几个String Object"></a>85. String s &#x3D; new String(“XYZ”);创建了几个String Object</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">两个对象</span>
<span style="color: red;">一个是”XYZ“，一个是指向这个字符串的引用对象s</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="86-C-是否可以继承String类？？"><a href="#86-C-是否可以继承String类？？" class="headerlink" title="86. C#是否可以继承String类？？"></a>86. C#是否可以继承String类？？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">不能，类似于sealed修饰过，String在.Net里有特殊处理过</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="87-结构体和类有何区别？？"><a href="#87-结构体和类有何区别？？" class="headerlink" title="87. 结构体和类有何区别？？"></a>87. 结构体和类有何区别？？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">结构体和类最大的区别是在存储空间上的
结构体是值类型，类是引用类型
结构体存储在栈上，类存储在堆上
结构体有面向对象中封装的特性，但是没有继承和多态。
</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="88-C-两个对像值相同（x-equals-y-true），但却可有不同的hashcode，这句话对不对？？？"><a href="#88-C-两个对像值相同（x-equals-y-true），但却可有不同的hashcode，这句话对不对？？？" class="headerlink" title="88. C#两个对像值相同（x.equals(y) &#x3D;&#x3D; true），但却可有不同的hashcode，这句话对不对？？？"></a>88. C#两个对像值相同（x.equals(y) &#x3D;&#x3D; true），但却可有不同的hashcode，这句话对不对？？？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">不对，有相同的hashcode
（1）如果两个对象相同（equals方法返回true），那么它们的hashCode一定要相同。
（2）如果两个对象的hashCode相同，它们并不一定相同。
</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="89-用最有效的方法算出2乘以8等于几？？？"><a href="#89-用最有效的方法算出2乘以8等于几？？？" class="headerlink" title="89. 用最有效的方法算出2乘以8等于几？？？"></a>89. 用最有效的方法算出2乘以8等于几？？？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">用位运算，把2转换为2进制，左移3位即可</span>
</details></blockquote>
<hr>
<h2 id="90-int？和int有什么区别？？"><a href="#90-int？和int有什么区别？？" class="headerlink" title="90. int？和int有什么区别？？"></a>90. int？和int有什么区别？？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">int? 为可空类型，默认值可以是null
int 默认值是0
int？是通过int装箱为引用实现的</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="91-C-语言中的sleep-和wait-有什么区别"><a href="#91-C-语言中的sleep-和wait-有什么区别" class="headerlink" title="91. C# 语言中的sleep()和wait()有什么区别"></a>91. C# 语言中的sleep()和wait()有什么区别</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">sleep()方法是将当前线程挂起指定的时间
wait() 释放对象上的锁并阻塞当前线程，直到它重新获取该锁
</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="92-C-可否对内存直接操作"><a href="#92-C-可否对内存直接操作" class="headerlink" title="92. C#可否对内存直接操作"></a>92. C#可否对内存直接操作</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">C#在unsafe模式下可以使用指针对内存进行操作，但在托管模式下不可以使用指针，C#NET默认不运行带指针的</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="93-如何实现多态"><a href="#93-如何实现多态" class="headerlink" title="93.如何实现多态"></a>93.如何实现多态</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">1.重写（vob） 2.重载</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="94-如何避免拆装箱"><a href="#94-如何避免拆装箱" class="headerlink" title="94. 如何避免拆装箱"></a>94. 如何避免拆装箱</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">1.通过struct重写函数来避免拆装箱，比如ToString()和GetType()都会先装箱后调用
2.通过泛型避免拆装箱，最简单的例子就是List泛型可以避免拆装箱
3.通过继承统一的接口类，提前拆装箱，避免在函数内部多次拆装箱
比如：结构体A和B都继承 一个接口I，就可以利用里氏替换原则父容子类,void Test(I i)，只在传入进行装箱，内部就不用拆装箱 </span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="95-请列出C-中几种循环的方法，并指出它们的不同？"><a href="#95-请列出C-中几种循环的方法，并指出它们的不同？" class="headerlink" title="95. 请列出C#中几种循环的方法，并指出它们的不同？"></a>95. 请列出C#中几种循环的方法，并指出它们的不同？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">For：确定次数循环
Foreach：遍历元素，只读
Do...while:次数不确定，条件随机变化但至少保证能被执行一次
While：次数不确定，条件随机变化</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="96-接口是否可继承接口？抽象类是否可实现接口？抽象类是否可以继承实现类？"><a href="#96-接口是否可继承接口？抽象类是否可实现接口？抽象类是否可以继承实现类？" class="headerlink" title="96. 接口是否可继承接口？抽象类是否可实现接口？抽象类是否可以继承实现类？"></a>96. 接口是否可继承接口？抽象类是否可实现接口？抽象类是否可以继承实现类？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">1.接口可以继承接口
2.抽象类可以实现接口
3.抽象类可以继承实现类，但前提是实现类必须有明确的构造函数</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="97-C-中结构体为什么可以继承接口并且实现接口"><a href="#97-C-中结构体为什么可以继承接口并且实现接口" class="headerlink" title="97.C#中结构体为什么可以继承接口并且实现接口??"></a>97.C#中结构体为什么可以继承接口并且实现接口??</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">1.接口与类 / 结构体之间的关系是 “实现” 而非 “继承”（尽管语法上使用: 接口名，但语义上不同于类的继承）
2.结构体作为值类型，需要接口实现来扩展功能
3.结构体实现接口不会破坏值类型的特性,用时（未装箱状态下）直接操作值类型实例，避免了引用类型的内存分配开销。</span>
</code></pre>
</details></blockquote>
<h1 id="Unity相关"><a href="#Unity相关" class="headerlink" title="Unity相关"></a>Unity相关</h1><hr>
<h2 id="1-Unity中点乘和叉乘对于我们来说的作用是什么？"><a href="#1-Unity中点乘和叉乘对于我们来说的作用是什么？" class="headerlink" title="1. Unity中点乘和叉乘对于我们来说的作用是什么？"></a>1. Unity中点乘和叉乘对于我们来说的作用是什么？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">点乘：
1.可以判断对象的方位（前后），用我们的正朝向和指向对方的向量点乘。大于0就是后面，小于0就是前面。
2.还可以得到两向量之间的夹角
</span>
<span style="color: red;">叉乘：
1.获得一个平面的法向量
2.得到两个向量之间的左右位置关系
</span>
注：Unity中用的是左手坐标系，所以确定方向的时候我们要用左手法则，最后得到的方向正好与右手法则相反
</code></pre>
</details></blockquote>
<hr>
<h2 id="2-Unity中多线程执行下面哪些代码会报错？"><a href="#2-Unity中多线程执行下面哪些代码会报错？" class="headerlink" title="2. Unity中多线程执行下面哪些代码会报错？"></a>2. Unity中多线程执行下面哪些代码会报错？</h2><p>A. Application.persistentDataPath<br>B. File.Exists(“文件名”)<br>C. transform.Translate<br>D. Object.Destroy(对象)</p>
<blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">A、C、D</span>
<span style="color: red;">UnityEngine命名空间中相关类基本都不能被Unity多线程使用</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="3-Application-streamingAssetsPath-和-Application-persistentDataPath两个路径有何区别？对于我们的意义是什么？"><a href="#3-Application-streamingAssetsPath-和-Application-persistentDataPath两个路径有何区别？对于我们的意义是什么？" class="headerlink" title="3. Application.streamingAssetsPath 和 Application.persistentDataPath两个路径有何区别？对于我们的意义是什么？"></a>3. Application.streamingAssetsPath 和 Application.persistentDataPath两个路径有何区别？对于我们的意义是什么？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">Application.streamingAssetsPath只读</span>
<span style="color: red;">Application.persistentDataPath 可读可写
-------------------------------------------------------------------
Application.streamingAssetsPath适合防止一些默认的2进制配置文件，用来读取初始化的数据
Application.persistentDataPath 用于处理数据持久化 ，或者作为热更新下载内容的存放目录
</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="4-请简述Unity中协程的原理。"><a href="#4-请简述Unity中协程的原理。" class="headerlink" title="4. 请简述Unity中协程的原理。"></a>4. 请简述Unity中协程的原理。</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">
1.协程不是线程，Unity中的协程主要由迭代器实现，迭代器的原理是状态机
2.Unity协程主要是分成两个部分：协程函数和协程调度器。
  	协程函数会根据迭代器函数进行分布执行，遇到yiled return 再将程序挂起，去执行其他内容
  	挂起的函数一般在Update和LateUpdate 之间执行
  	协程调度器则则对协程函数进行统一管理
</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="5-Unity底层如何处理C-代码"><a href="#5-Unity底层如何处理C-代码" class="headerlink" title="5. Unity底层如何处理C#代码"></a>5. Unity底层如何处理C#代码</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">
1. Mono
	C#代码在项目发布时，会被编译成IL中间代码，最后这些中间代码会通过Mono虚拟机被编译成各大操作系统的机器码
2.IL2CPP
	把IL中间代码转译为C++代码，再通过各平台的C++编译器直接编译为可执行的原生汇编代码。
</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="6-Unity中当一个细小高速物体撞击另一个较大物体时会出现什么情况？如何避免？"><a href="#6-Unity中当一个细小高速物体撞击另一个较大物体时会出现什么情况？如何避免？" class="headerlink" title="6. Unity中当一个细小高速物体撞击另一个较大物体时会出现什么情况？如何避免？"></a>6. Unity中当一个细小高速物体撞击另一个较大物体时会出现什么情况？如何避免？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">会出现穿模</span>
<span style="color: red;">1.我们可以尽量用射线检测来替代细小物体的物理系统碰撞
因为传统的FPS游戏都是通过射线检测加模拟计算来判断伤害的
2.修改Rigidbody刚体中的Interpolate（插值）和CollisionDetection（碰撞检测）两个参数，来提高碰撞检测的准确性</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="7-请简述一下Prefab（预制体）的本质是什么？"><a href="#7-请简述一下Prefab（预制体）的本质是什么？" class="headerlink" title="7. 请简述一下Prefab（预制体）的本质是什么？"></a>7. 请简述一下Prefab（预制体）的本质是什么？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">Prefab的本质就是一个配置文件
其中记录了一个GameObject对象上挂载的脚本信息
并且记录了脚本信息中的可配置的属性信息</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="8-Unity是否支持写成多线程程序？如果支持的话需要注意什么？"><a href="#8-Unity是否支持写成多线程程序？如果支持的话需要注意什么？" class="headerlink" title="8. Unity是否支持写成多线程程序？如果支持的话需要注意什么？"></a>8. Unity是否支持写成多线程程序？如果支持的话需要注意什么？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
	支持</span>
<span style="color: red;">注意：
1.只能从主线程访问Unity相关组件、对象以及
UnityEngine命名空间中的绝大部分内容
2.如果多线程中要和Unity主线程同时修改一些数据
可以通过lock关键词加锁</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="9-请简述一下对象池实现原理，在游戏开发中我们什么时候会用到它？"><a href="#9-请简述一下对象池实现原理，在游戏开发中我们什么时候会用到它？" class="headerlink" title="9. 请简述一下对象池实现原理，在游戏开发中我们什么时候会用到它？"></a>9. 请简述一下对象池实现原理，在游戏开发中我们什么时候会用到它？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">1.我们把不用的对象放入对象池中失活，下次需要用到对象的失活再从对象池中取。线程池也是同样的原理</span>
<span style="color: red;">2.在游戏中频繁创建对象、实例化对象的地方，都可以用到对象池。
比如前端开发中，游戏中的子弹、伤害字体、特效等等
比如后端开发中线程池等等
3.对象池的作用就是：
	避免大量创建对象再销毁对象时造成内存的消耗而引发GC。
</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="10-什么是DrawCall？DrawCall为什么会影响游戏运行效率？"><a href="#10-什么是DrawCall？DrawCall为什么会影响游戏运行效率？" class="headerlink" title="10 .什么是DrawCall？DrawCall为什么会影响游戏运行效率？"></a>10 .什么是DrawCall？DrawCall为什么会影响游戏运行效率？</h2><p>如何减少DrawCall？</p>
<blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">1.CPU向GPU发送的一次渲染命令</span>
<span style="color: red;">2.DrawCall次数高，Cpu就要话更多的时间取准备渲染数据，这其中会进行更多的计算，进而影响游戏运行的效率。当每帧需要提交数千个DrawCall时，CPU可能忙于处理命令提交，会出现Cpu过载，而GPU因等待数据空闲</span>
3. 如何减少DrawCall？
	2D和UI层面：打图集，注意面板中不同图集照片的层级不要穿插
	3D层面：使用动态批处理和静态批处理，尽量不要使用实时光照
</code></pre>
</details></blockquote>
<hr>
<h2 id="11-transform-forward和Vector3-forword的区别"><a href="#11-transform-forward和Vector3-forword的区别" class="headerlink" title="11. transform.forward和Vector3.forword的区别"></a>11. transform.forward和Vector3.forword的区别</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
Vector3.forword始终时(0,0,1)
可以认为是世界坐标系的Z轴朝向
transform.forword是当前物体的局部坐标系的Z轴在世界坐标系下的朝向
可以认为是物体自己的Z轴朝向</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="12-Unity中如何解决过多创建和删除对象带来的卡顿问题？"><a href="#12-Unity中如何解决过多创建和删除对象带来的卡顿问题？" class="headerlink" title="12. Unity中如何解决过多创建和删除对象带来的卡顿问题？"></a>12. Unity中如何解决过多创建和删除对象带来的卡顿问题？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
	可以通过协同程序，分时分步创建或删除
原理是避免一帧中处理太多对象</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="13-游戏中的成就系统，我们一般会使用设计模式中的哪种模式来制作？为什么？"><a href="#13-游戏中的成就系统，我们一般会使用设计模式中的哪种模式来制作？为什么？" class="headerlink" title="13. 游戏中的成就系统，我们一般会使用设计模式中的哪种模式来制作？为什么？"></a><code>13.</code> 游戏中的成就系统，我们一般会使用设计模式中的哪种模式来制作？为什么？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
观察者模式
Unity基础小框架中讲解的 事件中心 就是基于观察者模式的
是一种订阅通知机制</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="14-请简述热更新的流程"><a href="#14-请简述热更新的流程" class="headerlink" title="14. 请简述热更新的流程"></a>14. 请简述热更新的流程</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
本地存在资源对比文件和已有资源
1.下载资源服务器中的对比文件
2.将下载下来的远端对比文件和本地的做对比
   记录需要更新的资源和要移除的资源
3.根据第二步中记录的信息，进行资源下载和移除
4.更新本地对比文件，其内容和刚才下载的远端对比文件一致</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="15-我们应该如何优化UI（基于UGUI）"><a href="#15-我们应该如何优化UI（基于UGUI）" class="headerlink" title="15. 我们应该如何优化UI（基于UGUI）"></a>15. 我们应该如何优化UI（基于UGUI）</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
性能上
1.打图集，将同一画面的图片放入一个图集中，目的是减少DrawCall
2.面板中的图片和文字尽量不要交叉，因为这样会产生多余的DrawCall
3.取消勾选不必要的射线检测，UI组件上的
4.减少透明图片的重叠使用
5.UI动静分离
	因为UI本质就是mash网格，UI内部为了优化会把符合规则的ui网格进行合并。
	而每一次UI动（比如：放大缩小）就要重新合并
	那么如何分离？
	将会动的UI放在另一个画布上，不动的UI留在原来的节点。
	这样UI在动的时候，不会影响到不动UI的网格合并
等等
内存上
1.大图尽量使用9宫格缩放，让美术设计UI面板底图时不要过于复杂
尽量是有规律的纹理和颜色变化
2.图片的RGBA通道分离
等等</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="16-Unity中的Destroy和DestroyImmediate的区别是什么？"><a href="#16-Unity中的Destroy和DestroyImmediate的区别是什么？" class="headerlink" title="16. Unity中的Destroy和DestroyImmediate的区别是什么？"></a>16. Unity中的Destroy和DestroyImmediate的区别是什么？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
Destroy方法
可以指定删除的延迟时间，如果第二个参数不填写，最快也会在下一帧前完成删除。也就是如果Destroy对象后马上判空，该对象不会为空。
实际的对象销毁操作始终延迟到当前更新循环结束，但始终在渲染前完成
DestroyImmediate方法
会立即销毁删除对象（不会自动滞空，需要自己滞空）</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="17-第一次执行GameObject-Instantiate时可能出现明显的卡顿如何解决该问题？"><a href="#17-第一次执行GameObject-Instantiate时可能出现明显的卡顿如何解决该问题？" class="headerlink" title="17. 第一次执行GameObject.Instantiate时可能出现明显的卡顿如何解决该问题？"></a>17. 第一次执行GameObject.Instantiate时可能出现明显的卡顿如何解决该问题？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
我们可以通过Unity自带的性能分析工具Profiler分析实例化时造成卡顿的原因
程序上，一般我们可以从以下3个方面去优化它
1.相关资源加载：如果是由于资源加载带来的卡顿，我们可以在进入场景时进行资源预加载，总体思路就是将较大资源提前或者分帧加载
------------------------------------
2.脚本初始化：实例化对象时，会同步执行它身上挂载所有脚本的初始化工作，我们可以策略性的改变一些初始化逻辑，尽量不要再Awake和Start中做较复杂的逻辑，或者将复杂逻辑提前或者分帧处理
------------------------------------
3.对于会频繁使用的对象，我们可以使用缓存池
------------------------------------
美术上
不能只追求好的美术效果，而不考虑资源的消耗，要根据项目的实际情况，来设定模型的骨骼数、面数以及贴图的数量和大小上限。
在制作粒子特效时，粒子数、粒子面积、贴图等都要尽量少和小。
美术上要遵循：用最少的资源做出做好的效果，不能一味的用性能去换效果，最终会得不偿失</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="18-Unity使用IL2CPP打包时，我们应该注意什么？如何避免（可以举例说明）"><a href="#18-Unity使用IL2CPP打包时，我们应该注意什么？如何避免（可以举例说明）" class="headerlink" title="18. Unity使用IL2CPP打包时，我们应该注意什么？如何避免（可以举例说明）"></a>18. Unity使用IL2CPP打包时，我们应该注意什么？如何避免（可以举例说明）</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
使用IL2CPP打包时，最可能出现的问题就是代码裁剪，IL2CPP会自动将它认为不会使用的代码裁剪掉，比如我们在使用Lua开发时，其实会用到很多UnityEngine或者我们自己写的C#代码，但是这些代码并不会在引擎中直接使用，都是在Lua中使用的，此时最容易出现的问题就是代码裁剪，导致打包后出现异常和报错。
---------------------------------------------------------------------------
要避免IL2CPP的裁剪有3种方式，我们可以组合使用
1.设置打包时的裁剪等级
2.通过xml文件配置明确规定哪些内容不裁剪
3.在静态方法中显示调用不想被裁剪的内容</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="19-两个四元数相乘有什么作用？四元数乘以向量有什么作用？"><a href="#19-两个四元数相乘有什么作用？四元数乘以向量有什么作用？" class="headerlink" title="19. 两个四元数相乘有什么作用？四元数乘以向量有什么作用？"></a>19. 两个四元数相乘有什么作用？四元数乘以向量有什么作用？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">四元数相乘：角度叠加
四元数乘以向量：向量旋转</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="20-图中的小球是否被渲染了？是否会产生DrawCall？"><a href="#20-图中的小球是否被渲染了？是否会产生DrawCall？" class="headerlink" title="20. 图中的小球是否被渲染了？是否会产生DrawCall？"></a>20. 图中的小球是否被渲染了？是否会产生DrawCall？</h2><blockquote>
<img src="https://skymirror-1316984539.cos.ap-beijing.myqcloud.com/Typoraimage-20250731223300752.png" alt="image-20250731223300752" style="zoom: 33%;" /></blockquote>
<blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
不会被渲染，不会产生DrawCall
Unity本身有摄像机视锥体剔除，也就是不会显示完全位于视锥体之外的游戏对象
那么小球就不会进行渲染，也不会提交数据给GPU，也就不会产生DrawCall</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="21-在没有使用遮挡剔除的情况下，图中A和B都是默认标准材质。图中的小球最终是否会被渲染，是否会产生DrawCall？"><a href="#21-在没有使用遮挡剔除的情况下，图中A和B都是默认标准材质。图中的小球最终是否会被渲染，是否会产生DrawCall？" class="headerlink" title="21. 在没有使用遮挡剔除的情况下，图中A和B都是默认标准材质。图中的小球最终是否会被渲染，是否会产生DrawCall？"></a>21. 在没有使用遮挡剔除的情况下，图中A和B都是默认标准材质。图中的小球最终是否会被渲染，是否会产生DrawCall？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
最终不会被渲染，标准材质存在深度测试，小球在立方体后方，不会通过深度测试，所以不会被渲染
会产生DrawCall，如果都深度测试了，那么肯定是存在DrawCall的
深度测试发生在片元着色器处理之后，GPU会对每个片元执行深度测试来决定遮挡关系，决定是否被渲染</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="22-如果不考虑IOS平台，只在Windows和Android平台上发布游戏，如何在不使用第三方热更新方案的前提下实现热更新功能"><a href="#22-如果不考虑IOS平台，只在Windows和Android平台上发布游戏，如何在不使用第三方热更新方案的前提下实现热更新功能" class="headerlink" title="22. 如果不考虑IOS平台，只在Windows和Android平台上发布游戏，如何在不使用第三方热更新方案的前提下实现热更新功能"></a>22. 如果不考虑IOS平台，只在Windows和Android平台上发布游戏，如何在不使用第三方热更新方案的前提下实现热更新功能</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
C#的反射
可以通过热更DLL文件的形式，加载程序集（dll）
利用反射执行热更DLL包中的逻辑</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="23-Unity中如何调试排查Android上运行的项目问题"><a href="#23-Unity中如何调试排查Android上运行的项目问题" class="headerlink" title="23. Unity中如何调试排查Android上运行的项目问题"></a>23. Unity中如何调试排查Android上运行的项目问题</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
1.如果需要进行断点调试
通过数据线链接运行项目的Android设备
发布时开启了
Development Build 开发模式构建
Autoconnect Profiler 自动连接分析器
Script Debuggins 脚本调试 
Wait For Managed Debugger 等待托管调试器
等选项
然后只需要Build and Run既可以
利用Unity的Profiler 性能剖析器窗口排查性能问题
并且还可以进行断点调试
-----------------------------------------------------
2.如果只是获取一些打印调试信息
可以利用Unity2019.4及其以上版本提供的Android Logcat工具获取信息
Unity2019.4以下的版本，可以使用Android的ADB（安卓调试桥）工具
---------------------------------------------------------
3.如果需要获取设备输入信息
可以利用Unity Remote来测试移动设备的输入相关逻辑</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="24-Unity引擎中哪些功能使用了C-的反射功能？至少说出一点"><a href="#24-Unity引擎中哪些功能使用了C-的反射功能？至少说出一点" class="headerlink" title="24. Unity引擎中哪些功能使用了C#的反射功能？至少说出一点"></a>24. Unity引擎中哪些功能使用了C#的反射功能？至少说出一点</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
1.Inspector窗口中显示的内容
2.预设体文件
3.场景文件
4.Unity中的各种特性
等等</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="25-Unity中Awake和Start两个生命周期函数，分别在什么时候被调用？"><a href="#25-Unity中Awake和Start两个生命周期函数，分别在什么时候被调用？" class="headerlink" title="25 . Unity中Awake和Start两个生命周期函数，分别在什么时候被调用？"></a>25 . Unity中Awake和Start两个生命周期函数，分别在什么时候被调用？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
Awake：运行时
当脚本被动态添加到对象上时立即被调用。
当对象被实例化时，依附它的脚本会立即调用Awake
它类似构造函数
Start：第一次Update之前被调用</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="26-Unity场景上有多个对象，都分别挂载了n个脚本。我们如何控制不同脚本间生命周期函数Awake的执行先后顺序？"><a href="#26-Unity场景上有多个对象，都分别挂载了n个脚本。我们如何控制不同脚本间生命周期函数Awake的执行先后顺序？" class="headerlink" title="26. Unity场景上有多个对象，都分别挂载了n个脚本。我们如何控制不同脚本间生命周期函数Awake的执行先后顺序？"></a>26. Unity场景上有多个对象，都分别挂载了n个脚本。我们如何控制不同脚本间生命周期函数Awake的执行先后顺序？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
1.可以通过选中脚本文件，点击Inspector窗口右上角的Execution Order（执行顺序）按钮 
2.可以打开Project Setting窗口，选择Script Execution Order选项
通过这两种方式我们可以打开脚本执行顺序窗口
在其中我们可以自己设置自定义脚本的执行顺序</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="27-想要在Unity中使用指针我们需要进行哪些操作？"><a href="#27-想要在Unity中使用指针我们需要进行哪些操作？" class="headerlink" title="27. 想要在Unity中使用指针我们需要进行哪些操作？"></a>27. 想要在Unity中使用指针我们需要进行哪些操作？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
1.需要在PlayerSetting中的OtherSettings中勾选  Allow 'unsafe' code 选项
2.使用指针时必须在unsafe修饰的代码块中</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="28-Unity中的协同程序中yield-return不同的内容，代表的含义不同请说明下面这些yield-return的含义"><a href="#28-Unity中的协同程序中yield-return不同的内容，代表的含义不同请说明下面这些yield-return的含义" class="headerlink" title="28. Unity中的协同程序中yield return不同的内容，代表的含义不同请说明下面这些yield return的含义"></a>28. Unity中的协同程序中yield return不同的内容，代表的含义不同请说明下面这些yield return的含义</h2><blockquote>
<p>1.yield return 数字;<br>2.yield return null;<br>3.yield return new WaitForSeconds(数字);<br>4.yield return new WaitForFixedUpdate();<br>5.yield return new WaitForEndOfFrame();<br>6.yield break;</p>
</blockquote>
<blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
1.yield return 数字; 下一帧执行
2.yield return null;  下一帧执行
3.yield return new WaitForSeconds(数字); 等待指定秒后执行
4.yield return new WaitForFixedUpdate(); 等待下一个固定物理帧更新时执行
5.yield return new WaitForEndOfFrame(); 等待摄像机和GUI渲染完成后执行
6.yield break; 跳出协程</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="29-使用Unity协同程序进行异步加载时，底层是否会使用多线程？"><a href="#29-使用Unity协同程序进行异步加载时，底层是否会使用多线程？" class="headerlink" title="29.使用Unity协同程序进行异步加载时，底层是否会使用多线程？"></a><code>29</code>.使用Unity协同程序进行异步加载时，底层是否会使用多线程？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
可能会
协同程序的原理是分时分步完成指定逻辑
在其中的某一步骤中，是可以使用多线程来完成某些加载操作的，多线程加载完成后，再进入协同程序的下一步继续执行</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="30-Unity中动态加载资源的方式有哪些？"><a href="#30-Unity中动态加载资源的方式有哪些？" class="headerlink" title="30. Unity中动态加载资源的方式有哪些？"></a>30. Unity中动态加载资源的方式有哪些？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
1.Resource类中的相关方法加载Resources文件夹下的资源
2.AssetBundle类中或Addressables类中的相关方法加载AB包中的资源
3.WWW类中或UnityWebRequest类中的相关方法加载本地或远端资源
4.还可以答 C#原生的一些文件加载相关 File FileStream等等</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="31-Unity中的光照贴图的作用是什么？"><a href="#31-Unity中的光照贴图的作用是什么？" class="headerlink" title="31. Unity中的光照贴图的作用是什么？"></a>31. Unity中的光照贴图的作用是什么？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
在移动平台上（或配置较低的设备上）使用实时光源是非常消耗性能的
我们可以使用光照贴图，预先将环境光烘焙到贴图上，可以减少性能消耗</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="32-Unity场景中有两个点连成了一条线，想要旋转这条线，应该怎么做？"><a href="#32-Unity场景中有两个点连成了一条线，想要旋转这条线，应该怎么做？" class="headerlink" title="32.Unity场景中有两个点连成了一条线，想要旋转这条线，应该怎么做？"></a>32.Unity场景中有两个点连成了一条线，想要旋转这条线，应该怎么做？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
两点相减得到一条向量，向量乘以四元数得到旋转后的向量，再把起点加上旋转后的向量即可得到转移后的线</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="33-LOD（多细节层次）和-MipMap（纹理图）的作用是什么？"><a href="#33-LOD（多细节层次）和-MipMap（纹理图）的作用是什么？" class="headerlink" title="33. LOD（多细节层次）和 MipMap（纹理图）的作用是什么？"></a>33. LOD（多细节层次）和 MipMap（纹理图）的作用是什么？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
优化游戏性能
从不同距离渲染对象时，使用的是质量不同的模型(LOD)和贴图(Mipmap)。（一般情况是越远面数越低，图片越小）</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="34-游戏开发中，客户端和服务端交互数据，程序中常用方式是什么？"><a href="#34-游戏开发中，客户端和服务端交互数据，程序中常用方式是什么？" class="headerlink" title="34. 游戏开发中，客户端和服务端交互数据，程序中常用方式是什么？"></a>34. 游戏开发中，客户端和服务端交互数据，程序中常用方式是什么？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
消息数据：Socket或HTTP
文件数据：FTP或HTTP</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="35-Unity中如何将本地坐标转为世界坐标？"><a href="#35-Unity中如何将本地坐标转为世界坐标？" class="headerlink" title="35. Unity中如何将本地坐标转为世界坐标？"></a>35. Unity中如何将本地坐标转为世界坐标？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
1.用本地坐标加上父对象相对世界的坐标（如果有多层父子关系，不停地往上加即可）
2.利用Transform中的TransformPoint方法</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="36-Unity中如何计算出两个向量之间的夹角，请说出两种方式"><a href="#36-Unity中如何计算出两个向量之间的夹角，请说出两种方式" class="headerlink" title="36.Unity中如何计算出两个向量之间的夹角，请说出两种方式"></a>36.Unity中如何计算出两个向量之间的夹角，请说出两种方式</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
1. 利用Vector3中的API：Vector3.Angle
2. 先使用 Vector3.Dot 算出方向向量点乘结果，再通过Mathf.Acos反三角函数算出弧度，再将弧度转为角度</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="37-请写出UGUI中两种处理异形按钮的具体方法"><a href="#37-请写出UGUI中两种处理异形按钮的具体方法" class="headerlink" title="37. 请写出UGUI中两种处理异形按钮的具体方法"></a>37. 请写出UGUI中两种处理异形按钮的具体方法</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
方法一：异形按钮，自带的像素检测阈值
方法二：异形按钮，通过子对象拼凑</span>
</code></pre>
</details></blockquote>
<blockquote>
<img src="https://skymirror-1316984539.cos.ap-beijing.myqcloud.com/Typoraimage-20250802144023142.png" alt="image-20250802144023142" style="zoom: 67%;" />

<ul>
<li>第一步：将需要进行异形按钮判断的图片可读写打开</li>
<li>第二步：通过代码控制Image组件上阀值改变</li>
</ul>
</blockquote>
<hr>
<h2 id="38-请说出Unity中如何进行数据持久化，至少说出5种方式"><a href="#38-请说出Unity中如何进行数据持久化，至少说出5种方式" class="headerlink" title="38. 请说出Unity中如何进行数据持久化，至少说出5种方式"></a>38. 请说出Unity中如何进行数据持久化，至少说出5种方式</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
PlayerPrefs
2进制文件存储
xml文件存储
json文件存储
数据库存储（本地、远端、通过服务器存储到数据库）</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="39-在Unity中如何控制渲染优先级？（谁先渲染谁后渲染，分情况回答）"><a href="#39-在Unity中如何控制渲染优先级？（谁先渲染谁后渲染，分情况回答）" class="headerlink" title="39. 在Unity中如何控制渲染优先级？（谁先渲染谁后渲染，分情况回答）"></a>39. 在Unity中如何控制渲染优先级？（谁先渲染谁后渲染，分情况回答）</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
1.不同摄像机渲染时，摄像机深度（Camera depth）控制优先级
2.相同摄像机时，排序层级（Sorting Layer）控制优先级
3.相同排序层级时，层中的顺序（Order in Layer）控制优先级
4.相同摄像机，无排序层级属性时，Shader中的RenderQueue（渲染队列）控制优先级
--------------------------------------------
1、camera（depth越小，越先渲染）
2、sorting layer（值越小，越先渲染）（下面还有个sortingOrder 值越小，越先渲染）
3、渲染队列renderQueue（值越小，越先渲染）
4、深度值（距离相机越近该值越小，越远该值越大。）</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="40-Unity中判断两个2D矩形是否相交，有几种方式？（请至少说出两种方式）"><a href="#40-Unity中判断两个2D矩形是否相交，有几种方式？（请至少说出两种方式）" class="headerlink" title="40. Unity中判断两个2D矩形是否相交，有几种方式？（请至少说出两种方式）"></a>40. Unity中判断两个2D矩形是否相交，有几种方式？（请至少说出两种方式）</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
1.使用Unity物理系统进行碰撞检测
2.使用Unity中范围检测相关API
3.自己写算法进行检测(STA分离轴检测)  （太难了....）</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="41-Unity中想要制作角色的连招功能，在制作状态机时我们一般如何处理？"><a href="#41-Unity中想要制作角色的连招功能，在制作状态机时我们一般如何处理？" class="headerlink" title="41. Unity中想要制作角色的连招功能，在制作状态机时我们一般如何处理？"></a>41. Unity中想要制作角色的连招功能，在制作状态机时我们一般如何处理？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
1.状态机条件可以添加一个Trigger类型和Int类型
   Trigger条件主要用于触发动作，Int条件主要用于连招计数判断，根据连招技术设置不同的条件
2.逻辑上，当攻击按键输入时，我们需要触发动作，并且进行攻击计数
   通过连招输入窗口时间判断是否应该连招，当输入时间过了，就清0，每次攻击重置计时器
   连招结束后再最后一个攻击事件调用计数清零</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="42-Unity中如果想要在动作的某一时刻进行伤害检测，我们应该怎么做？（请说出两种做法）"><a href="#42-Unity中如果想要在动作的某一时刻进行伤害检测，我们应该怎么做？（请说出两种做法）" class="headerlink" title="42. Unity中如果想要在动作的某一时刻进行伤害检测，我们应该怎么做？（请说出两种做法）"></a>42. Unity中如果想要在动作的某一时刻进行伤害检测，我们应该怎么做？（请说出两种做法）</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
1.添加动画事件
2.在切换动画一开始，进行延迟触发，延迟时间为想要触发伤害的时间（延迟可以用延迟函数，也可以用协同程序）</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="43-Unity中想要制作自动寻路逻辑，我们应该怎么做？（请至少说出两种做法）"><a href="#43-Unity中想要制作自动寻路逻辑，我们应该怎么做？（请至少说出两种做法）" class="headerlink" title="43. Unity中想要制作自动寻路逻辑，我们应该怎么做？（请至少说出两种做法）"></a>43. Unity中想要制作自动寻路逻辑，我们应该怎么做？（请至少说出两种做法）</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
1.Unity自带的网格寻路系统
2.自定义寻路算法（比如 A星寻路算法）</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="44-游戏编辑器（比如-角色编辑器、关卡编辑器、地图编辑器等工具）的本质是什么？"><a href="#44-游戏编辑器（比如-角色编辑器、关卡编辑器、地图编辑器等工具）的本质是什么？" class="headerlink" title="44. 游戏编辑器（比如 角色编辑器、关卡编辑器、地图编辑器等工具）的本质是什么？"></a>44. 游戏编辑器（比如 角色编辑器、关卡编辑器、地图编辑器等工具）的本质是什么？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
数据的图形化编辑工具</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="45-Unity中使用的是左手还是右手坐标系？我们需要注意什么？"><a href="#45-Unity中使用的是左手还是右手坐标系？我们需要注意什么？" class="headerlink" title="45.Unity中使用的是左手还是右手坐标系？我们需要注意什么？"></a>45.Unity中使用的是左手还是右手坐标系？我们需要注意什么？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
左手坐标系
在进行向量相关计算时，要注意左手和右手坐标系的区别</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="46-Unity中鼠标、键盘、触屏、手柄等输入事件会在Update-之前、还是之后、还是同时执行？"><a href="#46-Unity中鼠标、键盘、触屏、手柄等输入事件会在Update-之前、还是之后、还是同时执行？" class="headerlink" title="46. Unity中鼠标、键盘、触屏、手柄等输入事件会在Update 之前、还是之后、还是同时执行？"></a>46. Unity中鼠标、键盘、触屏、手柄等输入事件会在Update 之前、还是之后、还是同时执行？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
之前</span>
</code></pre>
</details></blockquote>
<blockquote>
<img src="https://skymirror-1316984539.cos.ap-beijing.myqcloud.com/Typoraimage-20250802173436359.png" alt="image-20250802173436359" style="zoom: 67%;" /></blockquote>
<hr>
<h2 id="47-Unity中场景中一个处于激活状态的物体-场景上只有这一个物体-，不能被摄像机渲染出来，可能有几种情况？（至少说出3种可能的情况）"><a href="#47-Unity中场景中一个处于激活状态的物体-场景上只有这一个物体-，不能被摄像机渲染出来，可能有几种情况？（至少说出3种可能的情况）" class="headerlink" title="47. Unity中场景中一个处于激活状态的物体(场景上只有这一个物体)，不能被摄像机渲染出来，可能有几种情况？（至少说出3种可能的情况）"></a>47. Unity中场景中一个处于激活状态的物体(场景上只有这一个物体)，不能被摄像机渲染出来，可能有几种情况？（至少说出3种可能的情况）</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
1.在摄像机可视范围外（视口范围外）
2.在摄像机可视范围外（远近裁剪面之外范围）
3.物体的层级不能被摄像机渲染
4.该物体使用了透明材质，处于透明状态
5.该物体使用了单面渲染材质，摄像机看到的是该物体的背面
6.如果存在多摄像机，摄像机深度可能会影响
等等</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="48-Unity制作物理游戏相关功能时，我们采用哪种方式处理位移？为什么？"><a href="#48-Unity制作物理游戏相关功能时，我们采用哪种方式处理位移？为什么？" class="headerlink" title="48. Unity制作物理游戏相关功能时，我们采用哪种方式处理位移？为什么？"></a>48. Unity制作物理游戏相关功能时，我们采用哪种方式处理位移？为什么？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
通过刚体相关API来处理位移，比如加力、改变刚体速度变量
原因：在碰撞检测时能更准确无误</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="49-Unity热更新解决方案中，Lua和ILRuntime方案的本质是什么？"><a href="#49-Unity热更新解决方案中，Lua和ILRuntime方案的本质是什么？" class="headerlink" title="49. Unity热更新解决方案中，Lua和ILRuntime方案的本质是什么？"></a>49. Unity热更新解决方案中，Lua和ILRuntime方案的本质是什么？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
Lua热更本质：
Lua是解释型语言，不需要实现编译，在运行时动态解释执行。xLua和toLua等Lua热更新解决方案，是通过在Unity中内置Lua虚拟机（解释器）来执行Lua逻辑的
---------------------------------------------------------
ILruntime热更本质：
ILRuntime通过读取DLL文件中的IL汇编码，通过在Unity中内置的IL解释执行虚拟机（解释器）来执行热更DLL中的代码
----------------------------------------------------------
总体来说，他们都是在Unity中内置各自的解释器（写好的用于解释执行相关的代码）来执行我们的热更新代码</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="50-请解释Unity中的Prefab是什么，以及它在游戏开发中的作用是什么？"><a href="#50-请解释Unity中的Prefab是什么，以及它在游戏开发中的作用是什么？" class="headerlink" title="50. 请解释Unity中的Prefab是什么，以及它在游戏开发中的作用是什么？"></a>50. 请解释Unity中的Prefab是什么，以及它在游戏开发中的作用是什么？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">在Unity中，Prefab是一种游戏对象的预制件或者模板。它允许你在编辑器中创建一个游戏对象，并将其保存为Prefab，以便在需要时可以实例化多个相同的对象。当你在场景中使用一个Prefab实例时，它将保留与原始Prefab相同的组件、属性和位置，使得你可以轻松地创建和管理大量相似的游戏对象。
--------------------------------------------------------------------------------------------------------
Prefab在游戏开发中的作用非常重要，因为它们允许你创建可重用的游戏对象，并且可以在开发过程中快速迭代和修改。例如，当你需要在游戏中生成大量相似的敌人时，使用一个敌人Prefab可以使得你仅需创建和修改一个敌人对象，而不必重复编写和调整代码。此外，Prefab还允许你在编辑器中预览和调整游戏对象的属性和组件，使得你可以快速地进行修改和测试，从而加快开发进程。</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="51-CPU和GPU他们分别是什么？他们主要完成什么工作"><a href="#51-CPU和GPU他们分别是什么？他们主要完成什么工作" class="headerlink" title="51. CPU和GPU他们分别是什么？他们主要完成什么工作"></a>51. CPU和GPU他们分别是什么？他们主要完成什么工作</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
CPU为中央处理器
负责算数运算、逻辑操作、数据传输等通用计算任务，同时还管理和调度计算机的资源
（游戏开发中—游戏逻辑处理），主要处理操作系统管理、程序执行、通用计算等等
CPU一般处理串行任务，即顺序执行的单个任务，适用于大多数常规计算
---------------------------------------------------------------
GPU为图形处理器
是专门用于图形和并行计算的处理器
显卡就是搭载GPU的硬件设备，显卡包含一个或多个GPU芯片，还包含显存（用于存储图像数据）、显示接口、视频解码器等等（游戏开发中—渲染相关处理）
GPU主要处理并行任务，适用于图形渲染、3D游戏、机器学习、科学计算等需要大量并行计算的领域</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="52-Unity中的Lerp和Slerp分别是什么？"><a href="#52-Unity中的Lerp和Slerp分别是什么？" class="headerlink" title="52. Unity中的Lerp和Slerp分别是什么？"></a>52. Unity中的Lerp和Slerp分别是什么？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
Lerp和Slerp是两个方法，在Mathf和Vector等类中都提供了对应的方法
1.Lerp：
线性插值函数，接受三个参数，起始值、目标值和插值比例
Lerp用于在两个值之间进行平滑的线性插值，适用于直线运动、颜色过渡等场景
----------------------------------------------------------
2.Slerp：
球面插值函数，接受三个参数，起始值、目标值和插值比例
Slerp在插值过程中会在两个旋转之间沿着曲线（球面）插值，从而保持较为自然的旋转过渡
----------------------------------------------------------
他们都是在Unity常用的插值函数，能够在动画、平滑移动、旋转等场景中产生自然和平滑的效果</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="53-Unity底层是单线程还是多线程"><a href="#53-Unity底层是单线程还是多线程" class="headerlink" title="53. Unity底层是单线程还是多线程"></a>53. Unity底层是单线程还是多线程</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
Unity底层实现是基于单线程的，这个线程通常被称为 主线程 或 渲染线程
意味着大部分的游戏逻辑、渲染和更新都在主线程上执行。
-----------------------------------------------
但是Unity也支持自定义多线程处理复杂逻辑，并且Unity目前的版本也提供了一些多线程技术来改善性能，比如Job System、Dots等</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="54-如何在Unity中实现多语言支持？（不同国家的人，看到的游戏内的语言是不一样的）"><a href="#54-如何在Unity中实现多语言支持？（不同国家的人，看到的游戏内的语言是不一样的）" class="headerlink" title="54. 如何在Unity中实现多语言支持？（不同国家的人，看到的游戏内的语言是不一样的）"></a>54. 如何在Unity中实现多语言支持？（不同国家的人，看到的游戏内的语言是不一样的）</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
1. 单包：将所有设计多语言的图片、文本通过配置表去配置
	当显示这些内容时，根据配置表中的信息去动态的加载
	所有地区通用一个安装包，只是游戏中进行地区判断或者语言选择
---------------------------------------------------
2. 分包：根据不同地区发布不同的安装包</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="55-在Unity中，有时在第一次执行GameObject-Instantiate的时候有明显卡顿，该怎么解决？"><a href="#55-在Unity中，有时在第一次执行GameObject-Instantiate的时候有明显卡顿，该怎么解决？" class="headerlink" title="55. 在Unity中，有时在第一次执行GameObject.Instantiate的时候有明显卡顿，该怎么解决？"></a>55. 在Unity中，有时在第一次执行GameObject.Instantiate的时候有明显卡顿，该怎么解决？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">1.装箱——把栈中内容迁移到堆中去（值转引用）</span>
<span style="color: red;">2.装箱——把堆中内容迁移到栈中去（引用转值）</span>
3.如果问到值类型和引用类型同样，要引申这个
</code></pre>
</details></blockquote>
<hr>
<h2 id="56-在Unity中，有时在第一次执行GameObject-Instantiate的时候有明显卡顿，该怎么解决？"><a href="#56-在Unity中，有时在第一次执行GameObject-Instantiate的时候有明显卡顿，该怎么解决？" class="headerlink" title="56. 在Unity中，有时在第一次执行GameObject.Instantiate的时候有明显卡顿，该怎么解决？"></a>56. 在Unity中，有时在第一次执行GameObject.Instantiate的时候有明显卡顿，该怎么解决？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
通过Unity的Profiler窗口排查卡顿原因，一般有以下几种可能性
1.加载过大资源造成卡顿
解决方案：
a.预加载资源
b.简化资源（修改图片大小，减少模型顶点、面数，压缩优化资源等）
c.异步加载资源（分帧加载）
-----------------------------------
2.对象挂载的脚本中初始化耗时
解决方案：
a.减少序列化或反序列化信息
b.优化初始化相关逻辑，提前初始化，分帧初始化(协程)等</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="57-在Unity中AssetBundle的压缩方式有不压缩、LZMA、LZ4三种，请问LZMA和LZ4有什么区别？"><a href="#57-在Unity中AssetBundle的压缩方式有不压缩、LZMA、LZ4三种，请问LZMA和LZ4有什么区别？" class="headerlink" title="57. 在Unity中AssetBundle的压缩方式有不压缩、LZMA、LZ4三种，请问LZMA和LZ4有什么区别？"></a>57. 在Unity中AssetBundle的压缩方式有不压缩、LZMA、LZ4三种，请问LZMA和LZ4有什么区别？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：  
LZMA：压缩算法为Lempel-Ziv-Markov chain-Algorithm
压缩包最小（压缩率更高），但是解压过程较慢，耗时较长（因为它需要进行更多的解压缩操作）
-------------------------------------------------------
LZ4：压缩算法为Lempel-Ziv 4
压缩包较大（压缩率较低），但是不要求完整的数据包就可以解压缩，无需解压完整压缩包，解压时间快（几乎可以立即解压AssetBundle）</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="58-Unity中DrawCall、Batches、SetPass-Calls的意思是什么"><a href="#58-Unity中DrawCall、Batches、SetPass-Calls的意思是什么" class="headerlink" title="58. Unity中DrawCall、Batches、SetPass Calls的意思是什么"></a>58. Unity中DrawCall、Batches、SetPass Calls的意思是什么</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
Draw Call：
表示渲染请求的数量（每个 Draw Call 都会引起一次从 CPU 到 GPU 的数据传输）
直接影响渲染性能，因为它决定了 CPU 和 GPU 之间的通信次数
减少 Draw Call 的数量通常是优化渲染性能的关键之一
可以通过使用批处理技术（Batching）来合并多个物体为一个 Draw Call 来实现
-----------------------------------------------------------------
Batches：
是一种将多个物体合并为一个 Draw Call 的渲染优化技术
它将多个相似的物体合并成一个 Draw Call，从而减少 CPU 到 GPU 的数据传输和渲染开销
可以使用静态批处理、动态批处理和GPU Instancing等技术来进一步优化 Batch
--------------------------------------------------------------------
SetPass Call 渲染Pass（Shader中渲染通道）的数量
移动平台中尽量减少Shader中Pass的数量可以提升性能</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="59-Unity中摄像机组件中的投影-Projection-参数其中的两个选项"><a href="#59-Unity中摄像机组件中的投影-Projection-参数其中的两个选项" class="headerlink" title="59. Unity中摄像机组件中的投影(Projection)参数其中的两个选项"></a>59. Unity中摄像机组件中的投影(Projection)参数其中的两个选项</h2><p>透视投影（Perspective）和 正交投影（Orthographic）<br>有什么区别？</p>
<blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
透视投影：
模拟人眼看世界的方式，近大远小，并呈现出显示世界中的景深和透视效果
通常用于制作3D游戏
--------------------------------------------------------
正交投影：
不考虑对象到摄像机的距离，所有对象无论在场景中任何位置，都以相同大小显示
通常用于制作2D游戏</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="60-FSM和BT指什么？他们是用来处理什么的？"><a href="#60-FSM和BT指什么？他们是用来处理什么的？" class="headerlink" title="60. FSM和BT指什么？他们是用来处理什么的？"></a>60. FSM和BT指什么？他们是用来处理什么的？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
FSM（finite state machine）：有限状态机
BT（Behavior Tree）：行为树
------------------------------------
他们都是用来制作游戏中AI功能的设计方案</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="61-10000个monobehavior，每个各自执行update，和放到一个update里执行，哪个效率更高？为什么？"><a href="#61-10000个monobehavior，每个各自执行update，和放到一个update里执行，哪个效率更高？为什么？" class="headerlink" title="61.10000个monobehavior，每个各自执行update，和放到一个update里执行，哪个效率更高？为什么？"></a>61.10000个monobehavior，每个各自执行update，和放到一个update里执行，哪个效率更高？为什么？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
放在一个Update中执行效率较高
原因：
1.因为每调用一次Update，相当于就是执行了一次方法
而每一次方法的调用在底层是有开销的，当在一帧里进行过多的方法调用自然会增加额外的开销
2.Unity内部对生命周期函数采用了引用和查找机制，每次调用Update时，也会存在查找相关操作，也会增加部分开销</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="62-我们在编写代码时，有什么常用的优化代码性能的手段？至少说出3点"><a href="#62-我们在编写代码时，有什么常用的优化代码性能的手段？至少说出3点" class="headerlink" title="62. 我们在编写代码时，有什么常用的优化代码性能的手段？至少说出3点"></a>62. 我们在编写代码时，有什么常用的优化代码性能的手段？至少说出3点</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：  
1.间隔几帧执行一次逻辑(自己手动间隔、协同程序分时分步)
2.在帧更新函数中尽量少用临时变量(比如Update、OnGUI等每帧执行的生命周期函数中)
3.定时进行手动垃圾回收（GC）（比如切换场景时）
4.优化数学计算，比如尽量少用浮点数，用乘法代替除法等等
5.应用缓存池
6.尽量减少Update生命周期函数的数量
等等</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="63-OpenGL和DX的最大区别是什么？"><a href="#63-OpenGL和DX的最大区别是什么？" class="headerlink" title="63. OpenGL和DX的最大区别是什么？"></a>63. OpenGL和DX的最大区别是什么？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">OpenGL和DX的主要区别就是在于
OpenGL是一个跨平台、跨语言的开放图形库，可以支持各种平台，比如Windows、Linux、MacOS等等
DX是微软创建的，它不跨平台，只针对微软相关平台，比如Windows操作系统，xBox主机系
------------------------------------------------------------------
游戏引擎底层就会对图形API进行封装，为了适应更多的平台，往往会针对多种图形API进行封装</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="64-Unity工程文件中，meta后缀的文件中主要存了什么信息？（最少说出2点）"><a href="#64-Unity工程文件中，meta后缀的文件中主要存了什么信息？（最少说出2点）" class="headerlink" title="64. Unity工程文件中，meta后缀的文件中主要存了什么信息？（最少说出2点）"></a>64. Unity工程文件中，meta后缀的文件中主要存了什么信息？（最少说出2点）</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
1.文件的全局唯一标识，用于确保资源文件在Unity中的唯一性
2.导入设置相关信息，比如纹理在Inspector窗口中的相关设置信息
3.关联脚本，如果资源和脚本关联，会包含相关脚本信息
4.资源依赖关系
5.编辑器状态，比如在Unity编辑中是否被锁定等
-----------------------------------------------------
meta后缀文件在进行项目版本管理时比较重要，因为它可以确保资源的一致性</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="65-不同后缀的各种文件的本质是什么？"><a href="#65-不同后缀的各种文件的本质是什么？" class="headerlink" title="65. 不同后缀的各种文件的本质是什么？"></a>65. 不同后缀的各种文件的本质是什么？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：  
不同后缀的文件表示文件的类型或格式不同
一般情况下，不同后缀的文件都有着自己的一套序列化和反序列化的规则</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="66-UnityWebRequest可以用来做什么？"><a href="#66-UnityWebRequest可以用来做什么？" class="headerlink" title="66. UnityWebRequest可以用来做什么？"></a>66. UnityWebRequest可以用来做什么？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
1.用于上传下载数据（网络通讯，网络传输）
2.用于本地数据加载
3.支持异步执行
它支持多种协议，比如HTTP、HTTPS、FTP、本地文件系统</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="67-如何在Unity中进行多线程编程以提高性能？（至少说出3点可以使用多线程提高性能的内容）"><a href="#67-如何在Unity中进行多线程编程以提高性能？（至少说出3点可以使用多线程提高性能的内容）" class="headerlink" title="67. 如何在Unity中进行多线程编程以提高性能？（至少说出3点可以使用多线程提高性能的内容）"></a>67. 如何在Unity中进行多线程编程以提高性能？（至少说出3点可以使用多线程提高性能的内容）</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
我们可以将一些复杂耗时的计算任务在Unity中使用多线程处理以提高性能
比如：
1.网络通讯
2.A星寻路
3.文件读写操作
4.使用协同程序异步加载（协同程序底层，部分API也是开启了多线程的）
等等</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="68-游戏开发完成后1-游戏运行卡顿、设备发热一般往哪个大方向进行排查？"><a href="#68-游戏开发完成后1-游戏运行卡顿、设备发热一般往哪个大方向进行排查？" class="headerlink" title="68. 游戏开发完成后1.游戏运行卡顿、设备发热一般往哪个大方向进行排查？"></a>68. 游戏开发完成后1.游戏运行卡顿、设备发热一般往哪个大方向进行排查？</h2><p>2.游戏运行一段时间后闪退，一般往哪个大方向进行排查？</p>
<blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
卡顿、发热：性能
闪退：内存</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="69-游戏项目中，运行时主要占内存的内容有哪些？（至少说出5点）"><a href="#69-游戏项目中，运行时主要占内存的内容有哪些？（至少说出5点）" class="headerlink" title="69. 游戏项目中，运行时主要占内存的内容有哪些？（至少说出5点）"></a>69. 游戏项目中，运行时主要占内存的内容有哪些？（至少说出5点）</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
代码相关：
1.代码中预加载的数据（比如数据表中加载出来的数据）
2.代码中的成员数据（执行逻辑的代码中的相关成员）
-----------------------------------------
资源相关：
模型
3.模型数据
4.纹理贴图
5.动画数据
2D
6.UI
7.各种游戏图片（角色、道具、背景等等）
其他
8.音效
9.特效
--------------------------------------
等等</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="70-游戏项目中，主要消耗性能的内容有哪些？（至少说出3点）"><a href="#70-游戏项目中，主要消耗性能的内容有哪些？（至少说出3点）" class="headerlink" title="70. 游戏项目中，主要消耗性能的内容有哪些？（至少说出3点）"></a>70. 游戏项目中，主要消耗性能的内容有哪些？（至少说出3点）</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：  
1.图形渲染相关
2.物理引擎
3.骨骼动画
4.资源加载
5.寻路算法
6.网络通讯
7.常规游戏代码逻辑</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="71-网络游戏中，有一个数据统计界面，这些数据是由最近1000场战斗计算出来的平均数据。你认为以下处理方式合理吗？如果不合理，应该如何改进？"><a href="#71-网络游戏中，有一个数据统计界面，这些数据是由最近1000场战斗计算出来的平均数据。你认为以下处理方式合理吗？如果不合理，应该如何改进？" class="headerlink" title="71. 网络游戏中，有一个数据统计界面，这些数据是由最近1000场战斗计算出来的平均数据。你认为以下处理方式合理吗？如果不合理，应该如何改进？"></a>71. 网络游戏中，有一个数据统计界面，这些数据是由最近1000场战斗计算出来的平均数据。你认为以下处理方式合理吗？如果不合理，应该如何改进？</h2><blockquote>
<ul>
<li>我们通过向后端请求这1000场战斗的数据，然后在客户端计算相关平均数据，更新显示到统计界面上。</li>
</ul>
</blockquote>
<blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
不合理
应该让后端计算好，前端需要数据时请求获取计算好的数据后更新到界面上即可
无需前端来进行计算处理</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="72-如果在Unity当中制作FPS游戏，如何模拟枪械开枪时的后坐力"><a href="#72-如果在Unity当中制作FPS游戏，如何模拟枪械开枪时的后坐力" class="headerlink" title="72.  如果在Unity当中制作FPS游戏，如何模拟枪械开枪时的后坐力"></a>72.  如果在Unity当中制作FPS游戏，如何模拟枪械开枪时的后坐力</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
每次开枪时
可以给枪械、手臂IK、摄像机等（根据实际视角情况决定）
一个绕x轴（往上偏移）和y轴（左右偏移）的旋转角度
并且每帧都会归位（角度四元数不停向原始位置归位）</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="73-Unity当中存在多线程时，继承MonoBehaviour的脚本是否有必要对其中内容加锁？为什么？"><a href="#73-Unity当中存在多线程时，继承MonoBehaviour的脚本是否有必要对其中内容加锁？为什么？" class="headerlink" title="73. Unity当中存在多线程时，继承MonoBehaviour的脚本是否有必要对其中内容加锁？为什么？"></a>73. Unity当中存在多线程时，继承MonoBehaviour的脚本是否有必要对其中内容加锁？为什么？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
分情况讨论
1.如果是想要通过多线程控制或访问场景上对象的相关行为，比如移动旋转、资源加载、动态销毁等等，那么不用加锁
因为Unity的整个执行模型是单线程的，所有的游戏逻辑和渲染都在主线中进行。
大部分的UnityAPI都只能在主线程上调用，如果通过多线程去调用Unity场景上物体的相关API，或改变场景中对象的相关属性，会直接出现报错。因此加锁也没有意义
----------------------------------------------------------------------
2.如果是想要通过多线程改变继承MonoBehaviour脚本中的某些公共成员，比如一个int，一个List。那么可以为这些公共成员加锁，防止线程并发带来的问题
--------------------------------------------------------------------
但是建议尽量不要通过多线程和继承MonoBehaviour的挂载在场景对象中的脚本打交道</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="74-我们在Unity中进行一些复杂逻辑处理时，比如网路通讯、寻路算法。往往会开启多线程进行处理。我们如何保证数据能够和Unity主线程进行正常交互？（请至少说出1种方式）"><a href="#74-我们在Unity中进行一些复杂逻辑处理时，比如网路通讯、寻路算法。往往会开启多线程进行处理。我们如何保证数据能够和Unity主线程进行正常交互？（请至少说出1种方式）" class="headerlink" title="74. 我们在Unity中进行一些复杂逻辑处理时，比如网路通讯、寻路算法。往往会开启多线程进行处理。我们如何保证数据能够和Unity主线程进行正常交互？（请至少说出1种方式）"></a>74. 我们在Unity中进行一些复杂逻辑处理时，比如网路通讯、寻路算法。往往会开启多线程进行处理。我们如何保证数据能够和Unity主线程进行正常交互？（请至少说出1种方式）</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
1.对共享数据加锁，避免多线程并发带来的数据竞争问题
----------------------------------------------------------
2.是用C#中线程安全的数据结构存储共享数据
比如System.Collections.Concurrent 命名空间中的ConcurrentQueue<>和ConcurrentDictionary <>
--------------------------------------------------------------
3.可以尝试使用Unity当中的Dots系统
------------------------------------------------------------------
等等</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="75-Unity生命周期函数中的OnEnable和Start，我们在使用时应该如何选择？可以举例说明。"><a href="#75-Unity生命周期函数中的OnEnable和Start，我们在使用时应该如何选择？可以举例说明。" class="headerlink" title="75.Unity生命周期函数中的OnEnable和Start，我们在使用时应该如何选择？可以举例说明。"></a>75.Unity生命周期函数中的OnEnable和Start，我们在使用时应该如何选择？可以举例说明。</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
在对象的整个生命周期中
OnEnable在对象激活时都会自动调用一次
Start在第一次Update调用之前只会调用一次
----------------------------------------------
我们需要根据执行时机的这个特点来决定何时调用他们
OnEnable可以将一些想要重置的数据 放在其中处理
Start一般放只会初始化一次的数据内容</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="76-FixUpdate适合写哪些操作？为什么"><a href="#76-FixUpdate适合写哪些操作？为什么" class="headerlink" title="76.FixUpdate适合写哪些操作？为什么"></a>76.FixUpdate适合写哪些操作？为什么</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">一些物理操作在物理中调用，比如Force，RigidBody
在Update中调用物理相关，可能会造成物理模拟异常
比如：rigidbody.AddForce(force * Time.deltaTime);如果卡了帧间隔过大，就会出现突然加速等现象</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="77-Assetbunle的优缺点？？"><a href="#77-Assetbunle的优缺点？？" class="headerlink" title="77. Assetbunle的优缺点？？"></a>77. Assetbunle的优缺点？？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">首先AB包可以压缩包体减少胞体大小，Resources不能
然后AB包可以自定义存储位置，可以放在本地或者云端，可以热更
缺点就是AB包需要维护，维护不好会出现冗余资源和循环依赖</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="78-animator是什么数据结构？animator如何优化蜘蛛网情况？？"><a href="#78-animator是什么数据结构？animator如何优化蜘蛛网情况？？" class="headerlink" title="78. animator是什么数据结构？animator如何优化蜘蛛网情况？？"></a>78. animator是什么数据结构？animator如何优化蜘蛛网情况？？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">状态机。子状态机</span>
</code></pre>
</details></blockquote>
<hr>
<h1 id="Shader相关"><a href="#Shader相关" class="headerlink" title="Shader相关"></a>Shader相关</h1><hr>
<h2 id="1-解释一下Unity中的渲染管线（Rendering-Pipeline）是什么，如何使用它，并举例说明它在游戏开发中的应用场景。"><a href="#1-解释一下Unity中的渲染管线（Rendering-Pipeline）是什么，如何使用它，并举例说明它在游戏开发中的应用场景。" class="headerlink" title="1. 解释一下Unity中的渲染管线（Rendering Pipeline）是什么，如何使用它，并举例说明它在游戏开发中的应用场景。"></a>1. 解释一下Unity中的渲染管线（Rendering Pipeline）是什么，如何使用它，并举例说明它在游戏开发中的应用场景。</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">渲染管线分为应用阶段、几何阶段和光栅化阶段</span>
<span style="color: red;">1.应用阶段
主要是CPU准备一些数据，比如顶点、法线、贴图和光照数据等等
2.几何阶段
几何阶段主要为GPU计算数据，如顶点计算、坐标转换、裁剪等等。
顶点着色器-》曲面细分着色器——》几何着色器——》裁剪——》屏幕映射
3.光栅化阶段
根据几何阶段的信息来计算每个片元覆盖哪些像素，经过深度测试、透明混合确定最终渲染的颜色。
三角形设置——》三角形遍历——》片元着色器——》逐片元操作</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="2-渲染管线中的几何阶段是由CPU主导还是GPU主导？该阶段主要是在做什么？"><a href="#2-渲染管线中的几何阶段是由CPU主导还是GPU主导？该阶段主要是在做什么？" class="headerlink" title="2. 渲染管线中的几何阶段是由CPU主导还是GPU主导？该阶段主要是在做什么？"></a>2. 渲染管线中的几何阶段是由CPU主导还是GPU主导？该阶段主要是在做什么？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
渲染管线中的几何阶段主要由GPU主导
在几何阶段中完成的最主要工作就是
顶点、法线等模型数据的相关处理
对他们进行坐标空间转换，裁剪画面外图元等等
还可以进行顶点着色，为每个顶点计算颜色、纹理坐标、法线等属性，以便在后续阶段用于处理</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="3-齐次坐标是什么-对于我们有什么作用？"><a href="#3-齐次坐标是什么-对于我们有什么作用？" class="headerlink" title="3.齐次坐标是什么?对于我们有什么作用？"></a>3.齐次坐标是什么?对于我们有什么作用？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
是什么？
就是将一个原本是 n 维的向量或矩阵用 n + 1维来表示
是一种扩展的坐标系统,，用于在计算机图形学等学科中进行数学运算
对于我们的作用？
利用齐次坐标，我们可以明确的区分向量和点，能够表示出平移变换</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="4-Shader开发中的坐标空间变换，主要是在哪几个空间中进行变换？变换顺序是什么？"><a href="#4-Shader开发中的坐标空间变换，主要是在哪几个空间中进行变换？变换顺序是什么？" class="headerlink" title="4. Shader开发中的坐标空间变换，主要是在哪几个空间中进行变换？变换顺序是什么？"></a>4. Shader开发中的坐标空间变换，主要是在哪几个空间中进行变换？变换顺序是什么？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
主要是将模型相关数据（顶点、法线、切线等）在
模型空间 —> 世界空间 —> 观察空间 —> 裁剪空间 —> 屏幕空间 
之间进行变换</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="5-Shader当中的顶点和片元着色器有什么作用？"><a href="#5-Shader当中的顶点和片元着色器有什么作用？" class="headerlink" title="5. Shader当中的顶点和片元着色器有什么作用？"></a>5. Shader当中的顶点和片元着色器有什么作用？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
顶点着色器：
主要作用是对物体的顶点位置进行变换和投影，从本地坐标系转换到世界坐标系和相机坐标系等。在这个阶段，顶点着色器还可以计算光照的影响、法线的变换，以及传递一些数据供后续阶段使用
--------------------------------------------------------------------------------
片元着色器：
主要处理像素的颜色、纹理和光照。在顶点着色器之后，渲染管线会对物体进行光栅化，将物体的几何形状转换为像素。在片元着色器中，针对每个像素，会进行插值和纹理采样，以及计算光照、阴影、反射等效果。片元着色器最终输出的颜色将决定每个像素的显示效果。
----------------------------------------------------------------------------------
这两个着色器阶段协同工作，将3D场景中的几何信息转换为2D屏幕上的像素颜色，从而实现图形的渲染和显示。</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="6-Unity-Shader中，深度测试是在做什么？"><a href="#6-Unity-Shader中，深度测试是在做什么？" class="headerlink" title="6. Unity Shader中，深度测试是在做什么？"></a>6. Unity Shader中，深度测试是在做什么？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
深度测试通过比较像素的深度值，来确定哪些像素应该被绘制到屏幕上，并决定它们的可见性。
深度测试的主要目标是解决遮挡关系，确保前面的对象覆盖后面的对象，从而正确呈现场景</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="7-Unity-Shader中某片元通过了深度测试，但是没有开启深度写入，该片元的颜色信息是否写入到颜色缓冲区？"><a href="#7-Unity-Shader中某片元通过了深度测试，但是没有开启深度写入，该片元的颜色信息是否写入到颜色缓冲区？" class="headerlink" title="7. Unity Shader中某片元通过了深度测试，但是没有开启深度写入，该片元的颜色信息是否写入到颜色缓冲区？"></a>7. Unity Shader中某片元通过了深度测试，但是没有开启深度写入，该片元的颜色信息是否写入到颜色缓冲区？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
会写入颜色缓冲区
因为深度写入和颜色写入是两个独立的操作
只要通过了深度测试，不管是否写入深度缓冲区
该片元的颜色信息都会写入到颜色缓冲区中</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="8-Shader当中的Blend渲染命令主要用来干什么？"><a href="#8-Shader当中的Blend渲染命令主要用来干什么？" class="headerlink" title="8. Shader当中的Blend渲染命令主要用来干什么？"></a>8. Shader当中的Blend渲染命令主要用来干什么？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
用来进行颜色混合的
将当前片元的颜色和颜色缓冲区中的颜色进行混合计算
------------------------------------------------------
一般可以用来实现半透明相关效果，光照颜色叠加相关效果等等</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="9-Shader当中的Blend渲染命令后面跟的参数是用来干嘛的？"><a href="#9-Shader当中的Blend渲染命令后面跟的参数是用来干嘛的？" class="headerlink" title="9. Shader当中的Blend渲染命令后面跟的参数是用来干嘛的？"></a>9. Shader当中的Blend渲染命令后面跟的参数是用来干嘛的？</h2><blockquote>
<p>比如：<br>Blend SrcAlpha OneMinusSrcAlpha</p>
<img src="https://skymirror-1316984539.cos.ap-beijing.myqcloud.com/Typoraimage-20250808110002264.png" alt="image-20250808110002264" style="zoom: 50%;" /></blockquote>
<blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：  
Blend混合命令后面跟的参数有两种写法
这些因子其实就是一些特定的数，用于参与混合计算
写法一：
输出颜色rgb = 源因子 * 片元颜色的rgb + 目标因子 * 颜色缓冲区中颜色的rgb
输出颜色a = 源透明因子 * 片元颜色的a + 目标透明因子 *颜色缓冲区中颜色的a
写法二：
输出颜色rgb = 源因子 * 片元颜色的rgb + 目标因子 * 颜色缓冲区中颜色的rgb
输出颜色a = 源因子 * 片元颜色的a + 目标因子 *颜色缓冲区中颜色的a</span>
</code></pre>
</details></blockquote>
<hr>
<h1 id="Lua相关"><a href="#Lua相关" class="headerlink" title="Lua相关"></a>Lua相关</h1><hr>
<h2 id="1-Lua如何实现面向对象的三大特性？"><a href="#1-Lua如何实现面向对象的三大特性？" class="headerlink" title="1. Lua如何实现面向对象的三大特性？"></a>1. Lua如何实现面向对象的三大特性？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
面向对象三大特性
封装：利用table进行封装
继承：利用元表和__index模拟继承关系
          设置子类的元表为父类，父类的__index为父类自己
          当子类身上找不到对应属性和方法时
          会查找元表的__index中的内容，也就是会查找父类中的内容
          通过这种方式来模拟继承
多态：子类自己去实现带：的同名方法即可</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="2-请说出Lua中常用的数据类型（至少说出6种）"><a href="#2-请说出Lua中常用的数据类型（至少说出6种）" class="headerlink" title="2. 请说出Lua中常用的数据类型（至少说出6种）"></a>2. 请说出Lua中常用的数据类型（至少说出6种）</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
nil
boolean
number
string
table
function
userdata
thread</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="3-Lua中pairs和ipairs的区别"><a href="#3-Lua中pairs和ipairs的区别" class="headerlink" title="3. Lua中pairs和ipairs的区别"></a>3. Lua中pairs和ipairs的区别</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
pairs可以遍历出表中的所有键值对信息，在遍历不规则表时，建议用它
ipairs只能遍历出连续信息，对于不规则结构，可能会缺失</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="4-Lua中常用的元方法有哪些？至少说出3个元方法"><a href="#4-Lua中常用的元方法有哪些？至少说出3个元方法" class="headerlink" title="4. Lua中常用的元方法有哪些？至少说出3个元方法"></a>4. Lua中常用的元方法有哪些？至少说出3个元方法</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
__index
__newindex
__tostring 
__call
__add 运算符+
__sub 运算符-
__mul 运算符*
__div 运算符/
__mod 运算符%
__unm 运算符-
__concat 运算符..
__eq 运算符==
__lt 运算符<
__le 运算符<=</span>
<span style="color: red;">2.装箱——把堆中内容迁移到栈中去（引用转值）</span>
</details></blockquote>
<hr>
<h2 id="5-Lua中元表的作用"><a href="#5-Lua中元表的作用" class="headerlink" title="5. Lua中元表的作用"></a>5. Lua中元表的作用</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
为一个表设置元表后，该表在某些特殊行为下可以调用元方法
比如：把表当字符串打印时，会调用元表的_tostring
当访问该表中不存在的变量时，会通过_index指定的表去找</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="6-Lua中-index和-newindex有什么作用"><a href="#6-Lua中-index和-newindex有什么作用" class="headerlink" title="6. Lua中__ index和__ newindex有什么作用"></a>6. Lua中__ index和__ newindex有什么作用</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
__index用于查找：如果访问不存在的数据，由__index提供最终结果
__newindex用于更新：如果对不存在的数据赋值，由__newindex对数据进行赋值</span>
</code></pre>
</details></blockquote>
<hr>
<h1 id="网络相关"><a href="#网络相关" class="headerlink" title="网络相关"></a>网络相关</h1><hr>
<h2 id="1-网络游戏开发中，网络传输数据的基本流程是什么？"><a href="#1-网络游戏开发中，网络传输数据的基本流程是什么？" class="headerlink" title="1. 网络游戏开发中，网络传输数据的基本流程是什么？"></a>1. 网络游戏开发中，网络传输数据的基本流程是什么？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
客户端将自定义类对象数据序列化为2进制数据发送给服务端
服务端将收到的2进制数据反序列化为对应的类对象进行逻辑处理
如果是服务端发送给客户端的消息也是同理</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="2-网络通讯中分包黏包指的是什么？我们应该如何解决这些问题？"><a href="#2-网络通讯中分包黏包指的是什么？我们应该如何解决这些问题？" class="headerlink" title="2. 网络通讯中分包黏包指的是什么？我们应该如何解决这些问题？"></a>2. 网络通讯中分包黏包指的是什么？我们应该如何解决这些问题？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
分包：一个独立的数据包（消息）被拆分成了多个小数据，分别发送出去
黏包：多个数据包（消息）被粘合在了一起，变成了一个更大的数据包，发送出去
解决：加入消息头，在消息头中加入长度等其他信息，用于接收后判断消息长度，进行对应的逻辑处理</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="3-TCP和UDP通讯最大的区别是什么？"><a href="#3-TCP和UDP通讯最大的区别是什么？" class="headerlink" title="3. TCP和UDP通讯最大的区别是什么？"></a>3. TCP和UDP通讯最大的区别是什么？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
安全性上：
TCP是安全可靠的，有序、无差错、不丢失
而UDP不保证可靠性，发送的数据可能会丢失，也可能会乱序
--------------------------------------------
效率上：
UDP通讯效率更高</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="4-如果想要让UDP通讯具备TCP的优点，应该如何处理？"><a href="#4-如果想要让UDP通讯具备TCP的优点，应该如何处理？" class="headerlink" title="4. 如果想要让UDP通讯具备TCP的优点，应该如何处理？"></a>4. 如果想要让UDP通讯具备TCP的优点，应该如何处理？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：  
主要思路就是基于UDP模拟出TCP的安全性
主要做法：
1.为消息加入序号：为UDP发送的每一个消息加入一个序号
2.加入消息确认机制：接收端在成功接收到一个消息后，向发送端发送一个确认消息，表示该消息已经被正确接收。
3.加入超时重传机制：发送端在超时时间内未收到确认，则进行消息的重传。</span>
</code></pre>
</details></blockquote>
<hr>
<h1 id="数学相关"><a href="#数学相关" class="headerlink" title="数学相关"></a>数学相关</h1><hr>
<h2 id="1-是不是所有矩阵都有逆矩阵？如何计算一个矩阵的逆矩阵？"><a href="#1-是不是所有矩阵都有逆矩阵？如何计算一个矩阵的逆矩阵？" class="headerlink" title="1. 是不是所有矩阵都有逆矩阵？如何计算一个矩阵的逆矩阵？"></a>1. 是不是所有矩阵都有逆矩阵？如何计算一个矩阵的逆矩阵？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
1.并不是所有矩阵都有逆矩阵
2.计算流程
第一步：确定矩阵是否为方阵（即行列数相等）
第二步：计算矩阵的行列式（若行列式为0，则该矩阵没有逆矩阵）
第三步：计算矩阵的代数余子式矩阵
第四步：计算标准伴随矩阵（转置代数余子式矩阵）
第五步：计算逆矩阵（标准伴随矩阵 / 行列式）</span>
</code></pre>
</details></blockquote>
<hr>
<h1 id="算法相关"><a href="#算法相关" class="headerlink" title="算法相关"></a><code>算法相关</code></h1><h2 id="1-请问七大排序算法一般指哪七种排序算法？你一般常用的排序算法是哪种？请简单描述它的排序原理"><a href="#1-请问七大排序算法一般指哪七种排序算法？你一般常用的排序算法是哪种？请简单描述它的排序原理" class="headerlink" title="1. 请问七大排序算法一般指哪七种排序算法？你一般常用的排序算法是哪种？请简单描述它的排序原理"></a>1. 请问七大排序算法一般指哪七种排序算法？你一般常用的排序算法是哪种？请简单描述它的排序原理</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
冒泡排序
选择排序
插入排序
希尔排序
归并排序
快速排序
堆排序</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="2-请简单描述斐波那契数列的基本规则是什么"><a href="#2-请简单描述斐波那契数列的基本规则是什么" class="headerlink" title="2. 请简单描述斐波那契数列的基本规则是什么"></a>2. 请简单描述斐波那契数列的基本规则是什么</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
假设数列从索引0开始
斐波那契数列的基本规则就是从数列的第2项开始，每一项的值都是前两项的和：
F(n) = F(n-1)+F(n-2)  n >= 2
即：
1,1,2,3,5,8,13,21.......</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="3-请简单描述A星寻路算法的基本原理"><a href="#3-请简单描述A星寻路算法的基本原理" class="headerlink" title="3. 请简单描述A星寻路算法的基本原理"></a>3. 请简单描述A星寻路算法的基本原理</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
关键点：
1.寻路消耗公式：f(寻路消耗) = g(离起点距离) + h(离重点距离)
2.开启列表
3.关闭列表
基本原理：
每一次寻路，计算周围点的寻路消耗，并放入开启列表，对开启列表进行排序，得到寻路消耗最小的点放入关闭列表中</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="4-递归函数是什么？请用一句话总结"><a href="#4-递归函数是什么？请用一句话总结" class="headerlink" title="4. 递归函数是什么？请用一句话总结"></a>4. 递归函数是什么？请用一句话总结</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
递归函数就是在函数定义中使用自己的函数（自己调用自己）</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="5-在编写递归函数时，最需要关注的两点是什么？请说出你自己的理解"><a href="#5-在编写递归函数时，最需要关注的两点是什么？请说出你自己的理解" class="headerlink" title="5.  在编写递归函数时，最需要关注的两点是什么？请说出你自己的理解"></a>5.  在编写递归函数时，最需要关注的两点是什么？请说出你自己的理解</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
1.结束条件：在什么情况下递归会结束，否则会死循环
2.问题规模的减小：递归函数通过自身来解决问题的规模，每次递归都应该将问题分成一个或多个更小规模的子问题，直到达到结束条件
---------------------------------------------------------------
这两个关键点都是为了确保递归函数不会无限的执行下去，避免死循环</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="6-二分查找-折半查找-的原理是什么？"><a href="#6-二分查找-折半查找-的原理是什么？" class="headerlink" title="6. 二分查找(折半查找)的原理是什么？"></a>6. 二分查找(折半查找)的原理是什么？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：  
在一组有序（升\降）的数据中查找一个元素时
将目标元素和查找范围的中间值做比较
若目标==中间值，查找结束
若目标 != 中间值，将目标分到较大\较小的一组
通过分组，可以将查找范围缩小一半
再新租中重复刚才的步骤，直到找到目标</span>
</code></pre>
</details></blockquote>
<hr>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://wqxblog.top">wqx</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://wqxblog.top/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/">http://wqxblog.top/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://wqxblog.top" target="_blank">游戏开发笔记</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a></div><div class="post-share"><div class="social-share" data-image="https://skymirror-1316984539.cos.ap-beijing.myqcloud.com/Typoramimi.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/%E6%B8%B2%E6%9F%93/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E5%9F%BA%E7%A1%80/" title="渲染管线基础"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">渲染管线基础</div></div><div class="info-2"><div class="info-item-1"> 该内容基于Games101课程，内容可能有些杂乱，后续会详细整理。建议学习shader之前要看过一遍101  渲染管线基础 所谓渲染就是把三维空间的物体变成一张图 渲染管线就是将数据分阶段的变为屏幕图像的过程        具体绘制流程如下：  模型空间变换到世界空间 世界空间变换到观察空间 观察空间变换到裁剪空间 裁剪空间变换到屏幕空间 拿到屏幕空间对应映射的位置后，进行光栅化绘制像素       渲染管线分为三个阶段  应用阶段  该阶段中我们将渲染需要的数据传递给GPU用于后续两个阶段的处理  该阶段主导者为CPU  该阶段为渲染做了哪些准备？？  把不可见的物体数据剔除 准备好模型相关数据（顶点、法线、切线、贴图、着色器等等） 将数据加载到显存中 设置渲染状态（设置网格需要使用哪个着色器、材质、光源属性等等） 调用DrawCall（CPU通知GPU使用相关的数据和渲染状态进行渲染）       几何阶段  图元：几何体的最小可绘制单元。就是由顶点数据组合成的点、线、三角形。   ​           ...</div></div></div></a><a class="pagination-related" href="/%E6%A1%88%E4%BE%8B/Lily%E5%A5%A5%E5%BE%B7%E8%B5%9B/%E5%AE%9E%E6%88%98%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98/" title="实战中的问题"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">实战中的问题</div></div><div class="info-2"><div class="info-item-1">实战中的问题一、人物为什么没有动画情况下是张开双臂的状态 答案：建模时要绑定骨骼，四肢要明确反映出来，具体到底是头躯干还是腿，默认使用T字模型。   二、速通新InputSystem1.InputSystem是什么 绑定—》按下—》开始、触发、结束三个事件    2.Action参数   3.输入动作设置    4. 相互作用设置     5.值加工设置    6.按键绑定    7.InputAction类使用（1）启用输入检测 委托变量.Enable()；   （2）操作监听 三个基本事件     监听函数 使用CallbackContext获取信息CallbackContext context参数包含了触发动作的所有信息。你可以使用这个上下文来访问更多细节，例如：  context.ReadValue&lt;float&gt;(): 获取输入值（例如，对于键盘按键或手柄按钮）。 context.control: 获取触发该动作的输入控件。 context.interaction: 获取当前交互类型（例如，是否为按下、释放等）。 context.phase:...</div></div></div></a></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="https://skymirror-1316984539.cos.ap-beijing.myqcloud.com/Typoramimi.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">wqx</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">27</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">21</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">-只用于学习如有版权问题请联系我 484807196@qq.com</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E7%9B%B8%E5%85%B3"><span class="toc-number">1.</span> <span class="toc-text">C#相关</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%A3%85%E7%AE%B1%E5%92%8C%E6%8B%86%E7%AE%B1%E6%98%AF%E6%8C%87%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.1.</span> <span class="toc-text">1. 装箱和拆箱是指什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%80%BC%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%9C%A8%E5%8F%98%E9%87%8F%E8%B5%8B%E5%80%BC%E6%97%B6%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.2.</span> <span class="toc-text">2. 值和引用类型在变量赋值时的区别是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%A7%94%E6%89%98%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%9C%A8%E4%BD%BF%E7%94%A8%E4%B8%8A%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.3.</span> <span class="toc-text">3.  委托和事件在使用上的区别是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%9C%89%E4%B8%A4%E4%B8%AA%E6%8E%A5%E5%8F%A3IA%E5%92%8CIB%EF%BC%8C%E4%BB%96%E4%BB%AC%E4%B8%AD%E6%9C%89%E4%B8%80%E4%B8%AA%E5%90%8C%E5%90%8D%E6%96%B9%E6%B3%95Test-%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%90%8C%E6%97%B6%E7%BB%A7%E6%89%BF%E8%BF%99%E4%B8%A4%E4%B8%AA%E6%8E%A5%E5%8F%A3%EF%BC%8C%E5%BA%94%E8%AF%A5%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E4%BB%96%E4%BB%AC%E7%9A%84%E5%90%8C%E5%90%8D%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">1.4.</span> <span class="toc-text">4. 有两个接口IA和IB，他们中有一个同名方法Test()一个类同时继承这两个接口，应该如何处理他们的同名方法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E8%AF%B7%E8%AF%B4%E6%98%8EC-%E4%B8%AD%E7%9A%84List%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A9%E5%AE%B9%E7%9A%84"><span class="toc-number">1.5.</span> <span class="toc-text">5. 请说明C#中的List是如何扩容的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E8%AF%B7%E8%AF%B4%E8%AF%B4%E4%BD%A0%E8%AE%A4%E4%B8%BAC-%E4%B8%AD-%E5%92%8C-Equals-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.6.</span> <span class="toc-text">6.请说说你认为C#中 &#x3D;&#x3D; 和 Equals 的区别是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.7.</span> <span class="toc-text">7. 浅拷贝和深拷贝的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E4%B8%8A%E9%9D%A2%E4%B8%A4%E7%A7%8D%E8%8E%B710000%E4%B8%AA%E6%95%B0%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%8C%E5%93%AA%E7%A7%8D%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88"><span class="toc-number">1.8.</span> <span class="toc-text">8. 上面两种获10000个数的方式，哪种效率更高？为什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E8%AF%B7%E8%AF%B4%E5%87%BA%E4%BB%A5%E4%B8%8A%E4%BB%A3%E7%A0%81%EF%BC%9A1-A%E5%A4%84%E5%92%8CB%E5%A4%84%E8%B0%81%E5%85%88%E6%89%93%E5%8D%B0%EF%BC%9F-2-A%E3%80%81B%E5%87%BA%E6%89%93%E5%8D%B0%E7%9A%84i%E5%80%BC%E5%88%86%E5%88%AB%E6%98%AF%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="toc-number">1.9.</span> <span class="toc-text">9. 请说出以上代码：1.A处和B处谁先打印？ 2. A、B出打印的i值分别是多少？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E6%B3%9B%E5%9E%8B%E7%9A%84%E7%BA%A6%E6%9D%9F%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%EF%BC%9F"><span class="toc-number">1.10.</span> <span class="toc-text">10.泛型的约束有哪几种？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E4%BB%80%E4%B9%88%E6%98%AF%E9%97%AD%E5%8C%85%EF%BC%9F%E5%8F%AF%E4%BB%A5%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E"><span class="toc-number">1.11.</span> <span class="toc-text">11 . 什么是闭包？可以举例说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%8C%87%E4%BB%80%E4%B9%88%EF%BC%9F%E5%B8%B8%E8%A7%81%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">1.12.</span> <span class="toc-text">12 . 内存泄漏指什么？常见的内存泄漏有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-%E5%BA%8F%E5%88%97%E5%8C%96%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%B8%B8%E8%A7%81%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E6%88%91%E4%BB%AC%E4%BC%9A%E7%94%A8%E5%88%B0%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%9F"><span class="toc-number">1.13.</span> <span class="toc-text">13. 序列化是什么？常见的序列化方式有哪些？什么时候我们会用到序列化？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-%E8%AF%B7%E8%AF%B4%E6%98%8E%E4%BB%A5%E4%B8%8B%E4%B8%89%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.14.</span> <span class="toc-text">14. 请说明以下三者的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-C-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%8C%E9%87%8D%E8%BD%BD-%E5%92%8C-%E4%BB%A5%E5%8F%8A-%E4%B8%87%E7%89%A9%E4%B9%8B%E7%88%B6Object%E5%9F%BA%E7%B1%BB%E4%B8%AD%E7%9A%84%E8%99%9A%E6%96%B9%E6%B3%95-virtual-bool-Equals-Object-obj-%E5%AF%B9%E4%BA%8E%E6%88%91%E4%BB%AC%E7%9A%84%E6%84%8F%E4%B9%89%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.15.</span> <span class="toc-text">15. C#重载运算符，重载 &#x3D;&#x3D; 和 !&#x3D; 以及 万物之父Object基类中的虚方法 virtual bool Equals(Object obj)对于我们的意义是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-%E5%9C%A8%E5%BC%80%E5%8F%91%E6%97%B6%EF%BC%8C%E5%AF%B9string%E5%92%8CStringBuilder%E6%88%91%E4%BB%AC%E5%BA%94%E8%AF%A5%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9"><span class="toc-number">1.16.</span> <span class="toc-text">16.在开发时，对string和StringBuilder我们应该如何选择</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-%E8%AF%B7%E7%AE%80%E8%A6%81%E8%AF%B4%E6%98%8E-Net%E8%B7%A8%E8%AF%AD%E8%A8%80%E5%8E%9F%E7%90%86"><span class="toc-number">1.17.</span> <span class="toc-text">17. 请简要说明.Net跨语言原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-%E8%AF%B7%E7%AE%80%E8%A6%81%E8%AF%B4%E6%98%8E-Net%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%8E%9F%E7%90%86"><span class="toc-number">1.18.</span> <span class="toc-text">18. 请简要说明.Net跨平台原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.19.</span> <span class="toc-text">19. 数组和链表的区别是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-C-%E4%B8%AD%E7%9A%84Action%E5%92%8CFunc%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9FUnity-%E4%B8%AD%E7%9A%84UnityAction%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%BB%96%E4%BB%AC%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.20.</span> <span class="toc-text">20. C# 中的Action和Func是什么？Unity 中的UnityAction是什么？他们有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-%EF%BC%88%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%AD%E7%9A%84%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%EF%BC%89%E8%AF%B7%E9%97%AE%E6%9C%80%E7%BB%88%E5%BE%97%E5%88%B0%E6%89%93%E5%8D%B0%E7%BB%93%E6%9E%9C%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%EF%BC%9F"><span class="toc-number">1.21.</span> <span class="toc-text">21. （结构体中的引用类型）请问最终得到打印结果是什么？？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-C-%E4%B8%AD%E5%A6%82%E4%BD%95%E8%AE%A9%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AE%B9%E5%99%A8%E7%B1%BB%E8%83%BD%E5%A4%9F%E4%BD%BF%E7%94%A8for%E5%BE%AA%E7%8E%AF%E9%81%8D%E5%8E%86%EF%BC%9F%EF%BC%88%E9%80%9A%E8%BF%87-%E7%B1%BB%E5%AF%B9%E8%B1%A1-%E7%B4%A2%E5%BC%95-%E7%9A%84%E5%BD%A2%E5%BC%8F%E9%81%8D%E5%8E%86%EF%BC%89"><span class="toc-number">1.22.</span> <span class="toc-text">22. C#中如何让自定义容器类能够使用for循环遍历？（通过 类对象[索引] 的形式遍历）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-C-%E4%B8%AD%E5%A6%82%E4%BD%95%E8%AE%A9%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AE%B9%E5%99%A8%E7%B1%BB%E8%83%BD%E5%A4%9F%E4%BD%BF%E7%94%A8foreach%E5%BE%AA%E7%8E%AF%E9%81%8D%E5%8E%86%EF%BC%9F"><span class="toc-number">1.23.</span> <span class="toc-text">23. C#中如何让自定义容器类能够使用foreach循环遍历？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-C-%E4%B8%AD%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E8%AF%B4%E8%AF%B4%E4%BD%A0%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">1.24.</span> <span class="toc-text">24. C#中接口的作用是什么？说说你的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25-%E8%AF%B7%E9%97%AE%E4%BB%A5%E4%B8%8A%E8%BF%99%E4%B8%89%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%8C%E8%BF%90%E8%A1%8C%E5%90%8E%EF%BC%8C%E5%9C%A8%E5%A0%86%E4%B8%8A%E4%BC%9A%E5%88%86%E9%85%8D%E5%87%A0%E4%B8%AA%E2%80%9C%E6%88%BF%E9%97%B4%E2%80%9D"><span class="toc-number">1.25.</span> <span class="toc-text">25. 请问以上这三行代码，运行后，在堆上会分配几个“房间”</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26-C-%E4%B8%AD%E5%A6%82%E4%BD%95%E8%AE%A9%E4%B8%80%E4%B8%AA%E7%B1%BB%E4%B8%8D%E8%83%BD%E5%86%8D%E8%A2%AB%E5%85%B6%E4%BB%96%E7%B1%BB%E6%89%80%E7%BB%A7%E6%89%BF%EF%BC%9F"><span class="toc-number">1.26.</span> <span class="toc-text">26. C#中如何让一个类不能再被其他类所继承？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27-C-%E4%B8%AD%E5%85%83%E7%BB%84%E5%AF%B9%E4%BA%8E%E6%88%91%E4%BB%AC%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.27.</span> <span class="toc-text">27. C#中元组对于我们的作用是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28-C-%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B%E7%9A%84%E5%A5%BD%E5%A4%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.28.</span> <span class="toc-text">28. C#中使用泛型的好处是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#29-%E8%AF%B7%E8%AF%B4%E6%98%8EThread%E3%80%81ThreadPool%E3%80%81Task%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%B9%B6%E7%AE%80%E5%8D%95%E8%AF%B4%E6%98%8E%E5%BD%BC%E6%AD%A4%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.29.</span> <span class="toc-text">29. 请说明Thread、ThreadPool、Task分别是什么？并简单说明彼此的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#30-%E8%AF%B7%E7%AE%80%E8%BF%B0GC%EF%BC%88%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%89%E4%BA%A7%E7%94%9F%E7%9A%84%E5%8E%9F%E5%9B%A0%EF%BC%8C%E5%B9%B6%E8%87%B3%E5%B0%91%E8%AF%B4%E5%87%BA%E9%81%BF%E5%85%8DGC%E5%8F%91%E7%94%9F%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">1.30.</span> <span class="toc-text">30.请简述GC（垃圾回收）产生的原因，并至少说出避免GC发生的三种方式？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#31-%E5%A6%82%E6%9E%9C%E6%88%91%E4%BB%AC%E6%83%B3%E4%B8%BAUnity%E4%B8%AD%E7%9A%84Transform%E7%B1%BB%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%8C%E5%BA%94%E8%AF%A5%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%EF%BC%9F"><span class="toc-number">1.31.</span> <span class="toc-text">31. 如果我们想为Unity中的Transform类添加一个自定义的方法，应该如何处理？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32-%E8%AF%B7%E8%AF%B4%E5%87%BAusing%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%B8%A4%E4%B8%AA%E4%BD%9C%E7%94%A8"><span class="toc-number">1.32.</span> <span class="toc-text">32. 请说出using关键字的两个作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#33-C-%E4%B8%ADDictionary%E4%B8%8D%E6%94%AF%E6%8C%81%E7%9B%B8%E5%90%8C%E9%94%AE%E5%AD%98%E5%82%A8%E5%A6%82%E6%9E%9C%E6%83%B3%E8%A6%81%E4%B8%80%E4%B8%AA%E9%94%AE%E5%AF%B9%E5%BA%94%E5%A4%9A%E4%B8%AA%E5%80%BC%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%EF%BC%9F"><span class="toc-number">1.33.</span> <span class="toc-text">33. C#中Dictionary不支持相同键存储如果想要一个键对应多个值如何处理？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#34-%E8%AF%B7%E9%97%AE%E4%B8%8A%E9%9D%A2%E4%BB%A3%E7%A0%81%E7%9A%84%E6%9C%80%E7%BB%88%E6%89%93%E5%8D%B0%E7%BB%93%E6%9E%9C%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.34.</span> <span class="toc-text">34. 请问上面代码的最终打印结果是什么？为什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#35-%E4%B8%8A%E9%A2%98%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%88%91%E4%BB%AC%E5%B8%8C%E6%9C%9B%E6%89%93%E5%8D%B0%E5%87%BA0-9%EF%BC%8C%E5%BA%94%E8%AF%A5%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81%EF%BC%9F"><span class="toc-number">1.35.</span> <span class="toc-text">35.上题中的代码，如果我们希望打印出0~9，应该如何修改代码？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#36-%E5%86%85%E5%AD%98%E4%B8%AD%EF%BC%8C%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.36.</span> <span class="toc-text">36. 内存中，堆和栈的区别是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#37-TCP%E5%8D%8F%E8%AE%AE%E5%92%8CUDP%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.37.</span> <span class="toc-text">37.TCP协议和UDP协议的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#38-TCP%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7%E6%98%AF%E5%A6%82%E4%BD%95%E8%BE%BE%E5%88%B0%E7%9A%84%EF%BC%9F"><span class="toc-number">1.38.</span> <span class="toc-text">38. TCP协议的可靠性是如何达到的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#39-%E5%86%85%E5%AD%98%E6%8A%96%E5%8A%A8%E6%8C%87%E4%BB%80%E4%B9%88%EF%BC%9F%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%86%85%E5%AD%98%E6%8A%96%E5%8A%A8"><span class="toc-number">1.39.</span> <span class="toc-text">39. 内存抖动指什么？如何避免内存抖动</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#40-%E6%96%87%E4%BB%B6%E4%B8%AD%E4%BF%9D%E5%AD%98%E4%BA%86%E6%96%87%E6%9C%AC%E4%BF%A1%E6%81%AF%EF%BC%8C%E4%BD%86%E6%98%AF%E6%89%93%E5%BC%80%E5%90%8E%E5%8D%B4%E6%98%AF%E4%B9%B1%E7%A0%81%EF%BC%8C%E4%B8%80%E8%88%AC%E6%98%AF%E4%BB%80%E4%B9%88%E5%8E%9F%E5%9B%A0%E9%80%A0%E6%88%90%E7%9A%84%EF%BC%9F"><span class="toc-number">1.40.</span> <span class="toc-text">40. 文件中保存了文本信息，但是打开后却是乱码，一般是什么原因造成的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#41-C-%E4%B8%ADnew%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%88%E8%87%B3%E5%B0%91%E8%AF%B4%E5%87%BA3%E7%A7%8D%EF%BC%89"><span class="toc-number">1.41.</span> <span class="toc-text">41. C#中new关键字的作用（至少说出3种）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#42-%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%E5%92%8C%E5%BC%82%E6%AD%A5%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%EF%BC%9F"><span class="toc-number">1.42.</span> <span class="toc-text">42. 同步方法和异步方法的区别是什么？异步编程是什么意思？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#43-%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E6%8C%87%E4%BB%80%E4%B9%88%EF%BC%9F%E4%B8%80%E8%88%AC%E5%9C%A8%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8%EF%BC%9F%EF%BC%88%E8%87%B3%E5%B0%91%E8%AF%B4%E5%87%BA3%E7%A7%8D%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%89"><span class="toc-number">1.43.</span> <span class="toc-text">43. 回调函数指什么？一般在什么时候使用？（至少说出3种使用场景）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#44-%E5%A6%82%E4%BD%95%E7%94%A8%E4%B8%80%E4%B8%AAint%E5%8F%98%E9%87%8F%EF%BC%8C%E8%AE%B0%E5%BD%9532%E7%A7%8D%E7%8A%B6%E6%80%81%EF%BC%9F%EF%BC%88%E6%B3%A8%E6%84%8F%EF%BC%9A%E7%8A%B6%E6%80%81%E5%8F%AF%E4%BB%A5%E5%B9%B6%E5%AD%98%EF%BC%89"><span class="toc-number">1.44.</span> <span class="toc-text">44. 如何用一个int变量，记录32种状态？（注意：状态可以并存）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#45-csharp%E9%87%8C%E9%9D%A2%E6%9C%89%E4%B8%80%E4%B8%AA%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8E%A5%E5%8F%A3%E5%8F%AB%E5%81%9AIDispose%EF%BC%8C%E5%AE%83%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%EF%BC%9F"><span class="toc-number">1.45.</span> <span class="toc-text">45. csharp里面有一个常用的接口叫做IDispose，它的作用是？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#46-%E4%B8%8A%E4%B8%80%E9%A2%98%E8%BF%BD%E9%97%AE%EF%BC%9Acsharp%E6%9C%89%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%EF%BC%8C%E6%8A%8A%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E8%AE%BE%E7%BD%AE%E4%B8%BA%E7%A9%BA%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E7%B3%BB%E7%BB%9F%E4%BC%9A%E5%B8%AE%E6%88%91%E4%BB%AC%E5%9B%9E%E6%94%B6%EF%BC%8C%E5%AE%83%E5%92%8C%E6%8E%A5%E5%8F%A3IDispose%E6%9C%89%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB%E5%90%97%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%AD%98%E5%9C%A8%E4%B8%A4%E4%B8%AA%E5%81%9A%E6%9E%90%E6%9E%84%E4%BA%8B%E6%83%85%E7%9A%84%E4%B8%9C%E8%A5%BF%E5%91%A2%EF%BC%9F"><span class="toc-number">1.46.</span> <span class="toc-text">46. 上一题追问：csharp有垃圾回收机制，把一个对象设置为空的时候，系统会帮我们回收，它和接口IDispose有什么关系吗？为什么会存在两个做析构事情的东西呢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#47-C-%E4%B8%AD%E5%93%AA%E4%BA%9B%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E6%98%AF%E5%80%BC%E7%B1%BB%E5%9E%8B%EF%BC%88%E8%87%B3%E5%B0%91%E8%AF%B4%E5%87%BA13%E7%A7%8D%EF%BC%89%EF%BC%8C%E5%93%AA%E4%BA%9B%E6%98%AF%E5%BC%95%E7%94%A8%E8%AF%A5%E7%B1%BB%E5%9E%8B%EF%BC%88%E8%87%B3%E5%B0%91%E8%AF%B4%E5%87%BA5%E7%A7%8D%EF%BC%89"><span class="toc-number">1.47.</span> <span class="toc-text">47. C#中哪些变量类型是值类型（至少说出13种），哪些是引用该类型（至少说出5种）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#48-%E5%9C%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E4%B8%AD%E5%A3%B0%E6%98%8E%E7%9A%84%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%EF%BC%8C%E7%B1%BB%E5%9E%8B%E4%B8%BAint%EF%BC%8C%E8%AF%A5int%E5%8F%98%E9%87%8F%E5%AD%98%E5%82%A8%E5%9C%A8%E6%A0%88%E4%B8%8A%E8%BF%98%E6%98%AF%E5%A0%86%E4%B8%8A%EF%BC%9F%E5%9C%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%AD%E5%A3%B0%E6%98%8E%E7%9A%84%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%EF%BC%8C%E7%B1%BB%E5%9E%8B%E4%B8%BAstring%EF%BC%8C%E8%AF%A5string%E5%8F%98%E9%87%8F%E5%AD%98%E5%82%A8%E5%9C%A8%E6%A0%88%E4%B8%8A%E8%BF%98%E6%98%AF%E5%A0%86%E4%B8%8A%EF%BC%9F"><span class="toc-number">1.48.</span> <span class="toc-text">48. 在自定义类中声明的成员变量，类型为int，该int变量存储在栈上还是堆上？在自定义结构体中声明的成员变量，类型为string，该string变量存储在栈上还是堆上？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#49-C-%E4%B8%AD%E5%9C%A8%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E9%80%89%E6%8B%A9%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3%EF%BC%8C%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E9%80%89%E6%8B%A9%E4%BD%BF%E7%94%A8%E6%8A%BD%E8%B1%A1%E7%B1%BB%EF%BC%9F"><span class="toc-number">1.49.</span> <span class="toc-text">49.C#中在什么情况下会选择使用接口，什么情况下会选择使用抽象类？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#50-C-%E4%B8%AD%E4%BB%80%E4%B9%88%E6%98%AF%E6%89%98%E7%AE%A1%E5%86%85%E5%AD%98%E5%92%8C%E9%9D%9E%E6%89%98%E7%AE%A1%E5%86%85%E5%AD%98%EF%BC%9F"><span class="toc-number">1.50.</span> <span class="toc-text">50. C#中什么是托管内存和非托管内存？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#51-%E8%AF%B7%E9%97%AE%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%9F%E5%A6%82%E4%BD%95%E5%9C%A8C-%E4%B8%AD%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%93%8D%E4%BD%9C%EF%BC%9F"><span class="toc-number">1.51.</span> <span class="toc-text">51. 请问什么是线程安全？如何在C#中实现线程安全操作？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#52-C-%E4%B8%AD%E5%B1%9E%E6%80%A7-Property-%E5%92%8C%E5%AD%97%E6%AE%B5-Field-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.52.</span> <span class="toc-text">52. C#中属性(Property)和字段(Field)的区别是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#53-%E8%AF%B7%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8BC-%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B%EF%BC%88Async-Await%EF%BC%89%EF%BC%8C%E5%AE%83%E6%98%AF%E7%94%A8%E6%9D%A5%E5%81%9A%E4%BB%80%E4%B9%88%E7%9A%84%EF%BC%9F"><span class="toc-number">1.53.</span> <span class="toc-text">53. 请解释一下C#中的异步编程模型（Async&#x2F;Await），它是用来做什么的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#54-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%AD%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E6%8A%BD%E8%B1%A1%E5%87%BD%E6%95%B0%EF%BC%8C%E6%98%AF%E5%90%A6%E5%BF%85%E9%A1%BB%E5%9C%A8%E5%AD%90%E7%B1%BB%E4%B8%AD%E9%87%8D%E5%86%99%EF%BC%9F"><span class="toc-number">1.54.</span> <span class="toc-text">54. 抽象类中的虚函数和抽象函数，是否必须在子类中重写？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#55-%E5%BD%93%E6%88%91%E4%BB%AC%E4%BD%BF%E7%94%A8%E9%87%8C%E5%BC%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99%EF%BC%8C%E7%94%A8%E7%88%B6%E7%B1%BB%E5%AE%B9%E5%99%A8%E8%A3%85%E8%BD%BD%E5%AD%90%E7%B1%BB%E5%AF%B9%E8%B1%A1%E6%97%B6%E6%88%91%E4%BB%AC%E9%80%9A%E8%BF%87%E8%AF%A5%E7%88%B6%E7%B1%BB%E5%AE%B9%E5%99%A8%E8%B0%83%E7%94%A8%E5%85%B6%E4%B8%AD%E7%9A%84%E4%B8%80%E4%B8%AA%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%8C%E6%89%A7%E8%A1%8C%E7%9A%84%E9%80%BB%E8%BE%91%E6%98%AF%E7%88%B6%E7%B1%BB%E4%B8%AD%E7%9A%84%E8%BF%98%E6%98%AF%E5%AD%90%E7%B1%BB%E4%B8%AD%E7%9A%84%E9%80%BB%E8%BE%91%E5%91%A2%EF%BC%9F"><span class="toc-number">1.55.</span> <span class="toc-text">55. 当我们使用里式替换原则，用父类容器装载子类对象时我们通过该父类容器调用其中的一个虚函数，执行的逻辑是父类中的还是子类中的逻辑呢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#56-%E6%88%91%E4%BB%AC%E5%9C%A8%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E6%97%B6%EF%BC%8C%E6%83%B3%E8%A6%81%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4%EF%BC%8C%E5%BA%94%E8%AF%A5%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%EF%BC%9F"><span class="toc-number">1.56.</span> <span class="toc-text">56. 我们在游戏开发时，想要获取系统时间，应该如何获取？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#57-C-%E4%BD%BF%E7%94%A8var%E5%A3%B0%E6%98%8E%E4%B8%B4%E6%97%B6%E5%8F%98%E9%87%8F%E7%9B%B8%E6%AF%94%E7%94%A8%E6%8C%87%E5%AE%9A%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E%E4%B8%B4%E6%97%B6%E5%8F%98%E9%87%8F%EF%BC%8C%E5%9C%A8%E6%9C%80%E7%BB%88%E6%89%A7%E8%A1%8C%E6%97%B6%E6%98%AF%E5%90%A6%E4%BC%9A%E5%A2%9E%E5%8A%A0%E6%80%A7%E8%83%BD%E6%B6%88%E8%80%97%EF%BC%9F"><span class="toc-number">1.57.</span> <span class="toc-text">57. C#使用var声明临时变量相比用指定变量类型声明临时变量，在最终执行时是否会增加性能消耗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#58-%E6%88%91%E4%BB%AC%E7%9F%A5%E9%81%93%EF%BC%8C%E4%B8%8A%E8%BF%B0%E4%BB%A3%E7%A0%81b%E6%94%B9%E4%B8%BA20%E5%90%8E%EF%BC%8Ca%E8%BF%98%E6%98%AF10%E3%80%82%EF%BC%88%E5%80%BC%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%89%B9%E7%82%B9%EF%BC%89%E6%88%91%E4%BB%AC%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E7%AE%80%E5%8D%95%E4%BF%AE%E6%94%B9%E4%BB%A5%E4%B8%8A%E4%BB%A3%E7%A0%81%EF%BC%8C%E8%AE%A9b%E5%8F%98%E6%88%9020%E5%90%8E%EF%BC%8Ca%E8%B7%9F%E7%9D%80%E4%B8%80%E8%B5%B7%E5%8F%98%E3%80%82"><span class="toc-number">1.58.</span> <span class="toc-text">58. 我们知道，上述代码b改为20后，a还是10。（值类型的特点）我们是否可以简单修改以上代码，让b变成20后，a跟着一起变。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#59-%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8C-%E4%B8%AD%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%9D%A5%E5%81%9A%E4%BB%80%E4%B9%88%EF%BC%9F%E8%87%B3%E5%B0%91%E8%AF%B4%E5%87%BA%E4%B8%A4%E7%82%B9"><span class="toc-number">1.59.</span> <span class="toc-text">59. 我们可以使用C#中的迭代器来做什么？至少说出两点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#60-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%B9%B6%E9%80%89%E6%8B%A9%E5%85%B6%E4%B8%AD%E4%B8%80%E4%B8%AA%E5%8E%9F%E5%88%99%E8%AF%B4%E6%98%8E%E5%AE%83%E7%9A%84%E6%84%8F%E6%80%9D"><span class="toc-number">1.60.</span> <span class="toc-text">60. 面向对象的七大原则分别是什么？并选择其中一个原则说明它的意思</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#61-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%9C%A8%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD%E5%BE%88%E5%B8%B8%E7%94%A8%EF%BC%9F%E8%87%B3%E5%B0%91%E8%AF%B4%E5%87%BA3%E4%B8%AA%E4%BC%98%E7%82%B9"><span class="toc-number">1.61.</span> <span class="toc-text">61. 为什么单例模式在游戏开发中很常用？至少说出3个优点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#62-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%9C%A8%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD%E4%B8%80%E8%88%AC%E7%94%A8%E6%9D%A5%E5%81%9A%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.62.</span> <span class="toc-text">62. 工厂模式在游戏开发中一般用来做什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#63-%E8%A7%82%E5%AF%9F%E8%80%85%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%9C%A8%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">1.63.</span> <span class="toc-text">63. 观察者设计模式在游戏开发中有什么作用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#64-C-%E4%B8%AD%E5%A6%82%E4%BD%95%E5%9C%A8%E5%87%BD%E6%95%B0%E4%B8%AD%E8%BF%94%E5%9B%9E%E5%A4%9A%E4%B8%AA%E8%BF%94%E5%9B%9E%E5%80%BC%EF%BC%9F%EF%BC%88%E8%87%B3%E5%B0%91%E8%AF%B4%E5%87%BA3%E7%A7%8D%E6%96%B9%E6%B3%95%EF%BC%89"><span class="toc-number">1.64.</span> <span class="toc-text">64. C#中如何在函数中返回多个返回值？（至少说出3种方法）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#65-%E5%9C%A8%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD%EF%BC%8C%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E5%88%A9%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E6%A0%91%E5%8F%82%E4%B8%8E%E5%93%AA%E4%BA%9B%E5%8A%9F%E8%83%BD%E7%9A%84%E5%88%B6%E4%BD%9C%EF%BC%9F%EF%BC%88%E8%87%B3%E5%B0%91%E8%AF%B4%E5%87%BA3%E7%82%B9%EF%BC%89"><span class="toc-number">1.65.</span> <span class="toc-text">65. 在游戏开发中，我们可以利用数据结构中的树参与哪些功能的制作？（至少说出3点）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#66-%E7%88%B6%E7%B1%BB%E4%B8%AD%E5%AE%9A%E4%B9%89%E4%BA%86%E4%B8%80%E4%B8%AA%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%B1%9E%E6%80%A7%EF%BC%8C%E6%9C%89%E4%B8%A4%E4%B8%AA%E5%AD%90%E7%B1%BB%E9%83%BD%E7%BB%A7%E6%89%BF%E8%AF%A5%E7%88%B6%E7%B1%BB"><span class="toc-number">1.66.</span> <span class="toc-text">66. 父类中定义了一个静态成员属性，有两个子类都继承该父类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#67-%E6%B3%9B%E5%9E%8B%E7%88%B6%E7%B1%BB%E4%B8%AD%E5%AE%9A%E4%B9%89%E4%BA%86%E4%B8%80%E4%B8%AA%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%B1%9E%E6%80%A7%EF%BC%8C%E6%9C%89%E4%B8%A4%E4%B8%AA%E5%AD%90%E7%B1%BB%E9%83%BD%E7%BB%A7%E6%89%BF%E8%AF%A5%E6%B3%9B%E5%9E%8B%E7%88%B6%E7%B1%BB"><span class="toc-number">1.67.</span> <span class="toc-text">67. 泛型父类中定义了一个静态成员属性，有两个子类都继承该泛型父类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#68-%E4%BD%BF%E7%94%A8C-%E5%88%B6%E4%BD%9C%E6%B8%B8%E6%88%8F%E5%AD%98%E6%A1%A3%E5%8A%9F%E8%83%BD%EF%BC%8C%E8%AF%B7%E9%97%AE%E6%9C%89%E5%87%A0%E7%A7%8D%E5%81%9A%E6%B3%95%EF%BC%9F%EF%BC%88%E8%87%B3%E5%B0%91%E8%AF%B4%E5%87%BA%E4%B8%89%E7%A7%8D%EF%BC%89"><span class="toc-number">1.68.</span> <span class="toc-text">68. 使用C#制作游戏存档功能，请问有几种做法？（至少说出三种）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#69-C-%E4%B8%AD%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E5%88%B0%E7%B1%BB%E5%86%85%E9%83%A8%E7%9A%84%E7%A7%81%E6%9C%89%E6%88%90%E5%91%98%EF%BC%9F"><span class="toc-number">1.69.</span> <span class="toc-text">69. C#中是否可以通过反射获取到类内部的私有成员？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#70-%E5%9C%A8%E5%88%B6%E4%BD%9C%E6%B8%B8%E6%88%8F%E5%AD%98%E6%A1%A3%E5%8A%9F%E8%83%BD%E6%97%B6C-%E4%B8%AD%E5%8F%8D%E5%B0%84%E4%B8%BB%E8%A6%81%E5%8F%AF%E4%BB%A5%E5%8F%91%E6%8C%A5%E5%87%BA%E5%93%AA%E4%BA%9B%E4%BD%9C%E7%94%A8%EF%BC%88%E8%87%B3%E5%B0%91%E8%AF%B4%E5%87%BA%E4%B8%89%E7%82%B9%EF%BC%89"><span class="toc-number">1.70.</span> <span class="toc-text">70. 在制作游戏存档功能时C#中反射主要可以发挥出哪些作用（至少说出三点）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#71%EF%BC%88%E5%9D%91%EF%BC%89-%E8%AF%B7%E9%97%AE%E4%B8%8A%E9%9D%A2%E8%BF%99%E6%AE%B5%E4%BB%A3%E7%A0%81%E7%9A%84%E6%89%93%E5%8D%B0%E7%BB%93%E6%9E%9C%E6%98%AF%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="toc-number">1.71.</span> <span class="toc-text">71（坑）. 请问上面这段代码的打印结果是多少？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#72-%E5%9C%A8C-%E5%BD%93%E4%B8%AD%EF%BC%8C%E6%88%91%E4%BB%AC%E6%83%B3%E8%A6%81%E7%94%A8%E4%B8%80%E4%B8%AA%E5%AD%97%E5%85%B8%E5%AE%B9%E5%99%A8%E5%AD%98%E5%82%A8%E5%9C%BA%E6%99%AF%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E6%95%8C%E5%AF%B9%E5%AF%B9%E8%B1%A1%E3%80%82%E6%AF%94%E5%A6%82-%E6%80%AA%E7%89%A9%E3%80%81Boss%E3%80%81%E5%8F%AF%E8%A2%AB%E6%94%BB%E5%87%BB%E7%9A%84%E5%9C%BA%E6%99%AF%E7%89%A9%E4%BB%B6%E7%AD%89%E7%AD%89%E3%80%82%E5%BA%94%E8%AF%A5%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8"><span class="toc-number">1.72.</span> <span class="toc-text">72. 在C#当中，我们想要用一个字典容器存储场景中的所有敌对对象。比如 怪物、Boss、可被攻击的场景物件等等。应该如何存储</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#73-%E5%9C%A8C-%E4%B8%AD%EF%BC%8C%E7%BB%99%E4%BD%A0%E4%B8%80%E4%B8%AA%E6%95%B0%E5%AD%97%EF%BC%8C%E8%A1%A8%E7%A4%BA%E6%9C%89n%E7%A7%92%E8%AF%B7%E9%97%AE%E5%A6%82%E4%BD%95%E5%9C%A8%E4%B8%8D%E6%94%B9%E5%8F%98%E8%BF%99%E4%B8%AA%E6%95%B0%E5%AD%97%E7%9A%84%E5%89%8D%E6%8F%90%E4%B8%8B"><span class="toc-number">1.73.</span> <span class="toc-text">73. 在C#中，给你一个数字，表示有n秒请问如何在不改变这个数字的前提下</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#74%EF%BC%88%E5%9D%91%EF%BC%89-%E8%AF%B7%E9%97%AE%E6%89%A7%E8%A1%8C%E4%BB%A5%E4%B8%8A%E4%BB%A3%E7%A0%81%E5%90%8E%EF%BC%8CList%E4%B8%AD%E8%BF%98%E5%AD%98%E5%9C%A8%E5%93%AA%E4%BA%9B%E5%86%85%E5%AE%B9%EF%BC%9F"><span class="toc-number">1.74.</span> <span class="toc-text">74（坑）. 请问执行以上代码后，List中还存在哪些内容？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#75-%E5%81%87%E8%AE%BE%E6%B8%B8%E6%88%8F%E4%B8%AD%E6%9C%89%E4%B8%80%E4%B8%AA%E6%80%AA%E7%89%A9%E7%AE%A1%E7%90%86%E5%99%A8%E7%AE%A1%E7%90%86%E6%89%80%E6%9C%89%E6%80%AA%E7%89%A9%E3%80%82%E9%82%A3%E4%B9%88%E5%9C%A8%E5%BC%80%E5%8F%91%E6%97%B6%EF%BC%8C%E4%B8%BA%E4%BA%86%E9%81%BF%E5%85%8D%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%8C%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.75.</span> <span class="toc-text">75. 假设游戏中有一个怪物管理器管理所有怪物。那么在开发时，为了避免内存泄漏，我们需要注意什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#76-%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.76.</span> <span class="toc-text">76. 重载和重写的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#77-ArrayList%E5%92%8CList%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB"><span class="toc-number">1.77.</span> <span class="toc-text">77. ArrayList和List的主要区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#78-LinkedList-%E5%92%8CList%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.78.</span> <span class="toc-text">78. LinkedList 和List的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#79-%E8%AF%B7%E6%8F%8F%E8%BF%B0Interface%EF%BC%88%E6%8E%A5%E5%8F%A3%EF%BC%89%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E4%B8%8D%E5%90%8C"><span class="toc-number">1.79.</span> <span class="toc-text">79.请描述Interface（接口）与抽象类之间的不同</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#80-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%98%AF%E5%90%A6%E8%83%BD%E8%A2%AB%E9%87%8D%E5%86%99%EF%BC%9F%EF%BC%9F"><span class="toc-number">1.80.</span> <span class="toc-text">80. 构造函数是否能被重写？？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#81-%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%92%8C%E9%9D%9E%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.81.</span> <span class="toc-text">81. 静态成员和非静态成员的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#82-C-%E4%B8%ADref%E5%92%8Cout%E5%85%B3%E9%94%AE%E5%AD%97%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%EF%BC%9F"><span class="toc-number">1.82.</span> <span class="toc-text">82.  C#中ref和out关键字有什么区别？？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#83-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%ADstring-str-null-%E5%92%8C-string-str-%E2%80%9C%E2%80%9D-%E5%92%8Cstring-str-string-Empty%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%EF%BC%9F"><span class="toc-number">1.83.</span> <span class="toc-text">83. 字符串中string str &#x3D; null 和 string str &#x3D; “” 和string  str &#x3D; string.Empty的区别？？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#84-const%E5%92%8Creadonly-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%EF%BC%9F"><span class="toc-number">1.84.</span> <span class="toc-text">84. const和readonly 有什么区别？？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#85-String-s-new-String-%E2%80%9CXYZ%E2%80%9D-%E5%88%9B%E5%BB%BA%E4%BA%86%E5%87%A0%E4%B8%AAString-Object"><span class="toc-number">1.85.</span> <span class="toc-text">85. String s &#x3D; new String(“XYZ”);创建了几个String Object</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#86-C-%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E7%BB%A7%E6%89%BFString%E7%B1%BB%EF%BC%9F%EF%BC%9F"><span class="toc-number">1.86.</span> <span class="toc-text">86. C#是否可以继承String类？？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#87-%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E7%B1%BB%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB%EF%BC%9F%EF%BC%9F"><span class="toc-number">1.87.</span> <span class="toc-text">87. 结构体和类有何区别？？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#88-C-%E4%B8%A4%E4%B8%AA%E5%AF%B9%E5%83%8F%E5%80%BC%E7%9B%B8%E5%90%8C%EF%BC%88x-equals-y-true%EF%BC%89%EF%BC%8C%E4%BD%86%E5%8D%B4%E5%8F%AF%E6%9C%89%E4%B8%8D%E5%90%8C%E7%9A%84hashcode%EF%BC%8C%E8%BF%99%E5%8F%A5%E8%AF%9D%E5%AF%B9%E4%B8%8D%E5%AF%B9%EF%BC%9F%EF%BC%9F%EF%BC%9F"><span class="toc-number">1.88.</span> <span class="toc-text">88. C#两个对像值相同（x.equals(y) &#x3D;&#x3D; true），但却可有不同的hashcode，这句话对不对？？？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#89-%E7%94%A8%E6%9C%80%E6%9C%89%E6%95%88%E7%9A%84%E6%96%B9%E6%B3%95%E7%AE%97%E5%87%BA2%E4%B9%98%E4%BB%A58%E7%AD%89%E4%BA%8E%E5%87%A0%EF%BC%9F%EF%BC%9F%EF%BC%9F"><span class="toc-number">1.89.</span> <span class="toc-text">89. 用最有效的方法算出2乘以8等于几？？？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#90-int%EF%BC%9F%E5%92%8Cint%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%EF%BC%9F"><span class="toc-number">1.90.</span> <span class="toc-text">90. int？和int有什么区别？？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#91-C-%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84sleep-%E5%92%8Cwait-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">1.91.</span> <span class="toc-text">91. C# 语言中的sleep()和wait()有什么区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#92-C-%E5%8F%AF%E5%90%A6%E5%AF%B9%E5%86%85%E5%AD%98%E7%9B%B4%E6%8E%A5%E6%93%8D%E4%BD%9C"><span class="toc-number">1.92.</span> <span class="toc-text">92. C#可否对内存直接操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#93-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%80%81"><span class="toc-number">1.93.</span> <span class="toc-text">93.如何实现多态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#94-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E6%8B%86%E8%A3%85%E7%AE%B1"><span class="toc-number">1.94.</span> <span class="toc-text">94. 如何避免拆装箱</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#95-%E8%AF%B7%E5%88%97%E5%87%BAC-%E4%B8%AD%E5%87%A0%E7%A7%8D%E5%BE%AA%E7%8E%AF%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%8C%E5%B9%B6%E6%8C%87%E5%87%BA%E5%AE%83%E4%BB%AC%E7%9A%84%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="toc-number">1.95.</span> <span class="toc-text">95. 请列出C#中几种循环的方法，并指出它们的不同？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#96-%E6%8E%A5%E5%8F%A3%E6%98%AF%E5%90%A6%E5%8F%AF%E7%BB%A7%E6%89%BF%E6%8E%A5%E5%8F%A3%EF%BC%9F%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%98%AF%E5%90%A6%E5%8F%AF%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%EF%BC%9F%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E7%BB%A7%E6%89%BF%E5%AE%9E%E7%8E%B0%E7%B1%BB%EF%BC%9F"><span class="toc-number">1.96.</span> <span class="toc-text">96. 接口是否可继承接口？抽象类是否可实现接口？抽象类是否可以继承实现类？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#97-C-%E4%B8%AD%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AF%E4%BB%A5%E7%BB%A7%E6%89%BF%E6%8E%A5%E5%8F%A3%E5%B9%B6%E4%B8%94%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.97.</span> <span class="toc-text">97.C#中结构体为什么可以继承接口并且实现接口??</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Unity%E7%9B%B8%E5%85%B3"><span class="toc-number">2.</span> <span class="toc-text">Unity相关</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Unity%E4%B8%AD%E7%82%B9%E4%B9%98%E5%92%8C%E5%8F%89%E4%B9%98%E5%AF%B9%E4%BA%8E%E6%88%91%E4%BB%AC%E6%9D%A5%E8%AF%B4%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.1.</span> <span class="toc-text">1. Unity中点乘和叉乘对于我们来说的作用是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Unity%E4%B8%AD%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E4%B8%8B%E9%9D%A2%E5%93%AA%E4%BA%9B%E4%BB%A3%E7%A0%81%E4%BC%9A%E6%8A%A5%E9%94%99%EF%BC%9F"><span class="toc-number">2.2.</span> <span class="toc-text">2. Unity中多线程执行下面哪些代码会报错？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Application-streamingAssetsPath-%E5%92%8C-Application-persistentDataPath%E4%B8%A4%E4%B8%AA%E8%B7%AF%E5%BE%84%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB%EF%BC%9F%E5%AF%B9%E4%BA%8E%E6%88%91%E4%BB%AC%E7%9A%84%E6%84%8F%E4%B9%89%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.3.</span> <span class="toc-text">3. Application.streamingAssetsPath 和 Application.persistentDataPath两个路径有何区别？对于我们的意义是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E8%AF%B7%E7%AE%80%E8%BF%B0Unity%E4%B8%AD%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8E%9F%E7%90%86%E3%80%82"><span class="toc-number">2.4.</span> <span class="toc-text">4. 请简述Unity中协程的原理。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Unity%E5%BA%95%E5%B1%82%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86C-%E4%BB%A3%E7%A0%81"><span class="toc-number">2.5.</span> <span class="toc-text">5. Unity底层如何处理C#代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-Unity%E4%B8%AD%E5%BD%93%E4%B8%80%E4%B8%AA%E7%BB%86%E5%B0%8F%E9%AB%98%E9%80%9F%E7%89%A9%E4%BD%93%E6%92%9E%E5%87%BB%E5%8F%A6%E4%B8%80%E4%B8%AA%E8%BE%83%E5%A4%A7%E7%89%A9%E4%BD%93%E6%97%B6%E4%BC%9A%E5%87%BA%E7%8E%B0%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%EF%BC%9F%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%EF%BC%9F"><span class="toc-number">2.6.</span> <span class="toc-text">6. Unity中当一个细小高速物体撞击另一个较大物体时会出现什么情况？如何避免？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E8%AF%B7%E7%AE%80%E8%BF%B0%E4%B8%80%E4%B8%8BPrefab%EF%BC%88%E9%A2%84%E5%88%B6%E4%BD%93%EF%BC%89%E7%9A%84%E6%9C%AC%E8%B4%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.7.</span> <span class="toc-text">7. 请简述一下Prefab（预制体）的本质是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-Unity%E6%98%AF%E5%90%A6%E6%94%AF%E6%8C%81%E5%86%99%E6%88%90%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%A8%8B%E5%BA%8F%EF%BC%9F%E5%A6%82%E6%9E%9C%E6%94%AF%E6%8C%81%E7%9A%84%E8%AF%9D%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.8.</span> <span class="toc-text">8. Unity是否支持写成多线程程序？如果支持的话需要注意什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E8%AF%B7%E7%AE%80%E8%BF%B0%E4%B8%80%E4%B8%8B%E5%AF%B9%E8%B1%A1%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%8C%E5%9C%A8%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD%E6%88%91%E4%BB%AC%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E7%94%A8%E5%88%B0%E5%AE%83%EF%BC%9F"><span class="toc-number">2.9.</span> <span class="toc-text">9. 请简述一下对象池实现原理，在游戏开发中我们什么时候会用到它？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E4%BB%80%E4%B9%88%E6%98%AFDrawCall%EF%BC%9FDrawCall%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%BD%B1%E5%93%8D%E6%B8%B8%E6%88%8F%E8%BF%90%E8%A1%8C%E6%95%88%E7%8E%87%EF%BC%9F"><span class="toc-number">2.10.</span> <span class="toc-text">10 .什么是DrawCall？DrawCall为什么会影响游戏运行效率？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-transform-forward%E5%92%8CVector3-forword%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.11.</span> <span class="toc-text">11. transform.forward和Vector3.forword的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-Unity%E4%B8%AD%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%BF%87%E5%A4%9A%E5%88%9B%E5%BB%BA%E5%92%8C%E5%88%A0%E9%99%A4%E5%AF%B9%E8%B1%A1%E5%B8%A6%E6%9D%A5%E7%9A%84%E5%8D%A1%E9%A1%BF%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">2.12.</span> <span class="toc-text">12. Unity中如何解决过多创建和删除对象带来的卡顿问题？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-%E6%B8%B8%E6%88%8F%E4%B8%AD%E7%9A%84%E6%88%90%E5%B0%B1%E7%B3%BB%E7%BB%9F%EF%BC%8C%E6%88%91%E4%BB%AC%E4%B8%80%E8%88%AC%E4%BC%9A%E4%BD%BF%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%AD%E7%9A%84%E5%93%AA%E7%A7%8D%E6%A8%A1%E5%BC%8F%E6%9D%A5%E5%88%B6%E4%BD%9C%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.13.</span> <span class="toc-text">13. 游戏中的成就系统，我们一般会使用设计模式中的哪种模式来制作？为什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-%E8%AF%B7%E7%AE%80%E8%BF%B0%E7%83%AD%E6%9B%B4%E6%96%B0%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-number">2.14.</span> <span class="toc-text">14. 请简述热更新的流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-%E6%88%91%E4%BB%AC%E5%BA%94%E8%AF%A5%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96UI%EF%BC%88%E5%9F%BA%E4%BA%8EUGUI%EF%BC%89"><span class="toc-number">2.15.</span> <span class="toc-text">15. 我们应该如何优化UI（基于UGUI）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-Unity%E4%B8%AD%E7%9A%84Destroy%E5%92%8CDestroyImmediate%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.16.</span> <span class="toc-text">16. Unity中的Destroy和DestroyImmediate的区别是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%89%A7%E8%A1%8CGameObject-Instantiate%E6%97%B6%E5%8F%AF%E8%83%BD%E5%87%BA%E7%8E%B0%E6%98%8E%E6%98%BE%E7%9A%84%E5%8D%A1%E9%A1%BF%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%AF%A5%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">2.17.</span> <span class="toc-text">17. 第一次执行GameObject.Instantiate时可能出现明显的卡顿如何解决该问题？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-Unity%E4%BD%BF%E7%94%A8IL2CPP%E6%89%93%E5%8C%85%E6%97%B6%EF%BC%8C%E6%88%91%E4%BB%AC%E5%BA%94%E8%AF%A5%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88%EF%BC%9F%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%EF%BC%88%E5%8F%AF%E4%BB%A5%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E%EF%BC%89"><span class="toc-number">2.18.</span> <span class="toc-text">18. Unity使用IL2CPP打包时，我们应该注意什么？如何避免（可以举例说明）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-%E4%B8%A4%E4%B8%AA%E5%9B%9B%E5%85%83%E6%95%B0%E7%9B%B8%E4%B9%98%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F%E5%9B%9B%E5%85%83%E6%95%B0%E4%B9%98%E4%BB%A5%E5%90%91%E9%87%8F%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">2.19.</span> <span class="toc-text">19. 两个四元数相乘有什么作用？四元数乘以向量有什么作用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-%E5%9B%BE%E4%B8%AD%E7%9A%84%E5%B0%8F%E7%90%83%E6%98%AF%E5%90%A6%E8%A2%AB%E6%B8%B2%E6%9F%93%E4%BA%86%EF%BC%9F%E6%98%AF%E5%90%A6%E4%BC%9A%E4%BA%A7%E7%94%9FDrawCall%EF%BC%9F"><span class="toc-number">2.20.</span> <span class="toc-text">20. 图中的小球是否被渲染了？是否会产生DrawCall？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-%E5%9C%A8%E6%B2%A1%E6%9C%89%E4%BD%BF%E7%94%A8%E9%81%AE%E6%8C%A1%E5%89%94%E9%99%A4%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%8C%E5%9B%BE%E4%B8%ADA%E5%92%8CB%E9%83%BD%E6%98%AF%E9%BB%98%E8%AE%A4%E6%A0%87%E5%87%86%E6%9D%90%E8%B4%A8%E3%80%82%E5%9B%BE%E4%B8%AD%E7%9A%84%E5%B0%8F%E7%90%83%E6%9C%80%E7%BB%88%E6%98%AF%E5%90%A6%E4%BC%9A%E8%A2%AB%E6%B8%B2%E6%9F%93%EF%BC%8C%E6%98%AF%E5%90%A6%E4%BC%9A%E4%BA%A7%E7%94%9FDrawCall%EF%BC%9F"><span class="toc-number">2.21.</span> <span class="toc-text">21. 在没有使用遮挡剔除的情况下，图中A和B都是默认标准材质。图中的小球最终是否会被渲染，是否会产生DrawCall？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-%E5%A6%82%E6%9E%9C%E4%B8%8D%E8%80%83%E8%99%91IOS%E5%B9%B3%E5%8F%B0%EF%BC%8C%E5%8F%AA%E5%9C%A8Windows%E5%92%8CAndroid%E5%B9%B3%E5%8F%B0%E4%B8%8A%E5%8F%91%E5%B8%83%E6%B8%B8%E6%88%8F%EF%BC%8C%E5%A6%82%E4%BD%95%E5%9C%A8%E4%B8%8D%E4%BD%BF%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E7%83%AD%E6%9B%B4%E6%96%B0%E6%96%B9%E6%A1%88%E7%9A%84%E5%89%8D%E6%8F%90%E4%B8%8B%E5%AE%9E%E7%8E%B0%E7%83%AD%E6%9B%B4%E6%96%B0%E5%8A%9F%E8%83%BD"><span class="toc-number">2.22.</span> <span class="toc-text">22. 如果不考虑IOS平台，只在Windows和Android平台上发布游戏，如何在不使用第三方热更新方案的前提下实现热更新功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-Unity%E4%B8%AD%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95%E6%8E%92%E6%9F%A5Android%E4%B8%8A%E8%BF%90%E8%A1%8C%E7%9A%84%E9%A1%B9%E7%9B%AE%E9%97%AE%E9%A2%98"><span class="toc-number">2.23.</span> <span class="toc-text">23. Unity中如何调试排查Android上运行的项目问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-Unity%E5%BC%95%E6%93%8E%E4%B8%AD%E5%93%AA%E4%BA%9B%E5%8A%9F%E8%83%BD%E4%BD%BF%E7%94%A8%E4%BA%86C-%E7%9A%84%E5%8F%8D%E5%B0%84%E5%8A%9F%E8%83%BD%EF%BC%9F%E8%87%B3%E5%B0%91%E8%AF%B4%E5%87%BA%E4%B8%80%E7%82%B9"><span class="toc-number">2.24.</span> <span class="toc-text">24. Unity引擎中哪些功能使用了C#的反射功能？至少说出一点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25-Unity%E4%B8%ADAwake%E5%92%8CStart%E4%B8%A4%E4%B8%AA%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0%EF%BC%8C%E5%88%86%E5%88%AB%E5%9C%A8%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%A2%AB%E8%B0%83%E7%94%A8%EF%BC%9F"><span class="toc-number">2.25.</span> <span class="toc-text">25 . Unity中Awake和Start两个生命周期函数，分别在什么时候被调用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26-Unity%E5%9C%BA%E6%99%AF%E4%B8%8A%E6%9C%89%E5%A4%9A%E4%B8%AA%E5%AF%B9%E8%B1%A1%EF%BC%8C%E9%83%BD%E5%88%86%E5%88%AB%E6%8C%82%E8%BD%BD%E4%BA%86n%E4%B8%AA%E8%84%9A%E6%9C%AC%E3%80%82%E6%88%91%E4%BB%AC%E5%A6%82%E4%BD%95%E6%8E%A7%E5%88%B6%E4%B8%8D%E5%90%8C%E8%84%9A%E6%9C%AC%E9%97%B4%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0Awake%E7%9A%84%E6%89%A7%E8%A1%8C%E5%85%88%E5%90%8E%E9%A1%BA%E5%BA%8F%EF%BC%9F"><span class="toc-number">2.26.</span> <span class="toc-text">26. Unity场景上有多个对象，都分别挂载了n个脚本。我们如何控制不同脚本间生命周期函数Awake的执行先后顺序？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27-%E6%83%B3%E8%A6%81%E5%9C%A8Unity%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%8C%87%E9%92%88%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81%E8%BF%9B%E8%A1%8C%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C%EF%BC%9F"><span class="toc-number">2.27.</span> <span class="toc-text">27. 想要在Unity中使用指针我们需要进行哪些操作？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28-Unity%E4%B8%AD%E7%9A%84%E5%8D%8F%E5%90%8C%E7%A8%8B%E5%BA%8F%E4%B8%ADyield-return%E4%B8%8D%E5%90%8C%E7%9A%84%E5%86%85%E5%AE%B9%EF%BC%8C%E4%BB%A3%E8%A1%A8%E7%9A%84%E5%90%AB%E4%B9%89%E4%B8%8D%E5%90%8C%E8%AF%B7%E8%AF%B4%E6%98%8E%E4%B8%8B%E9%9D%A2%E8%BF%99%E4%BA%9Byield-return%E7%9A%84%E5%90%AB%E4%B9%89"><span class="toc-number">2.28.</span> <span class="toc-text">28. Unity中的协同程序中yield return不同的内容，代表的含义不同请说明下面这些yield return的含义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#29-%E4%BD%BF%E7%94%A8Unity%E5%8D%8F%E5%90%8C%E7%A8%8B%E5%BA%8F%E8%BF%9B%E8%A1%8C%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD%E6%97%B6%EF%BC%8C%E5%BA%95%E5%B1%82%E6%98%AF%E5%90%A6%E4%BC%9A%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="toc-number">2.29.</span> <span class="toc-text">29.使用Unity协同程序进行异步加载时，底层是否会使用多线程？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#30-Unity%E4%B8%AD%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E8%B5%84%E6%BA%90%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">2.30.</span> <span class="toc-text">30. Unity中动态加载资源的方式有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#31-Unity%E4%B8%AD%E7%9A%84%E5%85%89%E7%85%A7%E8%B4%B4%E5%9B%BE%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.31.</span> <span class="toc-text">31. Unity中的光照贴图的作用是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32-Unity%E5%9C%BA%E6%99%AF%E4%B8%AD%E6%9C%89%E4%B8%A4%E4%B8%AA%E7%82%B9%E8%BF%9E%E6%88%90%E4%BA%86%E4%B8%80%E6%9D%A1%E7%BA%BF%EF%BC%8C%E6%83%B3%E8%A6%81%E6%97%8B%E8%BD%AC%E8%BF%99%E6%9D%A1%E7%BA%BF%EF%BC%8C%E5%BA%94%E8%AF%A5%E6%80%8E%E4%B9%88%E5%81%9A%EF%BC%9F"><span class="toc-number">2.32.</span> <span class="toc-text">32.Unity场景中有两个点连成了一条线，想要旋转这条线，应该怎么做？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#33-LOD%EF%BC%88%E5%A4%9A%E7%BB%86%E8%8A%82%E5%B1%82%E6%AC%A1%EF%BC%89%E5%92%8C-MipMap%EF%BC%88%E7%BA%B9%E7%90%86%E5%9B%BE%EF%BC%89%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.33.</span> <span class="toc-text">33. LOD（多细节层次）和 MipMap（纹理图）的作用是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#34-%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD%EF%BC%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8C%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%BA%A4%E4%BA%92%E6%95%B0%E6%8D%AE%EF%BC%8C%E7%A8%8B%E5%BA%8F%E4%B8%AD%E5%B8%B8%E7%94%A8%E6%96%B9%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.34.</span> <span class="toc-text">34. 游戏开发中，客户端和服务端交互数据，程序中常用方式是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#35-Unity%E4%B8%AD%E5%A6%82%E4%BD%95%E5%B0%86%E6%9C%AC%E5%9C%B0%E5%9D%90%E6%A0%87%E8%BD%AC%E4%B8%BA%E4%B8%96%E7%95%8C%E5%9D%90%E6%A0%87%EF%BC%9F"><span class="toc-number">2.35.</span> <span class="toc-text">35. Unity中如何将本地坐标转为世界坐标？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#36-Unity%E4%B8%AD%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E5%87%BA%E4%B8%A4%E4%B8%AA%E5%90%91%E9%87%8F%E4%B9%8B%E9%97%B4%E7%9A%84%E5%A4%B9%E8%A7%92%EF%BC%8C%E8%AF%B7%E8%AF%B4%E5%87%BA%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">2.36.</span> <span class="toc-text">36.Unity中如何计算出两个向量之间的夹角，请说出两种方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#37-%E8%AF%B7%E5%86%99%E5%87%BAUGUI%E4%B8%AD%E4%B8%A4%E7%A7%8D%E5%A4%84%E7%90%86%E5%BC%82%E5%BD%A2%E6%8C%89%E9%92%AE%E7%9A%84%E5%85%B7%E4%BD%93%E6%96%B9%E6%B3%95"><span class="toc-number">2.37.</span> <span class="toc-text">37. 请写出UGUI中两种处理异形按钮的具体方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#38-%E8%AF%B7%E8%AF%B4%E5%87%BAUnity%E4%B8%AD%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%8C%E8%87%B3%E5%B0%91%E8%AF%B4%E5%87%BA5%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">2.38.</span> <span class="toc-text">38. 请说出Unity中如何进行数据持久化，至少说出5种方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#39-%E5%9C%A8Unity%E4%B8%AD%E5%A6%82%E4%BD%95%E6%8E%A7%E5%88%B6%E6%B8%B2%E6%9F%93%E4%BC%98%E5%85%88%E7%BA%A7%EF%BC%9F%EF%BC%88%E8%B0%81%E5%85%88%E6%B8%B2%E6%9F%93%E8%B0%81%E5%90%8E%E6%B8%B2%E6%9F%93%EF%BC%8C%E5%88%86%E6%83%85%E5%86%B5%E5%9B%9E%E7%AD%94%EF%BC%89"><span class="toc-number">2.39.</span> <span class="toc-text">39. 在Unity中如何控制渲染优先级？（谁先渲染谁后渲染，分情况回答）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#40-Unity%E4%B8%AD%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA2D%E7%9F%A9%E5%BD%A2%E6%98%AF%E5%90%A6%E7%9B%B8%E4%BA%A4%EF%BC%8C%E6%9C%89%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9F%EF%BC%88%E8%AF%B7%E8%87%B3%E5%B0%91%E8%AF%B4%E5%87%BA%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%89"><span class="toc-number">2.40.</span> <span class="toc-text">40. Unity中判断两个2D矩形是否相交，有几种方式？（请至少说出两种方式）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#41-Unity%E4%B8%AD%E6%83%B3%E8%A6%81%E5%88%B6%E4%BD%9C%E8%A7%92%E8%89%B2%E7%9A%84%E8%BF%9E%E6%8B%9B%E5%8A%9F%E8%83%BD%EF%BC%8C%E5%9C%A8%E5%88%B6%E4%BD%9C%E7%8A%B6%E6%80%81%E6%9C%BA%E6%97%B6%E6%88%91%E4%BB%AC%E4%B8%80%E8%88%AC%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%EF%BC%9F"><span class="toc-number">2.41.</span> <span class="toc-text">41. Unity中想要制作角色的连招功能，在制作状态机时我们一般如何处理？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#42-Unity%E4%B8%AD%E5%A6%82%E6%9E%9C%E6%83%B3%E8%A6%81%E5%9C%A8%E5%8A%A8%E4%BD%9C%E7%9A%84%E6%9F%90%E4%B8%80%E6%97%B6%E5%88%BB%E8%BF%9B%E8%A1%8C%E4%BC%A4%E5%AE%B3%E6%A3%80%E6%B5%8B%EF%BC%8C%E6%88%91%E4%BB%AC%E5%BA%94%E8%AF%A5%E6%80%8E%E4%B9%88%E5%81%9A%EF%BC%9F%EF%BC%88%E8%AF%B7%E8%AF%B4%E5%87%BA%E4%B8%A4%E7%A7%8D%E5%81%9A%E6%B3%95%EF%BC%89"><span class="toc-number">2.42.</span> <span class="toc-text">42. Unity中如果想要在动作的某一时刻进行伤害检测，我们应该怎么做？（请说出两种做法）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#43-Unity%E4%B8%AD%E6%83%B3%E8%A6%81%E5%88%B6%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%AF%BB%E8%B7%AF%E9%80%BB%E8%BE%91%EF%BC%8C%E6%88%91%E4%BB%AC%E5%BA%94%E8%AF%A5%E6%80%8E%E4%B9%88%E5%81%9A%EF%BC%9F%EF%BC%88%E8%AF%B7%E8%87%B3%E5%B0%91%E8%AF%B4%E5%87%BA%E4%B8%A4%E7%A7%8D%E5%81%9A%E6%B3%95%EF%BC%89"><span class="toc-number">2.43.</span> <span class="toc-text">43. Unity中想要制作自动寻路逻辑，我们应该怎么做？（请至少说出两种做法）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#44-%E6%B8%B8%E6%88%8F%E7%BC%96%E8%BE%91%E5%99%A8%EF%BC%88%E6%AF%94%E5%A6%82-%E8%A7%92%E8%89%B2%E7%BC%96%E8%BE%91%E5%99%A8%E3%80%81%E5%85%B3%E5%8D%A1%E7%BC%96%E8%BE%91%E5%99%A8%E3%80%81%E5%9C%B0%E5%9B%BE%E7%BC%96%E8%BE%91%E5%99%A8%E7%AD%89%E5%B7%A5%E5%85%B7%EF%BC%89%E7%9A%84%E6%9C%AC%E8%B4%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.44.</span> <span class="toc-text">44. 游戏编辑器（比如 角色编辑器、关卡编辑器、地图编辑器等工具）的本质是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#45-Unity%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%9A%84%E6%98%AF%E5%B7%A6%E6%89%8B%E8%BF%98%E6%98%AF%E5%8F%B3%E6%89%8B%E5%9D%90%E6%A0%87%E7%B3%BB%EF%BC%9F%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.45.</span> <span class="toc-text">45.Unity中使用的是左手还是右手坐标系？我们需要注意什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#46-Unity%E4%B8%AD%E9%BC%A0%E6%A0%87%E3%80%81%E9%94%AE%E7%9B%98%E3%80%81%E8%A7%A6%E5%B1%8F%E3%80%81%E6%89%8B%E6%9F%84%E7%AD%89%E8%BE%93%E5%85%A5%E4%BA%8B%E4%BB%B6%E4%BC%9A%E5%9C%A8Update-%E4%B9%8B%E5%89%8D%E3%80%81%E8%BF%98%E6%98%AF%E4%B9%8B%E5%90%8E%E3%80%81%E8%BF%98%E6%98%AF%E5%90%8C%E6%97%B6%E6%89%A7%E8%A1%8C%EF%BC%9F"><span class="toc-number">2.46.</span> <span class="toc-text">46. Unity中鼠标、键盘、触屏、手柄等输入事件会在Update 之前、还是之后、还是同时执行？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#47-Unity%E4%B8%AD%E5%9C%BA%E6%99%AF%E4%B8%AD%E4%B8%80%E4%B8%AA%E5%A4%84%E4%BA%8E%E6%BF%80%E6%B4%BB%E7%8A%B6%E6%80%81%E7%9A%84%E7%89%A9%E4%BD%93-%E5%9C%BA%E6%99%AF%E4%B8%8A%E5%8F%AA%E6%9C%89%E8%BF%99%E4%B8%80%E4%B8%AA%E7%89%A9%E4%BD%93-%EF%BC%8C%E4%B8%8D%E8%83%BD%E8%A2%AB%E6%91%84%E5%83%8F%E6%9C%BA%E6%B8%B2%E6%9F%93%E5%87%BA%E6%9D%A5%EF%BC%8C%E5%8F%AF%E8%83%BD%E6%9C%89%E5%87%A0%E7%A7%8D%E6%83%85%E5%86%B5%EF%BC%9F%EF%BC%88%E8%87%B3%E5%B0%91%E8%AF%B4%E5%87%BA3%E7%A7%8D%E5%8F%AF%E8%83%BD%E7%9A%84%E6%83%85%E5%86%B5%EF%BC%89"><span class="toc-number">2.47.</span> <span class="toc-text">47. Unity中场景中一个处于激活状态的物体(场景上只有这一个物体)，不能被摄像机渲染出来，可能有几种情况？（至少说出3种可能的情况）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#48-Unity%E5%88%B6%E4%BD%9C%E7%89%A9%E7%90%86%E6%B8%B8%E6%88%8F%E7%9B%B8%E5%85%B3%E5%8A%9F%E8%83%BD%E6%97%B6%EF%BC%8C%E6%88%91%E4%BB%AC%E9%87%87%E7%94%A8%E5%93%AA%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%A4%84%E7%90%86%E4%BD%8D%E7%A7%BB%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.48.</span> <span class="toc-text">48. Unity制作物理游戏相关功能时，我们采用哪种方式处理位移？为什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#49-Unity%E7%83%AD%E6%9B%B4%E6%96%B0%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B8%AD%EF%BC%8CLua%E5%92%8CILRuntime%E6%96%B9%E6%A1%88%E7%9A%84%E6%9C%AC%E8%B4%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.49.</span> <span class="toc-text">49. Unity热更新解决方案中，Lua和ILRuntime方案的本质是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#50-%E8%AF%B7%E8%A7%A3%E9%87%8AUnity%E4%B8%AD%E7%9A%84Prefab%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%AE%83%E5%9C%A8%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.50.</span> <span class="toc-text">50. 请解释Unity中的Prefab是什么，以及它在游戏开发中的作用是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#51-CPU%E5%92%8CGPU%E4%BB%96%E4%BB%AC%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%BB%96%E4%BB%AC%E4%B8%BB%E8%A6%81%E5%AE%8C%E6%88%90%E4%BB%80%E4%B9%88%E5%B7%A5%E4%BD%9C"><span class="toc-number">2.51.</span> <span class="toc-text">51. CPU和GPU他们分别是什么？他们主要完成什么工作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#52-Unity%E4%B8%AD%E7%9A%84Lerp%E5%92%8CSlerp%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.52.</span> <span class="toc-text">52. Unity中的Lerp和Slerp分别是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#53-Unity%E5%BA%95%E5%B1%82%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E8%BF%98%E6%98%AF%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.53.</span> <span class="toc-text">53. Unity底层是单线程还是多线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#54-%E5%A6%82%E4%BD%95%E5%9C%A8Unity%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%A4%9A%E8%AF%AD%E8%A8%80%E6%94%AF%E6%8C%81%EF%BC%9F%EF%BC%88%E4%B8%8D%E5%90%8C%E5%9B%BD%E5%AE%B6%E7%9A%84%E4%BA%BA%EF%BC%8C%E7%9C%8B%E5%88%B0%E7%9A%84%E6%B8%B8%E6%88%8F%E5%86%85%E7%9A%84%E8%AF%AD%E8%A8%80%E6%98%AF%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%EF%BC%89"><span class="toc-number">2.54.</span> <span class="toc-text">54. 如何在Unity中实现多语言支持？（不同国家的人，看到的游戏内的语言是不一样的）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#55-%E5%9C%A8Unity%E4%B8%AD%EF%BC%8C%E6%9C%89%E6%97%B6%E5%9C%A8%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%89%A7%E8%A1%8CGameObject-Instantiate%E7%9A%84%E6%97%B6%E5%80%99%E6%9C%89%E6%98%8E%E6%98%BE%E5%8D%A1%E9%A1%BF%EF%BC%8C%E8%AF%A5%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-number">2.55.</span> <span class="toc-text">55. 在Unity中，有时在第一次执行GameObject.Instantiate的时候有明显卡顿，该怎么解决？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#56-%E5%9C%A8Unity%E4%B8%AD%EF%BC%8C%E6%9C%89%E6%97%B6%E5%9C%A8%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%89%A7%E8%A1%8CGameObject-Instantiate%E7%9A%84%E6%97%B6%E5%80%99%E6%9C%89%E6%98%8E%E6%98%BE%E5%8D%A1%E9%A1%BF%EF%BC%8C%E8%AF%A5%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-number">2.56.</span> <span class="toc-text">56. 在Unity中，有时在第一次执行GameObject.Instantiate的时候有明显卡顿，该怎么解决？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#57-%E5%9C%A8Unity%E4%B8%ADAssetBundle%E7%9A%84%E5%8E%8B%E7%BC%A9%E6%96%B9%E5%BC%8F%E6%9C%89%E4%B8%8D%E5%8E%8B%E7%BC%A9%E3%80%81LZMA%E3%80%81LZ4%E4%B8%89%E7%A7%8D%EF%BC%8C%E8%AF%B7%E9%97%AELZMA%E5%92%8CLZ4%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.57.</span> <span class="toc-text">57. 在Unity中AssetBundle的压缩方式有不压缩、LZMA、LZ4三种，请问LZMA和LZ4有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#58-Unity%E4%B8%ADDrawCall%E3%80%81Batches%E3%80%81SetPass-Calls%E7%9A%84%E6%84%8F%E6%80%9D%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">2.58.</span> <span class="toc-text">58. Unity中DrawCall、Batches、SetPass Calls的意思是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#59-Unity%E4%B8%AD%E6%91%84%E5%83%8F%E6%9C%BA%E7%BB%84%E4%BB%B6%E4%B8%AD%E7%9A%84%E6%8A%95%E5%BD%B1-Projection-%E5%8F%82%E6%95%B0%E5%85%B6%E4%B8%AD%E7%9A%84%E4%B8%A4%E4%B8%AA%E9%80%89%E9%A1%B9"><span class="toc-number">2.59.</span> <span class="toc-text">59. Unity中摄像机组件中的投影(Projection)参数其中的两个选项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#60-FSM%E5%92%8CBT%E6%8C%87%E4%BB%80%E4%B9%88%EF%BC%9F%E4%BB%96%E4%BB%AC%E6%98%AF%E7%94%A8%E6%9D%A5%E5%A4%84%E7%90%86%E4%BB%80%E4%B9%88%E7%9A%84%EF%BC%9F"><span class="toc-number">2.60.</span> <span class="toc-text">60. FSM和BT指什么？他们是用来处理什么的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#61-10000%E4%B8%AAmonobehavior%EF%BC%8C%E6%AF%8F%E4%B8%AA%E5%90%84%E8%87%AA%E6%89%A7%E8%A1%8Cupdate%EF%BC%8C%E5%92%8C%E6%94%BE%E5%88%B0%E4%B8%80%E4%B8%AAupdate%E9%87%8C%E6%89%A7%E8%A1%8C%EF%BC%8C%E5%93%AA%E4%B8%AA%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.61.</span> <span class="toc-text">61.10000个monobehavior，每个各自执行update，和放到一个update里执行，哪个效率更高？为什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#62-%E6%88%91%E4%BB%AC%E5%9C%A8%E7%BC%96%E5%86%99%E4%BB%A3%E7%A0%81%E6%97%B6%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E5%B8%B8%E7%94%A8%E7%9A%84%E4%BC%98%E5%8C%96%E4%BB%A3%E7%A0%81%E6%80%A7%E8%83%BD%E7%9A%84%E6%89%8B%E6%AE%B5%EF%BC%9F%E8%87%B3%E5%B0%91%E8%AF%B4%E5%87%BA3%E7%82%B9"><span class="toc-number">2.62.</span> <span class="toc-text">62. 我们在编写代码时，有什么常用的优化代码性能的手段？至少说出3点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#63-OpenGL%E5%92%8CDX%E7%9A%84%E6%9C%80%E5%A4%A7%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.63.</span> <span class="toc-text">63. OpenGL和DX的最大区别是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#64-Unity%E5%B7%A5%E7%A8%8B%E6%96%87%E4%BB%B6%E4%B8%AD%EF%BC%8Cmeta%E5%90%8E%E7%BC%80%E7%9A%84%E6%96%87%E4%BB%B6%E4%B8%AD%E4%B8%BB%E8%A6%81%E5%AD%98%E4%BA%86%E4%BB%80%E4%B9%88%E4%BF%A1%E6%81%AF%EF%BC%9F%EF%BC%88%E6%9C%80%E5%B0%91%E8%AF%B4%E5%87%BA2%E7%82%B9%EF%BC%89"><span class="toc-number">2.64.</span> <span class="toc-text">64. Unity工程文件中，meta后缀的文件中主要存了什么信息？（最少说出2点）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#65-%E4%B8%8D%E5%90%8C%E5%90%8E%E7%BC%80%E7%9A%84%E5%90%84%E7%A7%8D%E6%96%87%E4%BB%B6%E7%9A%84%E6%9C%AC%E8%B4%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.65.</span> <span class="toc-text">65. 不同后缀的各种文件的本质是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#66-UnityWebRequest%E5%8F%AF%E4%BB%A5%E7%94%A8%E6%9D%A5%E5%81%9A%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.66.</span> <span class="toc-text">66. UnityWebRequest可以用来做什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#67-%E5%A6%82%E4%BD%95%E5%9C%A8Unity%E4%B8%AD%E8%BF%9B%E8%A1%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E4%BB%A5%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD%EF%BC%9F%EF%BC%88%E8%87%B3%E5%B0%91%E8%AF%B4%E5%87%BA3%E7%82%B9%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E5%86%85%E5%AE%B9%EF%BC%89"><span class="toc-number">2.67.</span> <span class="toc-text">67. 如何在Unity中进行多线程编程以提高性能？（至少说出3点可以使用多线程提高性能的内容）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#68-%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E5%AE%8C%E6%88%90%E5%90%8E1-%E6%B8%B8%E6%88%8F%E8%BF%90%E8%A1%8C%E5%8D%A1%E9%A1%BF%E3%80%81%E8%AE%BE%E5%A4%87%E5%8F%91%E7%83%AD%E4%B8%80%E8%88%AC%E5%BE%80%E5%93%AA%E4%B8%AA%E5%A4%A7%E6%96%B9%E5%90%91%E8%BF%9B%E8%A1%8C%E6%8E%92%E6%9F%A5%EF%BC%9F"><span class="toc-number">2.68.</span> <span class="toc-text">68. 游戏开发完成后1.游戏运行卡顿、设备发热一般往哪个大方向进行排查？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#69-%E6%B8%B8%E6%88%8F%E9%A1%B9%E7%9B%AE%E4%B8%AD%EF%BC%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E4%B8%BB%E8%A6%81%E5%8D%A0%E5%86%85%E5%AD%98%E7%9A%84%E5%86%85%E5%AE%B9%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%EF%BC%88%E8%87%B3%E5%B0%91%E8%AF%B4%E5%87%BA5%E7%82%B9%EF%BC%89"><span class="toc-number">2.69.</span> <span class="toc-text">69. 游戏项目中，运行时主要占内存的内容有哪些？（至少说出5点）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#70-%E6%B8%B8%E6%88%8F%E9%A1%B9%E7%9B%AE%E4%B8%AD%EF%BC%8C%E4%B8%BB%E8%A6%81%E6%B6%88%E8%80%97%E6%80%A7%E8%83%BD%E7%9A%84%E5%86%85%E5%AE%B9%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%EF%BC%88%E8%87%B3%E5%B0%91%E8%AF%B4%E5%87%BA3%E7%82%B9%EF%BC%89"><span class="toc-number">2.70.</span> <span class="toc-text">70. 游戏项目中，主要消耗性能的内容有哪些？（至少说出3点）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#71-%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E4%B8%AD%EF%BC%8C%E6%9C%89%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E7%95%8C%E9%9D%A2%EF%BC%8C%E8%BF%99%E4%BA%9B%E6%95%B0%E6%8D%AE%E6%98%AF%E7%94%B1%E6%9C%80%E8%BF%911000%E5%9C%BA%E6%88%98%E6%96%97%E8%AE%A1%E7%AE%97%E5%87%BA%E6%9D%A5%E7%9A%84%E5%B9%B3%E5%9D%87%E6%95%B0%E6%8D%AE%E3%80%82%E4%BD%A0%E8%AE%A4%E4%B8%BA%E4%BB%A5%E4%B8%8B%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E5%90%88%E7%90%86%E5%90%97%EF%BC%9F%E5%A6%82%E6%9E%9C%E4%B8%8D%E5%90%88%E7%90%86%EF%BC%8C%E5%BA%94%E8%AF%A5%E5%A6%82%E4%BD%95%E6%94%B9%E8%BF%9B%EF%BC%9F"><span class="toc-number">2.71.</span> <span class="toc-text">71. 网络游戏中，有一个数据统计界面，这些数据是由最近1000场战斗计算出来的平均数据。你认为以下处理方式合理吗？如果不合理，应该如何改进？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#72-%E5%A6%82%E6%9E%9C%E5%9C%A8Unity%E5%BD%93%E4%B8%AD%E5%88%B6%E4%BD%9CFPS%E6%B8%B8%E6%88%8F%EF%BC%8C%E5%A6%82%E4%BD%95%E6%A8%A1%E6%8B%9F%E6%9E%AA%E6%A2%B0%E5%BC%80%E6%9E%AA%E6%97%B6%E7%9A%84%E5%90%8E%E5%9D%90%E5%8A%9B"><span class="toc-number">2.72.</span> <span class="toc-text">72.  如果在Unity当中制作FPS游戏，如何模拟枪械开枪时的后坐力</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#73-Unity%E5%BD%93%E4%B8%AD%E5%AD%98%E5%9C%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%97%B6%EF%BC%8C%E7%BB%A7%E6%89%BFMonoBehaviour%E7%9A%84%E8%84%9A%E6%9C%AC%E6%98%AF%E5%90%A6%E6%9C%89%E5%BF%85%E8%A6%81%E5%AF%B9%E5%85%B6%E4%B8%AD%E5%86%85%E5%AE%B9%E5%8A%A0%E9%94%81%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.73.</span> <span class="toc-text">73. Unity当中存在多线程时，继承MonoBehaviour的脚本是否有必要对其中内容加锁？为什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#74-%E6%88%91%E4%BB%AC%E5%9C%A8Unity%E4%B8%AD%E8%BF%9B%E8%A1%8C%E4%B8%80%E4%BA%9B%E5%A4%8D%E6%9D%82%E9%80%BB%E8%BE%91%E5%A4%84%E7%90%86%E6%97%B6%EF%BC%8C%E6%AF%94%E5%A6%82%E7%BD%91%E8%B7%AF%E9%80%9A%E8%AE%AF%E3%80%81%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95%E3%80%82%E5%BE%80%E5%BE%80%E4%BC%9A%E5%BC%80%E5%90%AF%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%BF%9B%E8%A1%8C%E5%A4%84%E7%90%86%E3%80%82%E6%88%91%E4%BB%AC%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E8%83%BD%E5%A4%9F%E5%92%8CUnity%E4%B8%BB%E7%BA%BF%E7%A8%8B%E8%BF%9B%E8%A1%8C%E6%AD%A3%E5%B8%B8%E4%BA%A4%E4%BA%92%EF%BC%9F%EF%BC%88%E8%AF%B7%E8%87%B3%E5%B0%91%E8%AF%B4%E5%87%BA1%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%89"><span class="toc-number">2.74.</span> <span class="toc-text">74. 我们在Unity中进行一些复杂逻辑处理时，比如网路通讯、寻路算法。往往会开启多线程进行处理。我们如何保证数据能够和Unity主线程进行正常交互？（请至少说出1种方式）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#75-Unity%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84OnEnable%E5%92%8CStart%EF%BC%8C%E6%88%91%E4%BB%AC%E5%9C%A8%E4%BD%BF%E7%94%A8%E6%97%B6%E5%BA%94%E8%AF%A5%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%EF%BC%9F%E5%8F%AF%E4%BB%A5%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E%E3%80%82"><span class="toc-number">2.75.</span> <span class="toc-text">75.Unity生命周期函数中的OnEnable和Start，我们在使用时应该如何选择？可以举例说明。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#76-FixUpdate%E9%80%82%E5%90%88%E5%86%99%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88"><span class="toc-number">2.76.</span> <span class="toc-text">76.FixUpdate适合写哪些操作？为什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#77-Assetbunle%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F%EF%BC%9F"><span class="toc-number">2.77.</span> <span class="toc-text">77. Assetbunle的优缺点？？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#78-animator%E6%98%AF%E4%BB%80%E4%B9%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9Fanimator%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E8%9C%98%E8%9B%9B%E7%BD%91%E6%83%85%E5%86%B5%EF%BC%9F%EF%BC%9F"><span class="toc-number">2.78.</span> <span class="toc-text">78. animator是什么数据结构？animator如何优化蜘蛛网情况？？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Shader%E7%9B%B8%E5%85%B3"><span class="toc-number">3.</span> <span class="toc-text">Shader相关</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8BUnity%E4%B8%AD%E7%9A%84%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%EF%BC%88Rendering-Pipeline%EF%BC%89%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%AE%83%EF%BC%8C%E5%B9%B6%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E%E5%AE%83%E5%9C%A8%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E3%80%82"><span class="toc-number">3.1.</span> <span class="toc-text">1. 解释一下Unity中的渲染管线（Rendering Pipeline）是什么，如何使用它，并举例说明它在游戏开发中的应用场景。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%B8%AD%E7%9A%84%E5%87%A0%E4%BD%95%E9%98%B6%E6%AE%B5%E6%98%AF%E7%94%B1CPU%E4%B8%BB%E5%AF%BC%E8%BF%98%E6%98%AFGPU%E4%B8%BB%E5%AF%BC%EF%BC%9F%E8%AF%A5%E9%98%B6%E6%AE%B5%E4%B8%BB%E8%A6%81%E6%98%AF%E5%9C%A8%E5%81%9A%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">3.2.</span> <span class="toc-text">2. 渲染管线中的几何阶段是由CPU主导还是GPU主导？该阶段主要是在做什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E9%BD%90%E6%AC%A1%E5%9D%90%E6%A0%87%E6%98%AF%E4%BB%80%E4%B9%88-%E5%AF%B9%E4%BA%8E%E6%88%91%E4%BB%AC%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">3.3.</span> <span class="toc-text">3.齐次坐标是什么?对于我们有什么作用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Shader%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%9D%90%E6%A0%87%E7%A9%BA%E9%97%B4%E5%8F%98%E6%8D%A2%EF%BC%8C%E4%B8%BB%E8%A6%81%E6%98%AF%E5%9C%A8%E5%93%AA%E5%87%A0%E4%B8%AA%E7%A9%BA%E9%97%B4%E4%B8%AD%E8%BF%9B%E8%A1%8C%E5%8F%98%E6%8D%A2%EF%BC%9F%E5%8F%98%E6%8D%A2%E9%A1%BA%E5%BA%8F%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">3.4.</span> <span class="toc-text">4. Shader开发中的坐标空间变换，主要是在哪几个空间中进行变换？变换顺序是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Shader%E5%BD%93%E4%B8%AD%E7%9A%84%E9%A1%B6%E7%82%B9%E5%92%8C%E7%89%87%E5%85%83%E7%9D%80%E8%89%B2%E5%99%A8%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">3.5.</span> <span class="toc-text">5. Shader当中的顶点和片元着色器有什么作用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-Unity-Shader%E4%B8%AD%EF%BC%8C%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95%E6%98%AF%E5%9C%A8%E5%81%9A%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">3.6.</span> <span class="toc-text">6. Unity Shader中，深度测试是在做什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-Unity-Shader%E4%B8%AD%E6%9F%90%E7%89%87%E5%85%83%E9%80%9A%E8%BF%87%E4%BA%86%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95%EF%BC%8C%E4%BD%86%E6%98%AF%E6%B2%A1%E6%9C%89%E5%BC%80%E5%90%AF%E6%B7%B1%E5%BA%A6%E5%86%99%E5%85%A5%EF%BC%8C%E8%AF%A5%E7%89%87%E5%85%83%E7%9A%84%E9%A2%9C%E8%89%B2%E4%BF%A1%E6%81%AF%E6%98%AF%E5%90%A6%E5%86%99%E5%85%A5%E5%88%B0%E9%A2%9C%E8%89%B2%E7%BC%93%E5%86%B2%E5%8C%BA%EF%BC%9F"><span class="toc-number">3.7.</span> <span class="toc-text">7. Unity Shader中某片元通过了深度测试，但是没有开启深度写入，该片元的颜色信息是否写入到颜色缓冲区？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-Shader%E5%BD%93%E4%B8%AD%E7%9A%84Blend%E6%B8%B2%E6%9F%93%E5%91%BD%E4%BB%A4%E4%B8%BB%E8%A6%81%E7%94%A8%E6%9D%A5%E5%B9%B2%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">3.8.</span> <span class="toc-text">8. Shader当中的Blend渲染命令主要用来干什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-Shader%E5%BD%93%E4%B8%AD%E7%9A%84Blend%E6%B8%B2%E6%9F%93%E5%91%BD%E4%BB%A4%E5%90%8E%E9%9D%A2%E8%B7%9F%E7%9A%84%E5%8F%82%E6%95%B0%E6%98%AF%E7%94%A8%E6%9D%A5%E5%B9%B2%E5%98%9B%E7%9A%84%EF%BC%9F"><span class="toc-number">3.9.</span> <span class="toc-text">9. Shader当中的Blend渲染命令后面跟的参数是用来干嘛的？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Lua%E7%9B%B8%E5%85%B3"><span class="toc-number">4.</span> <span class="toc-text">Lua相关</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Lua%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%EF%BC%9F"><span class="toc-number">4.1.</span> <span class="toc-text">1. Lua如何实现面向对象的三大特性？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%AF%B7%E8%AF%B4%E5%87%BALua%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%88%E8%87%B3%E5%B0%91%E8%AF%B4%E5%87%BA6%E7%A7%8D%EF%BC%89"><span class="toc-number">4.2.</span> <span class="toc-text">2. 请说出Lua中常用的数据类型（至少说出6种）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Lua%E4%B8%ADpairs%E5%92%8Cipairs%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.3.</span> <span class="toc-text">3. Lua中pairs和ipairs的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Lua%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E5%85%83%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E8%87%B3%E5%B0%91%E8%AF%B4%E5%87%BA3%E4%B8%AA%E5%85%83%E6%96%B9%E6%B3%95"><span class="toc-number">4.4.</span> <span class="toc-text">4. Lua中常用的元方法有哪些？至少说出3个元方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Lua%E4%B8%AD%E5%85%83%E8%A1%A8%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">4.5.</span> <span class="toc-text">5. Lua中元表的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-Lua%E4%B8%AD-index%E5%92%8C-newindex%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8"><span class="toc-number">4.6.</span> <span class="toc-text">6. Lua中__ index和__ newindex有什么作用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3"><span class="toc-number">5.</span> <span class="toc-text">网络相关</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD%EF%BC%8C%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E6%95%B0%E6%8D%AE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">5.1.</span> <span class="toc-text">1. 网络游戏开发中，网络传输数据的基本流程是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E4%B8%AD%E5%88%86%E5%8C%85%E9%BB%8F%E5%8C%85%E6%8C%87%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%88%91%E4%BB%AC%E5%BA%94%E8%AF%A5%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%BF%99%E4%BA%9B%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">5.2.</span> <span class="toc-text">2. 网络通讯中分包黏包指的是什么？我们应该如何解决这些问题？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-TCP%E5%92%8CUDP%E9%80%9A%E8%AE%AF%E6%9C%80%E5%A4%A7%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">5.3.</span> <span class="toc-text">3. TCP和UDP通讯最大的区别是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%A6%82%E6%9E%9C%E6%83%B3%E8%A6%81%E8%AE%A9UDP%E9%80%9A%E8%AE%AF%E5%85%B7%E5%A4%87TCP%E7%9A%84%E4%BC%98%E7%82%B9%EF%BC%8C%E5%BA%94%E8%AF%A5%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%EF%BC%9F"><span class="toc-number">5.4.</span> <span class="toc-text">4. 如果想要让UDP通讯具备TCP的优点，应该如何处理？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E5%AD%A6%E7%9B%B8%E5%85%B3"><span class="toc-number">6.</span> <span class="toc-text">数学相关</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%98%AF%E4%B8%8D%E6%98%AF%E6%89%80%E6%9C%89%E7%9F%A9%E9%98%B5%E9%83%BD%E6%9C%89%E9%80%86%E7%9F%A9%E9%98%B5%EF%BC%9F%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E4%B8%80%E4%B8%AA%E7%9F%A9%E9%98%B5%E7%9A%84%E9%80%86%E7%9F%A9%E9%98%B5%EF%BC%9F"><span class="toc-number">6.1.</span> <span class="toc-text">1. 是不是所有矩阵都有逆矩阵？如何计算一个矩阵的逆矩阵？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3"><span class="toc-number">7.</span> <span class="toc-text">算法相关</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%AF%B7%E9%97%AE%E4%B8%83%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B8%80%E8%88%AC%E6%8C%87%E5%93%AA%E4%B8%83%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%9F%E4%BD%A0%E4%B8%80%E8%88%AC%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%98%AF%E5%93%AA%E7%A7%8D%EF%BC%9F%E8%AF%B7%E7%AE%80%E5%8D%95%E6%8F%8F%E8%BF%B0%E5%AE%83%E7%9A%84%E6%8E%92%E5%BA%8F%E5%8E%9F%E7%90%86"><span class="toc-number">7.1.</span> <span class="toc-text">1. 请问七大排序算法一般指哪七种排序算法？你一般常用的排序算法是哪种？请简单描述它的排序原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%AF%B7%E7%AE%80%E5%8D%95%E6%8F%8F%E8%BF%B0%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%A7%84%E5%88%99%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">7.2.</span> <span class="toc-text">2. 请简单描述斐波那契数列的基本规则是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E8%AF%B7%E7%AE%80%E5%8D%95%E6%8F%8F%E8%BF%B0A%E6%98%9F%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">7.3.</span> <span class="toc-text">3. 请简单描述A星寻路算法的基本原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E8%AF%B7%E7%94%A8%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%80%BB%E7%BB%93"><span class="toc-number">7.4.</span> <span class="toc-text">4. 递归函数是什么？请用一句话总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%9C%A8%E7%BC%96%E5%86%99%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0%E6%97%B6%EF%BC%8C%E6%9C%80%E9%9C%80%E8%A6%81%E5%85%B3%E6%B3%A8%E7%9A%84%E4%B8%A4%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E8%AF%B7%E8%AF%B4%E5%87%BA%E4%BD%A0%E8%87%AA%E5%B7%B1%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">7.5.</span> <span class="toc-text">5.  在编写递归函数时，最需要关注的两点是什么？请说出你自己的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE-%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">7.6.</span> <span class="toc-text">6. 二分查找(折半查找)的原理是什么？</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/Unity%E5%B7%A5%E5%85%B7/Excel%E6%95%B0%E6%8D%AE%E5%B7%A5%E5%85%B7%E5%8C%85/" title="Excel配置表小工具">Excel配置表小工具</a><time datetime="2025-07-27T02:43:33.549Z" title="发表于 2025-07-27 10:43:33">2025-07-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/Shader/UnityShader%E5%9F%BA%E7%A1%80(%E4%B8%89)/" title="UnityShader基础（三）">UnityShader基础（三）</a><time datetime="2025-07-22T07:31:00.000Z" title="发表于 2025-07-22 15:31:00">2025-07-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/Shader/UnityShader%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89/" title="UnityShader基础（上）">UnityShader基础（上）</a><time datetime="2025-07-22T07:30:00.000Z" title="发表于 2025-07-22 15:30:00">2025-07-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/UGUI/Unity%E5%9F%BA%E7%A1%80%E2%80%94UGUI/" title="Unity基础—UGUI">Unity基础—UGUI</a><time datetime="2025-07-22T07:30:00.000Z" title="发表于 2025-07-22 15:30:00">2025-07-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/Shader/UnityShader%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E7%BA%B9%E7%90%86%E5%92%8C%E9%80%8F%E6%98%8E/" title="UnityShader入门——纹理和透明">UnityShader入门——纹理和透明</a><time datetime="2025-07-22T06:14:08.876Z" title="发表于 2025-07-22 14:14:08">2025-07-22</time></div></div></div></div></div></div></main><footer id="footer" style="background: linear-gradient(135deg,#1a1a1a 0%,#2c3e50 40%,#34495e 60%,#2980b9 80%,#1a1a1a 100%);"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By wqx</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const initValine = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyValine = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const valineConfig = {
      el: '#vcomment',
      appId: 'pjJwWJWtXHLRCDLec3YJwOKJ-gzGzoHsz',
      appKey: 'iQtqxeQmZAFwQ0VtxYgke25D',
      avatar: 'monsterid',
      serverURLs: 'https://pjjwwjwt.lc-cn-n1-shared.com',
      emojiMaps: "",
      visitor: false,
      ...option,
      path: isShuoshuo ? path : (option && option.path) || window.location.pathname
    }

    new Valine(valineConfig)
  }

  const loadValine = async (el, path) => {
    if (typeof Valine === 'function') {
      initValine(el, path)
    } else {
      await btf.getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js')
      initValine(el, path)
    }
  }

  if (isShuoshuo) {
    'Valine' === 'Valine'
      ? window.shuoshuoComment = { loadComment: loadValine }
      : window.loadOtherComment = loadValine
    return
  }

  if ('Valine' === 'Valine' || !false) {
    if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>