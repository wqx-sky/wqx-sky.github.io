<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Unity性能优化 | 游戏开发笔记</title><meta name="author" content="wqx"><meta name="copyright" content="wqx"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Unity 性能优化 一、优化相关前提 1.Unity游戏安装包&#x2F;运行卡的原因？Unity编译打包时，使用C#编写的脚本会通过Mono的C#编译器打包成IL(中间语言)，然后在Mono的虚拟机中运行。   用Mono方式来进行打包的程序会出现一堆动态链接库，程序员写的程序控制逻辑就在Assembly-CSharp.dll动态链接库里面  这个动态链接库里包括了所有的功能代码在里面，当要执">
<meta property="og:type" content="article">
<meta property="og:title" content="Unity性能优化">
<meta property="og:url" content="http://wqxblog.top/Unity/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/Unity%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/index.html">
<meta property="og:site_name" content="游戏开发笔记">
<meta property="og:description" content="Unity 性能优化 一、优化相关前提 1.Unity游戏安装包&#x2F;运行卡的原因？Unity编译打包时，使用C#编写的脚本会通过Mono的C#编译器打包成IL(中间语言)，然后在Mono的虚拟机中运行。   用Mono方式来进行打包的程序会出现一堆动态链接库，程序员写的程序控制逻辑就在Assembly-CSharp.dll动态链接库里面  这个动态链接库里包括了所有的功能代码在里面，当要执">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://skymirror-1316984539.cos.ap-beijing.myqcloud.com/Typoramimi.jpg">
<meta property="article:published_time" content="2025-04-14T11:08:10.016Z">
<meta property="article:modified_time" content="2025-04-15T11:29:39.168Z">
<meta property="article:author" content="wqx">
<meta property="article:tag" content="优化">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://skymirror-1316984539.cos.ap-beijing.myqcloud.com/Typoramimi.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Unity性能优化",
  "url": "http://wqxblog.top/Unity/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/Unity%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/",
  "image": "https://skymirror-1316984539.cos.ap-beijing.myqcloud.com/Typoramimi.jpg",
  "datePublished": "2025-04-14T11:08:10.016Z",
  "dateModified": "2025-04-15T11:29:39.168Z",
  "author": [
    {
      "@type": "Person",
      "name": "wqx",
      "url": "http://wqxblog.top/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://wqxblog.top/Unity/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/Unity%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Unity性能优化',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background: linear-gradient(135deg,#1a1a1a 0%,#2c3e50 25%,#34495e 45%,#2980b9 80%,#1a1a1a 100%);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="https://skymirror-1316984539.cos.ap-beijing.myqcloud.com/Typoramimi.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background: linear-gradient(135deg,#1a1a1a 0%,#2c3e50 40%,#34495e 60%,#2980b9 80%,#1a1a1a 100%);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">游戏开发笔记</span></a><a class="nav-page-title" href="/"><span class="site-name">Unity性能优化</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Unity性能优化</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-04-14T11:08:10.016Z" title="发表于 2025-04-14 19:08:10">2025-04-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-04-15T11:29:39.168Z" title="更新于 2025-04-15 19:29:39">2025-04-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Unity/">Unity</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Unity/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">性能优化</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">7.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>23分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="Unity-性能优化"><a href="#Unity-性能优化" class="headerlink" title="Unity 性能优化"></a>Unity 性能优化</h1><hr>
<h2 id="一、优化相关前提"><a href="#一、优化相关前提" class="headerlink" title="一、优化相关前提"></a>一、优化相关前提</h2><hr>
<h3 id="1-Unity游戏安装包-运行卡的原因？"><a href="#1-Unity游戏安装包-运行卡的原因？" class="headerlink" title="1.Unity游戏安装包&#x2F;运行卡的原因？"></a>1.Unity游戏安装包&#x2F;运行卡的原因？</h3><p>Unity编译打包时，使用C#编写的脚本会通过Mono的C#编译器打包成IL(中间语言)，然后在Mono的虚拟机中运行。</p>
<p><img src="https://skymirror-1316984539.cos.ap-beijing.myqcloud.com/Typoraimage-20250411135407904.png" alt="image-20250411135407904"></p>
<ul>
<li><p>用Mono方式来进行打包的程序会出现一堆动态链接库，程序员写的程序控制逻辑就在Assembly-CSharp.dll动态链接库里面</p>
</li>
<li><p>这个动态链接库里包括了所有的功能代码在里面，当要执行程序时，就必须在程序启动之前把它加载到Mono虚拟机里面 </p>
</li>
<li><ul>
<li>Mono本身是一个虚拟机，因为C#本身是运行在DotNet平台上面的，而DotNet平台本身就是一个基于虚拟机的的平台，Mono虚拟机是对DotNet虚拟机的跨平台移植</li>
</ul>
</li>
</ul>
<p>IL2CPP打包方式 </p>
<ul>
<li>使用IL2CPP方式打出来的包是没有动态连接库的，它将Mono虚拟机和Assembly-CSharp.dll动态链接库整合在了一起，放在libil2cpp.so文件里.</li>
</ul>
<ul>
<li><code>解决方案：</code><ul>
<li>就是性能优化。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-什么是Drawcall（绘画调用）"><a href="#2-什么是Drawcall（绘画调用）" class="headerlink" title="2.什么是Drawcall（绘画调用）"></a>2.什么是Drawcall（绘画调用）</h3><ul>
<li>DrawCall就是<code>cpu对图形绘制接口的调用</code>,CPU通过调用图形库(OpenGL)接口,命令GPU进行渲染操作。</li>
<li>DrawCall性能优化的元凶是CPU，每一次绘制时CPU都要调用DrwaCall。而在调用DrawCall前都会有很多准备工作：检测渲染状态、提交所需要的数据、提交所需要的状态。。。。。当DrawCall过多，CPU就会有很多额外开销用于准备工作，而GPU的计算能力很强，这时GPU就可能会闲置。</li>
<li>后期补充</li>
<li>DrawCall优化：减少DrawCall数量即可</li>
<li><img src="https://skymirror-1316984539.cos.ap-beijing.myqcloud.com/Typoraimage-20250411141625324.png" alt="image-20250411141625324"></li>
</ul>
<hr>
<h3 id="3-Profile性能分析器"><a href="#3-Profile性能分析器" class="headerlink" title="3.Profile性能分析器"></a>3.Profile性能分析器</h3><ul>
<li><p>影响性能的参数，可以在Profiler中查看</p>
</li>
<li><p><code>选择峰值查看</code>，那一帧往往开销较大</p>
</li>
<li><p>一般选用Play Mode模式，查看游戏运行时的性能</p>
</li>
<li><p>Deep Profile功能，收集所有C#方法占用性能。但是这个功能<code>非常耗费性能</code>，如果是大型项目，开启就会捕捉成百上千个脚本，非常消耗性能。一般采用单独脚本分析。</p>
</li>
<li><p>Profile Analyzer配合Profiler使用。当我们使用Profiler收集了数据之后，不要关闭Profiler，并且打开Profile Analyzer，把Profiler收集的数据导入到Profile Analyzer，使用Profile Analyzer可以帮助我们选出一段数据中最具有代表性的一帧，方便我们进行性能分析。也能看出<code>收集的数据整体的一些情况</code>，例如中位数、平均值、最大值、最小值等。</p>
</li>
</ul>
<hr>
<h4 id="1-如何用分析器分析指定一段代码？"><a href="#1-如何用分析器分析指定一段代码？" class="headerlink" title="(1) 如何用分析器分析指定一段代码？"></a>(1) 如何用分析器分析指定一段代码？</h4><p>用  <code>Profiler.BeginSample(名称)和  Profiler.EndSample()</code>将指定代码括起来即可。中间的代码即可进行测试。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="comment">//这个名字不要写中文名。可能会搜索不到</span></span><br><span class="line">        Profiler.BeginSample(<span class="string">&quot;123&quot;</span>);<span class="comment">//开始截取代码，参数是分析器里面的名称是自定义的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            a += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Profiler.EndSample();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">file</span>:<span class="comment"><span class="doctag">///</span>D:/Unity/Editor/2022.2.13f1c1/Editor/Data/Documentation/en/Manual/ProfilerWindow.html</span></span><br></pre></td></tr></table></figure>

<p>​	其他模块具体可看Unity手册</p>
<hr>
<h3 id="4-调用栈（Call-Stack）"><a href="#4-调用栈（Call-Stack）" class="headerlink" title="4.调用栈（Call Stack）"></a>4.调用栈（Call Stack）</h3><ul>
<li><p>是计算机程序在执行过程中<code>记录函数调用的一种数据结构</code>。</p>
</li>
<li><p>调用栈是一个栈结构，即先进后出。它用于记录程序执行过程中，每一个函数被调用情况。</p>
</li>
<li><p>当一个函数被调用时，它的相关信息，<code>如函数名、参数、返回地址等，会被添加进调用栈中</code>。当该函数执行完成后，相应的信息会从调用栈中移除。通过不断的添加和移除，调用栈就记录了程序执行的顺序。</p>
</li>
<li><p>调用栈对于程序调试和分析非常有用。当程序出现错误或异常时，可以通过<code>查看调用栈来确定错误发生的位置和函数调用顺序</code>。调试器通常会显示当前调用栈的信息，以帮助开发人员查看函数的执行过程并找出发生异常的原因。</p>
</li>
<li><p>选中Deep Profile右侧的Call Stacks按钮，这样在收集性能数据的时候，每一帧都会记录该方法的的调用栈信息。</p>
</li>
<li><p>GC.Alloc、UnsafeUtility.Malloc、JobHandle.Complete是Unity的方法，启用Call Stacks且勾选它们后，如果Unity有调用它们，则可以在Hierarchy或Raw Hierarchy右侧的搜索框中搜索到它们，这样就可以查看它们的性能了。</p>
<ul>
<li><code>GC.Alloc</code>表示GC的内存分配情况。</li>
<li><code>UnsafeUtility.Malloc(Persistent)用于在内存中分配指定大小的未初始化内存块</code>。这个方法会直接在堆上分配内存，并可以绕过自动内存管理功能，需要手动管理内存的生命周期和释放。一般情况下，只有在<code>处理非托管内存的特定场景下</code>才会使用UnsafeUtility.Malloc方法。</li>
<li>JobHandle.Complete表示Job的完成情况。这里的Job是指Unity的Job System的一组特定的任务。</li>
</ul>
</li>
</ul>
<h4 id="（1）托管内存"><a href="#（1）托管内存" class="headerlink" title="（1）托管内存"></a>（1）托管内存</h4><ul>
<li>是<code>垃圾回收器自动管理的内存</code>，当到达一定量时，会由垃圾回收器自动释放它们。</li>
<li>托管内存存放在托管堆中。托管堆是一种<code>用于存储和管理对象的内存区域</code></li>
<li>垃圾回收机制：<ul>
<li>每当创建一个新的托管对象时，托管堆就会分配内存空间给这个对象，并记录这个对象的信息。当托管对象不再被引用或不可达时，垃圾回收器会自动将其标记为垃圾，并在适当的时候回收其占用的内存空间。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="（2）非托管内存"><a href="#（2）非托管内存" class="headerlink" title="（2）非托管内存"></a>（2）非托管内存</h4><ul>
<li>非托管内存<code>不会自动被回收</code>，它们需要我们程序员写代码去管理和释放它们。</li>
<li>非托管内存并不固定存储在一个地方，它们往往分散存储在不同的地方，例：操作系统的内存、临时缓冲区等。</li>
</ul>
<hr>
<h4 id="（3）DOTS简介"><a href="#（3）DOTS简介" class="headerlink" title="（3）DOTS简介"></a>（3）DOTS简介</h4><ul>
<li>DOTS（Data-Oriented Technology Stack）是Unity引擎中的一个新的编程模型和工具集。它旨在提供更高性能、更可扩展和更并行化的游戏开发体验。</li>
<li>三个主要部分：<ul>
<li>ECS框架：<ul>
<li>ECS是一种用于组织和管理游戏对象的方式。它将游戏对象分解为<code>实体（Entity）</code>、<code>组件（Component）</code>和<code>系统（System）</code>。这种模式更加适合于并行处理和优化，可以提高游戏性能。</li>
</ul>
</li>
<li>Job System（作业系统）：<ul>
<li>Job System允许开发者将任务并行化，利用多核处理器的能力。它通过将任务<code>划分为小的作业（jobs）并在多个线程上并发执行来提高性能</code>。Job System还可以与ECS结合使用，使得开发者可以更好地控制游戏的行为。</li>
</ul>
</li>
<li>Burst Compiler（突发编译器）：<ul>
<li>Burst Compiler是一种高性能的C#编译器，可以将C#代码转换为高效的本机代码，以进一步提高游戏的性能。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="5-设置性能分析器的一些属性"><a href="#5-设置性能分析器的一些属性" class="headerlink" title="5.设置性能分析器的一些属性"></a>5.设置性能分析器的一些属性</h3><ul>
<li>Color Blind Mode<ul>
<li>色盲模式，开启后会调整Profile窗口的颜色，照顾色盲用户。</li>
</ul>
</li>
<li>live按钮：<code>实时采集</code> ,数据收集期间也会动态的显示数据</li>
<li>Show Stats for ‘current frame’<ul>
<li>开启后，当点击Frame:XXX&#x2F;XXX左侧的按钮，从而选中最后一帧，则会显示最后一帧的统计信息。</li>
</ul>
</li>
<li>Preferences<ul>
<li>点击后会打开Project Settings窗口，用于设置性能分析器的一些属性。<ul>
<li>Frame Count：开始收集性能的数据时，每次最多可以查看多少帧。例如数值是300，则表示最多可以查看300帧。</li>
<li>Default recording state：选择Enable，则重启Unity再打开Profiler窗口，如果此时的模式是Edit Mode，则会自动开始点击圆形按钮，开始收集数据。选择Disabled，则重启Unity再打开Profiler窗口，需要手动点击圆形按钮，才会开始收集数据。选择Remember，则会按照当前圆形按钮是启用还是禁用来决定下一次重启Unity再打开Profiler窗口时，该圆形按钮是否启用。</li>
<li>Default editor target mode on start：选择Play Mode，则重启Unity再打开Profiler窗口，左上方会选择Play Mode，即在播放模式下才会收集数据。如果选择Edit Mode，则重启Unity再打开Profiler窗口，左上方会选择Edit Mode，即在编辑器模式下收集数据。</li>
<li>Custom connection ID：当有多个Unity项目的实例同时运行，它们都要使用性能分析器来分析性能，则可以通过这个Custom connection ID来区分它们。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="6-CPU-Usage模块"><a href="#6-CPU-Usage模块" class="headerlink" title="6. CPU Usage模块"></a>6. CPU Usage模块</h3><ul>
<li><p>下方窗口可以选择Timeline、Hierarchy、Raw Hierarchy。</p>
</li>
<li><p>Timeline:</p>
<ul>
<li>可以通过时间轴的方式查看这一帧中CPU依次干了什么。</li>
</ul>
</li>
<li><p>Hierarchy:</p>
<ul>
<li><p>可以查看CPU在这一帧中做的事情所消耗的性能和所花费的时间。</p>
</li>
<li><p>Total：</p>
<ul>
<li>表示一共占用了CPU使用情况的百分之几</li>
</ul>
</li>
<li><p>Self：</p>
<ul>
<li>表示自身的代码占用了CPU使用情况的百分之几，调用其它方法的代码不算在内的。</li>
</ul>
</li>
<li><p>Calls：</p>
<ul>
<li>表示被调用了几次</li>
</ul>
</li>
<li><p>GC Alloc：</p>
<ul>
<li>表示GC分配的内存，当一个对象被释放后，它GC分配的内存不会马上被回收，所有GC分配的内存的总量达到一定程度，会触发GC，此时垃圾回收器才会把这些内存回收，不过同时也会造成游戏卡一下。</li>
</ul>
</li>
<li><p>Time ms：</p>
<ul>
<li>表示一共耗时多少毫秒</li>
</ul>
</li>
<li><p>Self ms：</p>
<ul>
<li>表示表示自身的代码耗时多少毫秒，调用其它方法的代码不算在内的。</li>
</ul>
<p>  <img src="https://skymirror-1316984539.cos.ap-beijing.myqcloud.com/Typoraimage-20250412195856977.png" alt="image-20250412195856977"></p>
</li>
</ul>
<hr>
</li>
</ul>
<h3 id="7-Frame-Debugger"><a href="#7-Frame-Debugger" class="headerlink" title="7.Frame Debugger"></a>7.Frame Debugger</h3><ul>
<li><p>Frame Debugger窗口也叫帧调试器窗口，<code>用于查看每一帧的画面是如何渲染出来的</code>，可以详细查看这一帧的绘制过程。</p>
</li>
<li><p>打开Frame Debugger面板的方式：</p>
<ul>
<li>Window——Analysis——Frame Debugger、</li>
</ul>
</li>
<li><p>按下“Enable”，则会启动帧调试，此时如果运行了游戏，则会自动暂停，然后当前这帧的渲染情况可以在这个窗口中查看。</p>
</li>
<li><p>用Frame Debugger窗口查看当前一帧的每一步时，可以配合Stats窗口使用，以此来确定哪一个物体造成的性能开销较大。</p>
<p>  绘制的步骤越少，性能越好。</p>
<ul>
<li><p>Frame Debugger窗口也能看到每一帧的Shader信息，但是需要有一定Shader基础才能看懂。</p>
<pre><code>  大多数平台都支持帧调试器的使用，可以用手机的数据线成功连接到电脑，在手机上运行Unity的游戏，Frame Debugger窗口中会多出该手机设备供我们选择，我们就可以分析该手机设备上运行的Unity项目的性能。
  也可以让手机和电脑都连接同一个wifi，这样一来，Frame Debugger窗口中也会多出该手机设备供我们选择，我们就可以分析该手机设备上运行的Unity项目的性能。
  但是要注意，构建时必须在Project Settings窗口中勾选“Development Build”。而且有些平台可能不支持Frame Debugger的使用，例如WebGL平台。
</code></pre>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="8、Memory-Profiler"><a href="#8、Memory-Profiler" class="headerlink" title="8、Memory Profiler"></a>8、Memory Profiler</h3><hr>
<ul>
<li><p>拍摄的 内存快照会存储在Assets的同级文件夹MemoryCaptures里面。</p>
</li>
<li><p>看官方文档。要安装插件</p>
</li>
<li><p>Memory Profiler可以查看游戏当前一帧具体的内存使用情况，我们可以详细地看到各种东西占用了多少内存。</p>
<ul>
<li>如果发现某样东西占用了过高的内存，则可以考虑问题是不是出在它身上，从它身上入手来进行优化。也可以分析是不是存在内存泄漏问题，即可以分析是不是某些资源一直占着内存得不到释放，才导致内存占用过高。</li>
</ul>
</li>
<li><p>在Unity编辑器中运行游戏，Memory Profiler记录的内存情况可能会不准确，它会把Unity编辑器的一些内存占用情况也记录进去。我们应该把游戏构建到电脑或者手机，然后在电脑或者手机上运行游戏，再用Memory Profiler拍内存快照来分析，此时这些内存快照记录的数据才是准确的。</p>
<ul>
<li><p>构建项目到电脑时，应勾选Build Settings窗口的Development Build、Autoconnect Profiler，这样当发布的游戏运行时，就可以在Unity引擎的Memory Profiler左上角的下拉菜单选择关联刚才发布的程序，拍下快照查看它的内存占用情况。</p>
</li>
<li><p>用手机数据线连接到电脑，在手机上运行游戏，并在电脑分析，也必须勾选Build Settings窗口的Development Build、Autoconnect Profiler，而且手机上应勾选“开启开发者选项”、“USB调试”、“USB安装”。当用手机数据线连接到电脑，Memory Profiler左上的下拉菜单可以选择连接到电脑的手机设备。</p>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="9、Physics-Debugger窗口"><a href="#9、Physics-Debugger窗口" class="headerlink" title="9、Physics Debugger窗口"></a>9、Physics Debugger窗口</h3><ul>
<li><p>也叫<code>物理调试窗口</code>，使用它可以<code>在Scene窗口中查看当前场景中游戏对象的碰撞器、触发器、刚体、关节等与物理模拟相关的东西的范围</code>。尤其是在游戏对象较多的场景中，使用物理调试窗口可以方便我们观看它们的范围。</p>
</li>
<li><p>打开方法：Window——Analysis——Physics Debugger。</p>
</li>
<li><p>在Scene窗口中勾选Collision Geometry，则会在Scene窗口中显示游戏对象的碰撞几何体，具体的情况可以在Physics Debugger窗口中查看到和修改。如果勾选Mouse Select，则会开启鼠标悬停和鼠标选择功能，方便查看碰撞几何体。</p>
</li>
<li><p>Selected Object Info表示当前选中的游戏对象的信息。</p>
</li>
<li><p>Show Physics Scene表示要在哪些场景中显示碰撞几何体。</p>
</li>
<li><p>Show Layers表示哪些Layer层的游戏对象要显示碰撞几何体。</p>
</li>
<li><p>Show Static Colliders表示显示静态的碰撞器组件的范围。</p>
</li>
<li><p>Show Triggers表示显示勾选了Is Trigger属性的碰撞器的范围。</p>
</li>
<li><p>Show Rigidbodies表示显示Rigidbody组件的范围。</p>
</li>
<li><p>Show Kinematic Bodies表示显示勾选了Is Kinematic的Rigidbody组件的范围。</p>
</li>
<li><p>Show Articulation Bodies表示显示Articulation Body组件的范围。Articulation Body组件用于模拟机器人、车辆等物体的关节行为。例如可以实现机器人的动作、车辆的悬挂等物理效果。</p>
</li>
<li><p>Show Sleeping Bodies表示显示处于睡眠状态的Rigidbody组件的范围。当一个刚体在一段时间内没有受到外力作用，则会自动进入睡眠状态，进入睡眠状态的刚体不会参与物理模拟。当它再次受到外力的作用时，它就会从睡眠状态中唤醒，此时就又会重新参与物理模拟了。</p>
</li>
<li><p><code>Collider Types</code></p>
<ul>
<li>Show BoxColliders表示显示盒子碰撞器的范围。</li>
<li>Show SphereColliders表示显示球体碰撞器的范围。</li>
<li>Show CapsuleColliders表示显示胶囊体碰撞器的范围。</li>
<li>Show MeshColliders(convex)表示显示网格碰撞器的范围。</li>
<li>Show MeshColliders(concave)表示显示网格碰撞器的范围。</li>
<li>Show Terrain Colliders表示显示地形碰撞器的范围。</li>
</ul>
</li>
<li><p><code>Colors</code></p>
<ul>
<li>Static Colliders表示显示静态的碰撞器的颜色。</li>
<li>Triggers表示显示勾选了Is Trigger属性的碰撞器的颜色。</li>
<li>Rigidbodies表示显示Rigidbody组件的颜色。</li>
<li>Kinematic Bodies表示显示勾选了Is       Kinematic的Rigidbody组件的颜色。</li>
<li>Articulation Bodies表示显示Articulation Body组件的颜色。</li>
<li>Sleeping Bodies表示显示处于睡眠状态的Rigidbody组件的颜色。</li>
<li>Variation表示要显示的颜色与随机颜色混合的程度。调节这个变量，会影响所有显示的几何碰撞体的颜色。</li>
</ul>
</li>
<li><p><code>Rendering</code></p>
<ul>
<li>Transparency控制绘制的碰撞几何体的透明度。</li>
<li>Force Overdraw，勾选后，绘制的碰撞集合体会更加清晰。</li>
<li>View Distance控制能在Scene窗口中看到碰撞几何体的距离。</li>
<li>Terrain Tiles Max控制能在Scene窗口中看到Unity自带的地形系统Terrain的瓦片的最大数量。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="10、Import-Activity窗口"><a href="#10、Import-Activity窗口" class="headerlink" title="10、Import Activity窗口"></a>10、Import Activity窗口</h3><hr>
<ul>
<li>可以查看项目中的资源的信息。例如什么时候导入这个资源的、这个资源的文件大小等。</li>
</ul>
<hr>
<h3 id="11-、Code-Coverage窗口"><a href="#11-、Code-Coverage窗口" class="headerlink" title="11 、Code Coverage窗口"></a>11 、Code Coverage窗口</h3><hr>
<ul>
<li>Code Coverage用来评估我们编写的代码，在游戏测试运行的时候有多少被执行了。如果有一部分代码没有被执行，我们就要考虑是不是我们代码的逻辑有问题，从而改进我们的代码。</li>
<li>打开方法：Window——Analysic——Code Coverage</li>
<li>官方文档：<a target="_blank" rel="noopener" href="https://docs.unity.cn/Packages/com.unity.testtools.codecoverage@1.1/manual/index.html">https://docs.unity.cn/Packages/com.unity.testtools.codecoverage@1.1/manual/index.html</a></li>
<li>使用思路：<ul>
<li>先勾选<code>Enable Code Coverage</code>，然后勾选<code>Auto Generate Report</code>，再点击Start Recording按钮，接着点击播放按钮运行游戏。点击Start Recording按钮后，它会变成Stop Recording，测试完毕后点击它，就会停止测试。然后我们就可以在Result Location的路径找到生成的报告，从中看出在测试的时候有多少代码被执行了。\</li>
</ul>
</li>
<li>其他属性<ul>
<li>Results Location表示生成的报告要存放到的路径。</li>
<li>History Location表示生成的报告的历史记录要存放到的路径。必须勾选了Generate History才会生成。</li>
<li>Enable Code Coverage表示启用代码覆盖，测试之前要勾选它。</li>
<li>Included Assemblies表示测试的时候要考虑哪些程序集的代码。</li>
<li>Included Paths表示测试的时候要考虑哪些文件夹或文件中的代码。</li>
<li>Excluded Paths表示测试的时候不考虑哪些文件夹或文件中的代码。</li>
<li>Generate HTML Report，勾选后，生成报告时，会以html的格式来生成报告。如果取消勾选，则会以其它形式来生成报告，但是这样不方便我们观看。建议勾选。</li>
<li>Generate Summary Badges，勾选后，生成的报告的文件夹中，会额外生成.svg和.png后缀的文件，概括这次测试中有百分之几的代码被使用了。</li>
<li>Generate History，勾选后，生成报告时，会自动在History Location的路径生成历史记录。</li>
<li>Generate Additional Metrics，勾选后，生成报告时，报告中会有额外的衡量指标。</li>
<li>Auto Generate Report，勾选后，我们点击Start Recording开始测试，然后点击Stop Recording结束测试后，会自动在Results Location的路径生成报告。</li>
<li>Clear Data清空上一次测试的数据。</li>
<li>Clear History，清空History Location路径中的所有历史记录。</li>
<li>Generate from Last，根据上一次测试的数据，在Results Location的路径生成报告。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="二、静态批处理"><a href="#二、静态批处理" class="headerlink" title="二、静态批处理"></a>二、静态批处理</h2><hr>
<h3 id="1-什么是静态批处理"><a href="#1-什么是静态批处理" class="headerlink" title="1.什么是静态批处理"></a>1.什么是静态批处理</h3><ul>
<li>静态合批也叫静态批处理，是Unity的一种优化技术。对于始终静止不动的物体使用静态合批后，<code>CPU会把它们合并为一个批次发送给GPU处理</code>，这样可以减少Draw Call带来的性能消耗，从而提升游戏性能。</li>
<li>注：<code>静态批处理比[动态批处理](https://docs.unity3d.com/cn/current/Manual/dynamic-batching.html)更高效</code>，因为静态批处理不会转换 CPU 上的顶点。有关静态批处理的性能影响的更多信息。</li>
<li>注：要使用静态合批，必须确保Edit——Project Settings——Player——Other Settings——<code>Static Batching</code>是勾选的。</li>
</ul>
<hr>
<h3 id="2-如何进行静态批处理"><a href="#2-如何进行静态批处理" class="headerlink" title="2.如何进行静态批处理"></a>2.如何进行静态批处理</h3><ul>
<li><p>物体设置为静态的方法：</p>
<ul>
<li><p>选中该物体，点击在Inspector窗口右上角的Static右方的下拉菜单，选择Batching Static。</p>
</li>
<li><p>使用静态合批虽然可以提升游戏性能，但是设置为静态的物体在整个游戏中就不能再运动了，强行使它们运动会出问题。</p>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-静态批处理的注意事项"><a href="#3-静态批处理的注意事项" class="headerlink" title="3.静态批处理的注意事项"></a>3.静态批处理的注意事项</h3><ul>
<li>而且即使按照以上步骤进行了静态合批，也不一定保证会成功，<code>必须满足以下全部条件</code>，静态合批才会成功：<br>  1、游戏对象处于<code>激活</code>状态。<br>  2、游戏对象有一个<code>Mesh Filter组件</code>，并且该组件已启用。<br>  3、Mesh Filter组件具有对网格的引用。<br>  4、网格已启用<code>Read/Write功能</code>。<br>  5、网格的顶点计数大于0。<br>  6、该网格尚未与另一个网格组合。<br>  7、游戏对象有一个<code>Mesh Renderer</code>组件，并且该组件已启用。<br>  8、网格渲染器组件不将任何材质与DisableBatching标记设置为true的着色器一起使用。<br>  9、要批处理在一起的网格使用相同的顶点属性。例如，Unity可以将使用顶点位置、顶点法线和一个UV的网格与另一个UV进行批处理，但不能将使用顶点定位、顶点法线、UV0、UV1和顶点切线的网格进行批处理。</li>
<li><img src="https://skymirror-1316984539.cos.ap-beijing.myqcloud.com/Typoraimage-20250413214501293.png" alt="image-20250413214501293"></li>
<li>注：即使静态合批成功，合出来的每个批次可以包含的网格顶点数是有限的，最多是64000个顶点。如果超过这个数，则会创建到另一个批次中。</li>
<li>合成成功后(Static Batching会有数据显示)<img src="https://skymirror-1316984539.cos.ap-beijing.myqcloud.com/Typoraimage-20250413220650463.png" alt="image-20250413220650463"></li>
</ul>
<h3 id="4-思考unity光照会影响静态批处理吗"><a href="#4-思考unity光照会影响静态批处理吗" class="headerlink" title="4.思考unity光照会影响静态批处理吗"></a>4.思考unity光照会影响静态批处理吗</h3><blockquote>
<ul>
<li>在Unity中，光照设置对静态批处理的影响主要取决于物体是否使用了<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=240336235&content_type=Article&match_order=1&q=%E5%85%89%E7%85%A7%E8%B4%B4%E5%9B%BE&zhida_source=entity">光照贴图</a>（Lightmaps）和是否接受<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=240336235&content_type=Article&match_order=1&q=%E5%AE%9E%E6%97%B6%E5%85%89%E7%85%A7&zhida_source=entity">实时光照</a>。<br>  以下是光照如何影响静态批处理的一些情况：<ul>
<li>1，使用光照贴图的静态物体:<br>  当静态游戏对象使用光照贴图时，它们的光照信息被预计算并存储在贴图中。这些物体可以被静态批处理，因为它们的光照不会在运行时改变。光照贴图是静态光照的一部分，通常用于烘焙静态场景的光照。</li>
<li>2，接受实时光照的静态物体:<br>  静态物体也可以接受实时光照，但这不会影响它们是否可以进行静态批处理。静态批处理主要关注的是网格和材质的合并，而不是光照模式。不过，实时光照的计算可能会在运行时产生额外的性能开销。</li>
<li>3，动态光照与静态批处理:<br>  如果场景中的光源是动态的（例如，移动的点光源或聚光灯），它们会在运行时影响物体的光照。静态批处理的物体仍然可以接受动态光照，但是光照的计算是在GPU上实时进行的，这与批处理的网格合并无关。</li>
<li>4，阴影和静态批处理:<br>  静态批处理的物体可以产生和接受阴影。如果使用了阴影贴图，阴影可以被预计算并存储，类似于光照贴图。实时阴影的计算不会影响静态批处理，但会增加渲染负担。</li>
</ul>
</li>
</ul>
<p>总的来说，<code>光照设置本身不会直接影响静态批处理的过程</code>。静态批处理是在构建时对使用相同材质的静态网格进行合并的优化技术。然而，<code>光照设置会影响渲染性能</code>，因此在设计场景时，你应该考虑到光照对性能的潜在影响，尤其是在移动和其他性能受限的平台上。</p>
</blockquote>
<hr>
<h3 id="5-在游戏运行时进行静态合批-用的少"><a href="#5-在游戏运行时进行静态合批-用的少" class="headerlink" title="5.在游戏运行时进行静态合批(用的少)"></a>5.在游戏运行时进行静态合批(用的少)</h3><hr>
<ul>
<li>如果要在游戏运行时进行静态合批，则可以使用<code>StaticBatchingUtility类的Combine方法</code>。</li>
<li><code>StaticBatchingUtility.Combine(GameObject 根物体)</code><br>      对指定的根物体的所有子孙物体进行静态合批。<br>      只有当它们符合静态合批的所有条件，静态合批才会成功。<br>      成功之后，这些物体就不能再运动了，强行运动会出问题。但是该根物体仍然允许运动。</li>
<li><code>StaticBatchingUtility.Combine(GameObject[] 要进行静态合批的游戏对象,GameObject 根物体)</code><br>      对指定的游戏对象进行静态合批，并指定它们静态合批的根物体。<br>      只有当它们符合静态合批的所有条件，静态合批才会成功。<br>      成功之后，这些物体就不能再运动了，强行运动会出问题。但是该根物体仍然允许运动。</li>
</ul>
<hr>
<h2 id="三、动态批处理"><a href="#三、动态批处理" class="headerlink" title="三、动态批处理"></a>三、动态批处理</h2><hr>
<h3 id="1-什么是动态批处理"><a href="#1-什么是动态批处理" class="headerlink" title="1.什么是动态批处理"></a>1.什么是动态批处理</h3><ul>
<li><p>动态合批也叫动态批处理，是Unity的<code>一种优化技术</code>。</p>
<p>  对<code>移动的物体</code>使用动态合批后，则Unity不会一个个绘制它们，而是把它们<code>合并为一个批次（Batch）</code>，再由CPU把它们一次性提交给GPU进行处理，这样可以减少Draw Call带来的性能消耗，从而提高性能。</p>
</li>
<li><p>官方文档：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.unity3d.com/cn/current/Manual/dynamic-batching.html">https://docs.unity3d.com/cn/current/Manual/dynamic-batching.html</a></li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-如何将进行动态批处理"><a href="#2-如何将进行动态批处理" class="headerlink" title="2.如何将进行动态批处理"></a>2.如何将进行动态批处理</h3><ul>
<li>动态合批默认是由Unity自动完成。</li>
<li>可以在Edit——Project Settings——Player——Other Settings——Dynamic Batching查看。</li>
<li><code>默认Dynamic Batching是勾选的</code>，当条件满足时，Unity会自动对使用了<code>相同材质（Material）</code>的物体进行动态合批。如果取消勾选，则不会进行动态合批。</li>
</ul>
<hr>
<h3 id="3-动态批处理的注意事项"><a href="#3-动态批处理的注意事项" class="headerlink" title="3.动态批处理的注意事项"></a>3.动态批处理的注意事项</h3><ul>
<li><p>即使勾选了Dynamic Batching，也必须同时满足以下条件，动态合批才会成功：</p>
<ul>
<li>（1）Unity<code>不能对包含超过900个顶点属性和225个顶点的网格</code>应用动态批处理。这是因为网格的动态批处理对每个顶点都有开销。例如，如果你的着色器使用顶点位置、顶点法线和单个UV，那么Unity<code>最多可以批处理225个顶点</code>。然而，如果你的着色器使用顶点位置、顶点法线、UV0、UV1和顶点切线，那么Unity只能批处理180个顶点。</li>
<li>（2）如果GameObjects使用不同的材质实例，Unity就不能将它们批处理在一起，即使它们本质上是相同的。唯一的例外是阴影施法者的渲染。</li>
<li>（3）带有<code>光贴图的游戏对象有额外的渲染参数</code>。这意味着，如果你想批处理光照贴图的游戏对象，它们必须指向相同的光照贴图位置。</li>
<li>（4）Unity<code>不能完全将动态批处理应用于使多通道着色器的GameObjects</code>。<ul>
<li>几乎所有的Unity着色器都支持正向渲染中的多个光源。为了实现这一点，他们为每个光处理一个额外的渲染通道。<code>Unity只批处理第一个渲染通道</code>。<code>它不能批处理额外的逐像素灯光的绘制调用。</code><br>  遗留延迟渲染路径不支持动态批处理，因为它在两个渲染通道中绘制GameObjects。第一个通道是灯光预通道，第二个通道渲染GameObjects。</li>
</ul>
</li>
</ul>
</li>
<li><p>注：物体必须使用<code>相同的材质</code>，才有可能成功进行动态合批。</p>
</li>
<li><p>注：使用动态合批往往能减少CPU和GPU的开销，提升游戏性能，但同时<code>也会占用一定的内存</code>。</p>
<p>  <code>是否要开启动态合批，要根据自己的项目来定。可以尝试启用，在性能分析器中看看效果如果，如果效果好，再确定启用它。</code></p>
</li>
</ul>
<hr>
<h2 id="四、GPU-Instancing"><a href="#四、GPU-Instancing" class="headerlink" title="四、GPU Instancing"></a>四、GPU Instancing</h2><hr>
<h3 id="1-什么是GPU-Instancing"><a href="#1-什么是GPU-Instancing" class="headerlink" title="1.什么是GPU Instancing"></a>1.什么是GPU Instancing</h3><ul>
<li>使用GPU Instancing可以在一个Draw Call中同时渲染多个相同或类似的物体，从而减少CPU和GPU的开销。</li>
<li>官方文档：<ul>
<li><a target="_blank" rel="noopener" href="https://docs.unity3d.com/Manual/GPUInstancing.html">https://docs.unity3d.com/Manual/GPUInstancing.html</a></li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-如果启用GPU-Instancing"><a href="#2-如果启用GPU-Instancing" class="headerlink" title="2.如果启用GPU Instancing"></a>2.如果启用GPU Instancing</h3><ul>
<li>要启用GPU Instancing，我们可以选中一个材质，然后在Inspector窗口勾选Enable GPU Instancing，这样就可以了。</li>
</ul>
<hr>
<h3 id="3-GPU-Instancing注意事项"><a href="#3-GPU-Instancing注意事项" class="headerlink" title="3.GPU Instancing注意事项"></a>3.GPU Instancing注意事项</h3><ul>
<li>要成功使用GPU Instancing进行优化，游戏对象必须<code>同时满足以下条件</code>：<ul>
<li>（1）使用<code>相同的材质和网格</code></li>
<li>（2）材质的着<code>色器必须支持GPU Instancing</code>。例如：标准着色器和表面着色器。</li>
<li>（3）网格的<code>顶点布局和着色器</code>必须相同。如果网格的顶点布局或者着色器不同，那么它们就无法被合成一个实例。</li>
<li>（4）每个实例需要有不同的变换信息（例如位置、旋转缩放）。虽然多个实例可以使用相同的材质和网格，但是它们必须拥有不同的变换信息，才能被正确地实例化并渲染出来。</li>
</ul>
</li>
<li>注： 另外需要注意的是，GPU Instancing与SRP Batcher不兼容。如果项目使用了SRP Batcher，并且配置为优先使用SRP Batcher而不是GPU实例化，启用GPU实例化可能不会生效。SRP Batcher是Unity提供的一种渲染优化技术，它可以将多个网格合并成单个批次进行渲染，从而提高性能。在这种情况下，GPU实例化将被忽略。</li>
<li>注：使用GPU Instancing往往能减少CPU和GPU的开销，提升游戏性能，但同时也会占用一定的内存。</li>
<li>是否要启用GPU Instancing，<code>要根据自己的项目来定</code>。可以尝试启用，在性能分析器中看看效果如果，如果效果好，再确定启用它。</li>
<li>一般来说，当场景中有大量重复的网格实例时，可以尝试启用GPU Instancing。例如场景中有大量树木、草地、石块等，这些实例具有相同的网格和材质，只是位置、颜色等属性稍有差异，那么启用GPU Instancing或许能够显著提高性能。</li>
</ul>
<hr>
<h2 id="五、遮挡剔除"><a href="#五、遮挡剔除" class="headerlink" title="五、遮挡剔除"></a>五、遮挡剔除</h2><hr>
<h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://wqxblog.top">wqx</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://wqxblog.top/Unity/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/Unity%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">http://wqxblog.top/Unity/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/Unity%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://wqxblog.top" target="_blank">游戏开发笔记</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E4%BC%98%E5%8C%96/">优化</a></div><div class="post-share"><div class="social-share" data-image="https://skymirror-1316984539.cos.ap-beijing.myqcloud.com/Typoramimi.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/uncategorized/hello-world/" title="Hello World"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Hello World</div></div><div class="info-2"><div class="info-item-1">Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot;  More info: Writing Run server1$ hexo server  More info: Server Generate static files1$ hexo generate  More info: Generating Deploy to remote sites1$ hexo deploy  More info: Deployment </div></div></div></a><a class="pagination-related" href="/C-%E8%BF%9B%E9%98%B6/%E5%85%AB%E8%82%A1%E6%96%87/Csharp%E8%BF%9B%E9%98%B6%E4%B9%8B%E7%9F%A5%E8%AF%86%E7%82%B9%E6%8B%93%E5%B1%95/" title="C#进阶之知识点拓展"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">C#进阶之知识点拓展</div></div><div class="info-2"><div class="info-item-1">C#进阶之知识点拓展一、.Net相关知识1.  微软的.Net  微软的.Net既不是编程语言也不是框架 你可以简单为.Net本质上就是微软为自己的一系列产品取的一个代号。 包含的内容： 框架体系：.Net Framework、.Net  Core、Mono等等。 开发语言：C#,VB,F#等等(C#是.Net平台主推的开发语言) 开发工具：Visual  Studio、Visual  Studio  Code等等。      2.微软做.Net平台的目的  (1). 跨语言  只要是面向.NET平台的编程语言(C#,VB,C++,F#等等)，用其中一种语言编写的内容可以无缝地用在另一种语言编写的应用程序中。     (2). 跨平台  一次编译，不需要任何代码修改，应用程序就可以运行在任意有.NET框架实现的操作系统上，即代码不依赖于操作系统，也不依赖硬件环境。      3.如何实现的跨语言？(1). CLS（Common Language ...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="https://skymirror-1316984539.cos.ap-beijing.myqcloud.com/Typoramimi.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">wqx</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">-只用于学习如有版权问题请联系我 484807196@qq.com</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Unity-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">1.</span> <span class="toc-text">Unity 性能优化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%BC%98%E5%8C%96%E7%9B%B8%E5%85%B3%E5%89%8D%E6%8F%90"><span class="toc-number">1.1.</span> <span class="toc-text">一、优化相关前提</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Unity%E6%B8%B8%E6%88%8F%E5%AE%89%E8%A3%85%E5%8C%85-%E8%BF%90%E8%A1%8C%E5%8D%A1%E7%9A%84%E5%8E%9F%E5%9B%A0%EF%BC%9F"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.Unity游戏安装包&#x2F;运行卡的原因？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BB%80%E4%B9%88%E6%98%AFDrawcall%EF%BC%88%E7%BB%98%E7%94%BB%E8%B0%83%E7%94%A8%EF%BC%89"><span class="toc-number">1.1.2.</span> <span class="toc-text">2.什么是Drawcall（绘画调用）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Profile%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%99%A8"><span class="toc-number">1.1.3.</span> <span class="toc-text">3.Profile性能分析器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%A6%82%E4%BD%95%E7%94%A8%E5%88%86%E6%9E%90%E5%99%A8%E5%88%86%E6%9E%90%E6%8C%87%E5%AE%9A%E4%B8%80%E6%AE%B5%E4%BB%A3%E7%A0%81%EF%BC%9F"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">(1) 如何用分析器分析指定一段代码？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%B0%83%E7%94%A8%E6%A0%88%EF%BC%88Call-Stack%EF%BC%89"><span class="toc-number">1.1.4.</span> <span class="toc-text">4.调用栈（Call Stack）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E6%89%98%E7%AE%A1%E5%86%85%E5%AD%98"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">（1）托管内存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E9%9D%9E%E6%89%98%E7%AE%A1%E5%86%85%E5%AD%98"><span class="toc-number">1.1.4.2.</span> <span class="toc-text">（2）非托管内存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89DOTS%E7%AE%80%E4%BB%8B"><span class="toc-number">1.1.4.3.</span> <span class="toc-text">（3）DOTS简介</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E8%AE%BE%E7%BD%AE%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%99%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B1%9E%E6%80%A7"><span class="toc-number">1.1.5.</span> <span class="toc-text">5.设置性能分析器的一些属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-CPU-Usage%E6%A8%A1%E5%9D%97"><span class="toc-number">1.1.6.</span> <span class="toc-text">6. CPU Usage模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-Frame-Debugger"><span class="toc-number">1.1.7.</span> <span class="toc-text">7.Frame Debugger</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E3%80%81Memory-Profiler"><span class="toc-number">1.1.8.</span> <span class="toc-text">8、Memory Profiler</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%E3%80%81Physics-Debugger%E7%AA%97%E5%8F%A3"><span class="toc-number">1.1.9.</span> <span class="toc-text">9、Physics Debugger窗口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10%E3%80%81Import-Activity%E7%AA%97%E5%8F%A3"><span class="toc-number">1.1.10.</span> <span class="toc-text">10、Import Activity窗口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E3%80%81Code-Coverage%E7%AA%97%E5%8F%A3"><span class="toc-number">1.1.11.</span> <span class="toc-text">11 、Code Coverage窗口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E9%9D%99%E6%80%81%E6%89%B9%E5%A4%84%E7%90%86"><span class="toc-number">1.2.</span> <span class="toc-text">二、静态批处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%99%E6%80%81%E6%89%B9%E5%A4%84%E7%90%86"><span class="toc-number">1.2.1.</span> <span class="toc-text">1.什么是静态批处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E9%9D%99%E6%80%81%E6%89%B9%E5%A4%84%E7%90%86"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.如何进行静态批处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%9D%99%E6%80%81%E6%89%B9%E5%A4%84%E7%90%86%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.2.3.</span> <span class="toc-text">3.静态批处理的注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%80%9D%E8%80%83unity%E5%85%89%E7%85%A7%E4%BC%9A%E5%BD%B1%E5%93%8D%E9%9D%99%E6%80%81%E6%89%B9%E5%A4%84%E7%90%86%E5%90%97"><span class="toc-number">1.2.4.</span> <span class="toc-text">4.思考unity光照会影响静态批处理吗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%9C%A8%E6%B8%B8%E6%88%8F%E8%BF%90%E8%A1%8C%E6%97%B6%E8%BF%9B%E8%A1%8C%E9%9D%99%E6%80%81%E5%90%88%E6%89%B9-%E7%94%A8%E7%9A%84%E5%B0%91"><span class="toc-number">1.2.5.</span> <span class="toc-text">5.在游戏运行时进行静态合批(用的少)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%8A%A8%E6%80%81%E6%89%B9%E5%A4%84%E7%90%86"><span class="toc-number">1.3.</span> <span class="toc-text">三、动态批处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%8A%A8%E6%80%81%E6%89%B9%E5%A4%84%E7%90%86"><span class="toc-number">1.3.1.</span> <span class="toc-text">1.什么是动态批处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%A6%82%E4%BD%95%E5%B0%86%E8%BF%9B%E8%A1%8C%E5%8A%A8%E6%80%81%E6%89%B9%E5%A4%84%E7%90%86"><span class="toc-number">1.3.2.</span> <span class="toc-text">2.如何将进行动态批处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%8A%A8%E6%80%81%E6%89%B9%E5%A4%84%E7%90%86%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.3.3.</span> <span class="toc-text">3.动态批处理的注意事项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81GPU-Instancing"><span class="toc-number">1.4.</span> <span class="toc-text">四、GPU Instancing</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AFGPU-Instancing"><span class="toc-number">1.4.1.</span> <span class="toc-text">1.什么是GPU Instancing</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%A6%82%E6%9E%9C%E5%90%AF%E7%94%A8GPU-Instancing"><span class="toc-number">1.4.2.</span> <span class="toc-text">2.如果启用GPU Instancing</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-GPU-Instancing%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.4.3.</span> <span class="toc-text">3.GPU Instancing注意事项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E9%81%AE%E6%8C%A1%E5%89%94%E9%99%A4"><span class="toc-number">1.5.</span> <span class="toc-text">五、遮挡剔除</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1"><span class="toc-number">1.5.1.</span> <span class="toc-text">1.</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/C-%E8%BF%9B%E9%98%B6/%E5%85%AB%E8%82%A1%E6%96%87/Csharp%E8%BF%9B%E9%98%B6%E4%B9%8B%E9%87%8D%E8%A6%81%E8%AF%BE%E7%A8%8B%E8%A1%A5%E5%85%85/" title="C#进阶之重要知识点补充">C#进阶之重要知识点补充</a><time datetime="2025-04-16T03:08:27.574Z" title="发表于 2025-04-16 11:08:27">2025-04-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/Unity/%E5%B0%8F%E6%A1%86%E6%9E%B6/%E3%80%8A%E5%94%90%E8%80%81%E5%B8%88%E5%9F%BA%E7%A1%80%E5%B0%8F%E6%A1%86%E6%9E%B6%E8%A7%A3%E6%9E%90%E4%B8%8E%E4%BB%A3%E7%A0%81%E3%80%8B/" title="Unity小框架">Unity小框架</a><time datetime="2025-04-15T11:54:13.381Z" title="发表于 2025-04-15 19:54:13">2025-04-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/C-%E8%BF%9B%E9%98%B6/%E5%85%AB%E8%82%A1%E6%96%87/Csharp%E8%BF%9B%E9%98%B6%E4%B9%8B%E7%9F%A5%E8%AF%86%E7%82%B9%E6%8B%93%E5%B1%95/" title="C#进阶之知识点拓展">C#进阶之知识点拓展</a><time datetime="2025-04-14T11:32:53.100Z" title="发表于 2025-04-14 19:32:53">2025-04-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/Unity/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/Unity%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" title="Unity性能优化">Unity性能优化</a><time datetime="2025-04-14T11:08:10.016Z" title="发表于 2025-04-14 19:08:10">2025-04-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/uncategorized/hello-world/" title="Hello World">Hello World</a><time datetime="2025-04-14T07:48:41.942Z" title="发表于 2025-04-14 15:48:41">2025-04-14</time></div></div></div></div></div></div></main><footer id="footer" style="background: linear-gradient(135deg,#1a1a1a 0%,#2c3e50 40%,#34495e 60%,#2980b9 80%,#1a1a1a 100%);"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By wqx</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>