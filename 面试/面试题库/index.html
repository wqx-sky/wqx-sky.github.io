<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>面试题库 | 游戏开发笔记</title><meta name="author" content="wqx"><meta name="copyright" content="wqx"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="C#相关 1. 装箱和拆箱是指什么？  解析查看  1.装箱——把栈中内容迁移到堆中去（值转引用） 2.装箱——把堆中内容迁移到栈中去（引用转值） 3.如果问到值类型和引用类型同样，要引申这个    2. 值和引用类型在变量赋值时的区别是什么？  解析查看  1.值类型在赋值时只是把数据值复制过去，值类型数据值具有独立性 2.引用类型在赋值时复制的是引用（地址），一这意味着两个变量指向同一个对象，">
<meta property="og:type" content="article">
<meta property="og:title" content="面试题库">
<meta property="og:url" content="http://wqxblog.top/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/index.html">
<meta property="og:site_name" content="游戏开发笔记">
<meta property="og:description" content="C#相关 1. 装箱和拆箱是指什么？  解析查看  1.装箱——把栈中内容迁移到堆中去（值转引用） 2.装箱——把堆中内容迁移到栈中去（引用转值） 3.如果问到值类型和引用类型同样，要引申这个    2. 值和引用类型在变量赋值时的区别是什么？  解析查看  1.值类型在赋值时只是把数据值复制过去，值类型数据值具有独立性 2.引用类型在赋值时复制的是引用（地址），一这意味着两个变量指向同一个对象，">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://skymirror-1316984539.cos.ap-beijing.myqcloud.com/Typoramimi.jpg">
<meta property="article:published_time" content="2025-05-10T07:30:06.000Z">
<meta property="article:modified_time" content="2025-07-31T15:02:13.152Z">
<meta property="article:author" content="wqx">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://skymirror-1316984539.cos.ap-beijing.myqcloud.com/Typoramimi.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "面试题库",
  "url": "http://wqxblog.top/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/",
  "image": "https://skymirror-1316984539.cos.ap-beijing.myqcloud.com/Typoramimi.jpg",
  "datePublished": "2025-05-10T07:30:06.000Z",
  "dateModified": "2025-07-31T15:02:13.152Z",
  "author": [
    {
      "@type": "Person",
      "name": "wqx",
      "url": "http://wqxblog.top/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://wqxblog.top/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '面试题库',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background: linear-gradient(135deg,#1a1a1a 0%,#2c3e50 25%,#34495e 45%,#2980b9 80%,#1a1a1a 100%);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="https://skymirror-1316984539.cos.ap-beijing.myqcloud.com/Typoramimi.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">23</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">19</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background: linear-gradient(135deg,#1a1a1a 0%,#2c3e50 40%,#34495e 60%,#2980b9 80%,#1a1a1a 100%);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">游戏开发笔记</span></a><a class="nav-page-title" href="/"><span class="site-name">面试题库</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">面试题库</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-05-10T07:30:06.000Z" title="发表于 2025-05-10 15:30:06">2025-05-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-07-31T15:02:13.152Z" title="更新于 2025-07-31 23:02:13">2025-07-31</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">6.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>21分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="C-相关"><a href="#C-相关" class="headerlink" title="C#相关"></a>C#相关</h1><hr>
<h2 id="1-装箱和拆箱是指什么？"><a href="#1-装箱和拆箱是指什么？" class="headerlink" title="1. 装箱和拆箱是指什么？"></a>1. 装箱和拆箱是指什么？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">1.装箱——把栈中内容迁移到堆中去（值转引用）</span>
<span style="color: red;">2.装箱——把堆中内容迁移到栈中去（引用转值）</span>
3.如果问到值类型和引用类型同样，要引申这个
</code></pre>
</details></blockquote>
<hr>
<h2 id="2-值和引用类型在变量赋值时的区别是什么？"><a href="#2-值和引用类型在变量赋值时的区别是什么？" class="headerlink" title="2. 值和引用类型在变量赋值时的区别是什么？"></a>2. 值和引用类型在变量赋值时的区别是什么？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">1.值类型在赋值时只是把数据值复制过去，值类型数据值具有独立性</span>
<span style="color: red;">2.引用类型在赋值时复制的是引用（地址），一这意味着两个变量指向同一个对象，对其中一个变量进行修改也会影响到另外一个变量。</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="3-委托和事件在使用上的区别是什么？"><a href="#3-委托和事件在使用上的区别是什么？" class="headerlink" title="3.  委托和事件在使用上的区别是什么？"></a>3.  委托和事件在使用上的区别是什么？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">1.委托可以在外部调用，但是事件不能在外部直接调用，只能通过+=或者-=来取消/订阅事件</span>
<span style="color: red;">2.想要调用必须在类内部再封装一个方法来调用事件</span>
<span style="color: red;">3.事件不能在外部直接赋值，但是委托可以</span>
</code></pre>
</details></blockquote>
<blockquote>
<details>
<summary>代码查看</summary>
<pre><code>
public class Publisher 
&#123;
public event NotificationHandler Notify; // 封装为事件
public void SendMessage(string msg)
 &#123;
    Notify?.Invoke(msg); // 安全触发事件
&#125;
&#125;
// 外部代码只能订阅/取消订阅
var publisher = new Publisher();
publisher.Notify += (msg) => &#123; Console.WriteLine(msg); &#125;;
publisher.Notify -= ...; // 无法直接清空事件
</code></pre>
</details></blockquote>
<hr>
<h2 id="4-有两个接口IA和IB，他们中有一个同名方法Test-一个类同时继承这两个接口，应该如何处理他们的同名方法？"><a href="#4-有两个接口IA和IB，他们中有一个同名方法Test-一个类同时继承这两个接口，应该如何处理他们的同名方法？" class="headerlink" title="4. 有两个接口IA和IB，他们中有一个同名方法Test()一个类同时继承这两个接口，应该如何处理他们的同名方法？"></a>4. 有两个接口IA和IB，他们中有一个同名方法Test()一个类同时继承这两个接口，应该如何处理他们的同名方法？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">显示实现接口
IA.Test()
IB.Test()</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="5-请说明C-中的List是如何扩容的"><a href="#5-请说明C-中的List是如何扩容的" class="headerlink" title="5. 请说明C#中的List是如何扩容的"></a>5. 请说明C#中的List是如何扩容的</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">List的底层实现是使用数组</span>
<span style="color: red;">当List容量不足的时候，他会重新再开辟一个大内存，数组大小通常会扩大一倍，并将现有元素复制到新数组</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="6-请说说你认为C-中-和-Equals-的区别是什么？"><a href="#6-请说说你认为C-中-和-Equals-的区别是什么？" class="headerlink" title="6.请说说你认为C#中 &#x3D;&#x3D; 和 Equals 的区别是什么？"></a>6.请说说你认为C#中 &#x3D;&#x3D; 和 Equals 的区别是什么？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">1. == 是运算符，Equals是万物之父Object中的虚方法，子类可以重写</span>
<span style="color: red;">2.Equals 一般再子类中重写后用于比较两个对象中的内容是否相同
	==在没有运算符重载的前提下时
	引用类型用于比较地址；值类型用于比较值是否相同
3.运算效率不同，一般Equals没有==效率高，因为一般Equals比较的内容比==读多
</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="7-浅拷贝和深拷贝的区别？"><a href="#7-浅拷贝和深拷贝的区别？" class="headerlink" title="7. 浅拷贝和深拷贝的区别？"></a>7. 浅拷贝和深拷贝的区别？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">浅拷贝：
	只是复制对象的引用地址
</span><span style="color: red;">深拷贝：
	计算机在内存上重新开辟了一个空间，把对象的引用地址和值圈复制过来，两个对象是独立存在的。
</span>举例：
	比如引用对象A和引用对象B
	让A = B，就是浅拷贝，此时A、B的引用地址相同，改A中内容，B也变
	如果想要深拷贝，简单处理就是new（包括对象中的成员）
</code></pre>
</details></blockquote>
<hr>
<h2 id="8-上面两种获10000个数的方式，哪种效率更高？为什么"><a href="#8-上面两种获10000个数的方式，哪种效率更高？为什么" class="headerlink" title="8. 上面两种获10000个数的方式，哪种效率更高？为什么"></a>8. 上面两种获10000个数的方式，哪种效率更高？为什么</h2><blockquote>
<p><img src="https://skymirror-1316984539.cos.ap-beijing.myqcloud.com/Typoraimage-20250731202257832.png" alt="image-20250731202257832"></p>
</blockquote>
<blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">方式2的效率更高
因为List本质是数组，我们通过Add往List中添加元素时，会不断的触发扩容
扩容会带来内存和性能上的消耗
内存方面：每次扩容会产生垃圾，还会造成GC的触发
性能方面：每次扩容会进行“搬家”（老数组中内容存入新数组中）</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="9-请说出以上代码：1-A处和B处谁先打印？-2-A、B出打印的i值分别是多少？"><a href="#9-请说出以上代码：1-A处和B处谁先打印？-2-A、B出打印的i值分别是多少？" class="headerlink" title="9. 请说出以上代码：1.A处和B处谁先打印？ 2. A、B出打印的i值分别是多少？"></a>9. 请说出以上代码：1.A处和B处谁先打印？ 2. A、B出打印的i值分别是多少？</h2><blockquote>
<img src="https://skymirror-1316984539.cos.ap-beijing.myqcloud.com/Typoraimage-20250731202607327.png" alt="image-20250731202607327" style="zoom: 67%;" /></blockquote>
<blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
1.B处先打印，A处后打印
2.A处 i = 10，B处 i = 11</span>
<span style="color: red;">解析：
try → catch（如果有异常） → finally
</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="10-泛型的约束有哪几种？"><a href="#10-泛型的约束有哪几种？" class="headerlink" title="10.泛型的约束有哪几种？"></a>10.泛型的约束有哪几种？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
1.值类型约束 T:struct
2.引用类型约束 T:class
3.公共无参构造约束 T:new()
4.类约束 T:类名
5.接口约束 T:接口名
6.另一个泛型约束 T:U</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="11-什么是闭包？可以举例说明"><a href="#11-什么是闭包？可以举例说明" class="headerlink" title="11 . 什么是闭包？可以举例说明"></a>11 . 什么是闭包？可以举例说明</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">闭包是指有权访问另一个函数作用域中的变量的函数
所以闭包一般都是指的一个函数
创建这种特殊闭包函数的方式往往是在一个函数中创建另一个函数</span>
</code></pre>
</details></blockquote>
<h2 id="12-内存泄漏指什么？常见的内存泄漏有哪些？"><a href="#12-内存泄漏指什么？常见的内存泄漏有哪些？" class="headerlink" title="12 . 内存泄漏指什么？常见的内存泄漏有哪些？"></a>12 . 内存泄漏指什么？常见的内存泄漏有哪些？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">内存泄漏是指某些对象废弃了，不想使用了，但是不能被GC垃圾回收，一直占用者内存</span>
<span style="color: red;">常见的内存泄漏有：
1.静态引用
2.不使用的引用对象没有置null，一直被引用
3.文件操作时，没有使用using或者没有进行Dispose()
4.委托或事件注册后没有解除注册（有加就有减）</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="13-序列化是什么？常见的序列化方式有哪些？什么时候我们会用到序列化？"><a href="#13-序列化是什么？常见的序列化方式有哪些？什么时候我们会用到序列化？" class="headerlink" title="13. 序列化是什么？常见的序列化方式有哪些？什么时候我们会用到序列化？"></a>13. 序列化是什么？常见的序列化方式有哪些？什么时候我们会用到序列化？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
	序列化是将程序中数据对象转换为可以存储或传输的形式 的过程。
举例：
比如我们常见的序列化方式 xml、Json、2进制等。就是将内存中的数据按照我们自己定义的规则进行序列化，序列化之后就可以用于存储和传输，当读取和接受数据时，只需要按照对应规则进行反序列化便可得到原始数据
所谓的存储读取和传输接受，其实一般指的就是数据持久化和网络通讯
所以我们经常会在这两块知识点看到序列化反序列化这两个关键词</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="14-请说明以下三者的区别"><a href="#14-请说明以下三者的区别" class="headerlink" title="14. 请说明以下三者的区别"></a>14. 请说明以下三者的区别</h2><blockquote>
<p>string str &#x3D; null<br>string str &#x3D; “”<br>string str &#x3D; string.Empty</p>
</blockquote>
<blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
str = null 在堆中没有分配内存地址
str = "" 和 string.Empty 一样都是在堆内存中分配了空间，里面存储的是空字符串
而string.Empty是一个静态只读变量</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="15-C-重载运算符，重载-和-以及-万物之父Object基类中的虚方法-virtual-bool-Equals-Object-obj-对于我们的意义是什么？"><a href="#15-C-重载运算符，重载-和-以及-万物之父Object基类中的虚方法-virtual-bool-Equals-Object-obj-对于我们的意义是什么？" class="headerlink" title="15. C#重载运算符，重载 &#x3D;&#x3D; 和 !&#x3D; 以及 万物之父Object基类中的虚方法 virtual bool Equals(Object obj)对于我们的意义是什么？"></a>15. C#重载运算符，重载 &#x3D;&#x3D; 和 !&#x3D; 以及 万物之父Object基类中的虚方法 virtual bool Equals(Object obj)对于我们的意义是什么？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">1.重载== 和！=
	因为默认== 和！=对于引用类型是判断对象引用是否相等
	重写这个可以自定义判断对象里面的值，而不是引用
</span>
<span style="color: red;">2.重载 Equals
	如果想保留判断引用地址（保留==）相等，就重写Equals
</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="16-在开发时，对string和StringBuilder我们应该如何选择"><a href="#16-在开发时，对string和StringBuilder我们应该如何选择" class="headerlink" title="16.在开发时，对string和StringBuilder我们应该如何选择"></a>16.在开发时，对string和StringBuilder我们应该如何选择</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
string在每次拼接时都会产生垃圾
而StringBuilder在拼接时，是在原空间中进行修改，不会产生垃圾，会自动帮助我们扩容
所以当字符串需要频繁修改拼接时，我们使用StringBuilder</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="17-请简要说明-Net跨语言原理"><a href="#17-请简要说明-Net跨语言原理" class="headerlink" title="17. 请简要说明.Net跨语言原理"></a>17. 请简要说明.Net跨语言原理</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
.Net制定了了CLI公共语言基础结构的规则
只要是按照该规则设计的语言在进行.Net相关开发时
编译器会将源代码（C#、VB等等）编译为CIL通用中间代码。
也就是说不管什么语言进行开发，最终都会统一规范变为中间代码
最终通过CLR（公共语言运行时或者称为.Net虚拟）将中间代码翻译为对应操作系统的原生代码（机器码）
在操作系统（Windows）上运行</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="18-请简要说明-Net跨平台原理"><a href="#18-请简要说明-Net跨平台原理" class="headerlink" title="18. 请简要说明.Net跨平台原理"></a>18. 请简要说明.Net跨平台原理</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
由于.Net Framework中利用CLI和CLR实现了跨语言，CLR主要起到一个翻译、运行、管理中间代码的作用
.Net Core和Mono就是利用了CLR的这一特点，为不同操作系统实现对应CLR（公共语言运行时或.Net虚拟机）
那么不同操作系统对应的CLR就会将IL中间代码翻译为对应系统可以执行的原生代码（机器码）
达到跨平台的目的</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="19-数组和链表的区别是什么？"><a href="#19-数组和链表的区别是什么？" class="headerlink" title="19. 数组和链表的区别是什么？"></a>19. 数组和链表的区别是什么？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
1.存储结构不同
数组是顺序存储结构，在内存中是连续存储的
链表是链式存储结构，在内存中是非连续存储的
-----------------------------------------------------------
2.访问效率不同
数组由于是顺序存储，通过下标访问，访问效率高
链表由于是非连续存储，我们想要获取其中某一元素，需要从头或尾遍历，效率低
------------------------------------------------------------
3.插入、删除效率不同
数组由于是顺序存储，在插入和删除时，需要整体移动数组中的大部分元素，效率低
链表由于是链式存储，在插入和删除时，效率高
---------------------------------------------------------------
4.越界问题
数组由于是顺序存储，声明时容量是固定的，如果不处理扩容逻辑，存在越界风险
链表由于是链式存储，无越界风险</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="20-C-中的Action和Func是什么？Unity-中的UnityAction是什么？他们有什么区别？"><a href="#20-C-中的Action和Func是什么？Unity-中的UnityAction是什么？他们有什么区别？" class="headerlink" title="20. C# 中的Action和Func是什么？Unity 中的UnityAction是什么？他们有什么区别？"></a>20. C# 中的Action和Func是什么？Unity 中的UnityAction是什么？他们有什么区别？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
Action和Func是System命名空间下 C#为我们提供的两个写好的委托
Action本身是一个无参无返回值的委托
对应的Action<>泛型委托支持最多16个参数
-------------------------------------------
Func本身是一个无参有返回值的委托
对应的Func<>泛型委托支持最多16个参数，并且有返回值
------------------------------------------------
UnityAction是UnityEngine.Events命名空间下 Unity为我们提供的写好的委托
UnityAction本身是一个无参无返回值的委托
对应的UnityAction<>泛型委托支持最多4个参数</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="21-（结构体中的引用类型）请问最终得到打印结果是什么？？"><a href="#21-（结构体中的引用类型）请问最终得到打印结果是什么？？" class="headerlink" title="21. （结构体中的引用类型）请问最终得到打印结果是什么？？"></a>21. （结构体中的引用类型）请问最终得到打印结果是什么？？</h2><blockquote>
<img src="https://skymirror-1316984539.cos.ap-beijing.myqcloud.com/Typoraimage-20250731223017846.png" alt="image-20250731223017846" style="zoom: 50%;" />

<img src="https://skymirror-1316984539.cos.ap-beijing.myqcloud.com/Typoraimage-20250731223029521.png" alt="image-20250731223029521" style="zoom:50%;" />

<img src="https://skymirror-1316984539.cos.ap-beijing.myqcloud.com/Typoraimage-20250731223037047.png" alt="image-20250731223037047" style="zoom: 50%;" /></blockquote>
<blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
0-Alice-7
考点：
1.值和引用的区别
2.特殊引用类型string
3.结构体中的引用成员</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="22-C-中如何让自定义容器类能够使用for循环遍历？（通过-类对象-索引-的形式遍历）"><a href="#22-C-中如何让自定义容器类能够使用for循环遍历？（通过-类对象-索引-的形式遍历）" class="headerlink" title="22. C#中如何让自定义容器类能够使用for循环遍历？（通过 类对象[索引] 的形式遍历）"></a>22. C#中如何让自定义容器类能够使用for循环遍历？（通过 类对象[索引] 的形式遍历）</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
通过在类中实现索引器实现</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="23-C-中如何让自定义容器类能够使用foreach循环遍历？"><a href="#23-C-中如何让自定义容器类能够使用foreach循环遍历？" class="headerlink" title="23. C#中如何让自定义容器类能够使用foreach循环遍历？"></a>23. C#中如何让自定义容器类能够使用foreach循环遍历？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
通过为该类实现迭代器可以让其使用foreach遍历
传统方式：
继承IEnumerator、IEnumerable两个接口
实现其中的 
1.GetEnumerator方法
2.Current属性
3.MoveNext方法
语法糖方式：
利用yield return语法糖，实现GetEnumerator方法即可完成迭代器的实现</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="24-C-中接口的作用是什么？说说你的理解"><a href="#24-C-中接口的作用是什么？说说你的理解" class="headerlink" title="24. C#中接口的作用是什么？说说你的理解"></a>24. C#中接口的作用是什么？说说你的理解</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
用于建立行为的继承关系，而不是对象
不同对象，有相同行为时，我们可以利用接口对不同对象的行为进行整合（里氏替换原则）</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="25-请问以上这三行代码，运行后，在堆上会分配几个“房间”"><a href="#25-请问以上这三行代码，运行后，在堆上会分配几个“房间”" class="headerlink" title="25. 请问以上这三行代码，运行后，在堆上会分配几个“房间”"></a>25. 请问以上这三行代码，运行后，在堆上会分配几个“房间”</h2><blockquote>
<img src="https://skymirror-1316984539.cos.ap-beijing.myqcloud.com/Typoraimage-20250731224718174.png" alt="image-20250731224718174" style="zoom:33%;" /></blockquote>
<blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
2个房间
"123"一个房间
"1234"一个房间</span>
</code></pre>
</details></blockquote>
<hr>
<h1 id="Unity相关"><a href="#Unity相关" class="headerlink" title="Unity相关"></a>Unity相关</h1><hr>
<h2 id="1-Unity中点乘和叉乘对于我们来说的作用是什么？"><a href="#1-Unity中点乘和叉乘对于我们来说的作用是什么？" class="headerlink" title="1. Unity中点乘和叉乘对于我们来说的作用是什么？"></a>1. Unity中点乘和叉乘对于我们来说的作用是什么？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">点乘：
1.可以判断对象的方位（前后），用我们的正朝向和指向对方的向量点乘。大于0就是后面，小于0就是前面。
2.还可以得到两向量之间的夹角
</span>
<span style="color: red;">叉乘：
1.获得一个平面的法向量
2.得到两个向量之间的左右位置关系
</span>
注：Unity中用的是左手坐标系，所以确定方向的时候我们要用左手法则，最后得到的方向正好与右手法则相反
</code></pre>
</details></blockquote>
<hr>
<h2 id="2-Unity中多线程执行下面哪些代码会报错？"><a href="#2-Unity中多线程执行下面哪些代码会报错？" class="headerlink" title="2. Unity中多线程执行下面哪些代码会报错？"></a>2. Unity中多线程执行下面哪些代码会报错？</h2><p>A. Application.persistentDataPath<br>B. File.Exists(“文件名”)<br>C. transform.Translate<br>D. Object.Destroy(对象)</p>
<blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">A、C、D</span>
<span style="color: red;">UnityEngine命名空间中相关类基本都不能被Unity多线程使用</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="3-Application-streamingAssetsPath-和-Application-persistentDataPath两个路径有何区别？对于我们的意义是什么？"><a href="#3-Application-streamingAssetsPath-和-Application-persistentDataPath两个路径有何区别？对于我们的意义是什么？" class="headerlink" title="3. Application.streamingAssetsPath 和 Application.persistentDataPath两个路径有何区别？对于我们的意义是什么？"></a>3. Application.streamingAssetsPath 和 Application.persistentDataPath两个路径有何区别？对于我们的意义是什么？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">Application.streamingAssetsPath只读</span>
<span style="color: red;">Application.persistentDataPath 可读可写
-------------------------------------------------------------------
Application.streamingAssetsPath适合防止一些默认的2进制配置文件，用来读取初始化的数据
Application.persistentDataPath 用于处理数据持久化 ，或者作为热更新下载内容的存放目录
</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="4-请简述Unity中协程的原理。"><a href="#4-请简述Unity中协程的原理。" class="headerlink" title="4. 请简述Unity中协程的原理。"></a>4. 请简述Unity中协程的原理。</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">
1.协程不是线程，Unity中的协程主要由迭代器实现，迭代器的原理是状态机
2.Unity协程主要是分成两个部分：协程函数和协程调度器。
  	协程函数会根据迭代器函数进行分布执行，遇到yiled return 再将程序挂起，去执行其他内容
  	挂起的函数一般在Update和LateUpdate 之间执行
  	协程调度器则则对协程函数进行统一管理
</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="5-Unity底层如何处理C-代码"><a href="#5-Unity底层如何处理C-代码" class="headerlink" title="5. Unity底层如何处理C#代码"></a>5. Unity底层如何处理C#代码</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">
1. Mono
	C#代码在项目发布时，会被编译成IL中间代码，最后这些中间代码会通过Mono虚拟机被编译成各大操作系统的机器码
2.IL2CPP
	把IL中间代码转译为C++代码，再通过各平台的C++编译器直接编译为可执行的原生汇编代码。
</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="6-Unity中当一个细小高速物体撞击另一个较大物体时会出现什么情况？如何避免？"><a href="#6-Unity中当一个细小高速物体撞击另一个较大物体时会出现什么情况？如何避免？" class="headerlink" title="6. Unity中当一个细小高速物体撞击另一个较大物体时会出现什么情况？如何避免？"></a>6. Unity中当一个细小高速物体撞击另一个较大物体时会出现什么情况？如何避免？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">会出现穿模</span>
<span style="color: red;">1.我们可以尽量用射线检测来替代细小物体的物理系统碰撞
因为传统的FPS游戏都是通过射线检测加模拟计算来判断伤害的
2.修改Rigidbody刚体中的Interpolate（插值）和CollisionDetection（碰撞检测）两个参数，来提高碰撞检测的准确性</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="7-请简述一下Prefab（预制体）的本质是什么？"><a href="#7-请简述一下Prefab（预制体）的本质是什么？" class="headerlink" title="7. 请简述一下Prefab（预制体）的本质是什么？"></a>7. 请简述一下Prefab（预制体）的本质是什么？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">Prefab的本质就是一个配置文件
其中记录了一个GameObject对象上挂载的脚本信息
并且记录了脚本信息中的可配置的属性信息</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="8-Unity是否支持写成多线程程序？如果支持的话需要注意什么？"><a href="#8-Unity是否支持写成多线程程序？如果支持的话需要注意什么？" class="headerlink" title="8. Unity是否支持写成多线程程序？如果支持的话需要注意什么？"></a>8. Unity是否支持写成多线程程序？如果支持的话需要注意什么？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
	支持</span>
<span style="color: red;">注意：
1.只能从主线程访问Unity相关组件、对象以及
UnityEngine命名空间中的绝大部分内容
2.如果多线程中要和Unity主线程同时修改一些数据
可以通过lock关键词加锁</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="9-请简述一下对象池实现原理，在游戏开发中我们什么时候会用到它？"><a href="#9-请简述一下对象池实现原理，在游戏开发中我们什么时候会用到它？" class="headerlink" title="9. 请简述一下对象池实现原理，在游戏开发中我们什么时候会用到它？"></a>9. 请简述一下对象池实现原理，在游戏开发中我们什么时候会用到它？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">1.我们把不用的对象放入对象池中失活，下次需要用到对象的失活再从对象池中取。线程池也是同样的原理</span>
<span style="color: red;">2.在游戏中频繁创建对象、实例化对象的地方，都可以用到对象池。
比如前端开发中，游戏中的子弹、伤害字体、特效等等
比如后端开发中线程池等等
3.对象池的作用就是：
	避免大量创建对象再销毁对象时造成内存的消耗而引发GC。
</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="10-什么是DrawCall？DrawCall为什么会影响游戏运行效率？"><a href="#10-什么是DrawCall？DrawCall为什么会影响游戏运行效率？" class="headerlink" title="10 .什么是DrawCall？DrawCall为什么会影响游戏运行效率？"></a>10 .什么是DrawCall？DrawCall为什么会影响游戏运行效率？</h2><p>如何减少DrawCall？</p>
<blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">1.CPU向GPU发送的一次渲染命令</span>
<span style="color: red;">2.DrawCall次数高，Cpu就要话更多的时间取准备渲染数据，这其中会进行更多的计算，进而影响游戏运行的效率。当每帧需要提交数千个DrawCall时，CPU可能忙于处理命令提交，会出现Cpu过载，而GPU因等待数据空闲</span>
3. 如何减少DrawCall？
	2D和UI层面：打图集，注意面板中不同图集照片的层级不要穿插
	3D层面：使用动态批处理和静态批处理，尽量不要使用实时光照
</code></pre>
</details></blockquote>
<hr>
<h2 id="11-transform-forward和Vector3-forword的区别"><a href="#11-transform-forward和Vector3-forword的区别" class="headerlink" title="11. transform.forward和Vector3.forword的区别"></a>11. transform.forward和Vector3.forword的区别</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
Vector3.forword始终时(0,0,1)
可以认为是世界坐标系的Z轴朝向
transform.forword是当前物体的局部坐标系的Z轴在世界坐标系下的朝向
可以认为是物体自己的Z轴朝向</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="12-Unity中如何解决过多创建和删除对象带来的卡顿问题？"><a href="#12-Unity中如何解决过多创建和删除对象带来的卡顿问题？" class="headerlink" title="12. Unity中如何解决过多创建和删除对象带来的卡顿问题？"></a>12. Unity中如何解决过多创建和删除对象带来的卡顿问题？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
	可以通过协同程序，分时分步创建或删除
原理是避免一帧中处理太多对象</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="13-游戏中的成就系统，我们一般会使用设计模式中的哪种模式来制作？为什么？"><a href="#13-游戏中的成就系统，我们一般会使用设计模式中的哪种模式来制作？为什么？" class="headerlink" title="13. 游戏中的成就系统，我们一般会使用设计模式中的哪种模式来制作？为什么？"></a>13. 游戏中的成就系统，我们一般会使用设计模式中的哪种模式来制作？为什么？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
观察者模式
Unity基础小框架中讲解的 事件中心 就是基于观察者模式的
是一种订阅通知机制</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="14-请简述热更新的流程"><a href="#14-请简述热更新的流程" class="headerlink" title="14. 请简述热更新的流程"></a>14. 请简述热更新的流程</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
本地存在资源对比文件和已有资源
1.下载资源服务器中的对比文件
2.将下载下来的远端对比文件和本地的做对比
   记录需要更新的资源和要移除的资源
3.根据第二步中记录的信息，进行资源下载和移除
4.更新本地对比文件，其内容和刚才下载的远端对比文件一致</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="15-我们应该如何优化UI（基于UGUI）"><a href="#15-我们应该如何优化UI（基于UGUI）" class="headerlink" title="15. 我们应该如何优化UI（基于UGUI）"></a>15. 我们应该如何优化UI（基于UGUI）</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
性能上
1.打图集，将同一画面的图片放入一个图集中，目的是减少DrawCall
2.面板中的图片和文字尽量不要交叉，因为这样会产生多余的DrawCall
3.取消勾选不必要的射线检测，UI组件上的
4.减少透明图片的重叠使用
5.UI动静分离
	因为UI本质就是mash网格，UI内部为了优化会把符合规则的ui网格进行合并。
	而每一次UI动（比如：放大缩小）就要重新合并
	那么如何分离？
	将会动的UI放在另一个画布上，不动的UI留在原来的节点。
	这样UI在动的时候，不会影响到不动UI的网格合并
等等
内存上
1.大图尽量使用9宫格缩放，让美术设计UI面板底图时不要过于复杂
尽量是有规律的纹理和颜色变化
2.图片的RGBA通道分离
等等</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="16-Unity中的Destroy和DestroyImmediate的区别是什么？"><a href="#16-Unity中的Destroy和DestroyImmediate的区别是什么？" class="headerlink" title="16. Unity中的Destroy和DestroyImmediate的区别是什么？"></a>16. Unity中的Destroy和DestroyImmediate的区别是什么？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
Destroy方法
可以指定删除的延迟时间，如果第二个参数不填写，最快也会在下一帧前完成删除。也就是如果Destroy对象后马上判空，该对象不会为空。
实际的对象销毁操作始终延迟到当前更新循环结束，但始终在渲染前完成
DestroyImmediate方法
会立即销毁删除对象（不会自动滞空，需要自己滞空）</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="17-第一次执行GameObject-Instantiate时可能出现明显的卡顿如何解决该问题？"><a href="#17-第一次执行GameObject-Instantiate时可能出现明显的卡顿如何解决该问题？" class="headerlink" title="17. 第一次执行GameObject.Instantiate时可能出现明显的卡顿如何解决该问题？"></a>17. 第一次执行GameObject.Instantiate时可能出现明显的卡顿如何解决该问题？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
我们可以通过Unity自带的性能分析工具Profiler分析实例化时造成卡顿的原因
程序上，一般我们可以从以下3个方面去优化它
1.相关资源加载：如果是由于资源加载带来的卡顿，我们可以在进入场景时进行资源预加载，总体思路就是将较大资源提前或者分帧加载
------------------------------------
2.脚本初始化：实例化对象时，会同步执行它身上挂载所有脚本的初始化工作，我们可以策略性的改变一些初始化逻辑，尽量不要再Awake和Start中做较复杂的逻辑，或者将复杂逻辑提前或者分帧处理
------------------------------------
3.对于会频繁使用的对象，我们可以使用缓存池
------------------------------------
美术上
不能只追求好的美术效果，而不考虑资源的消耗，要根据项目的实际情况，来设定模型的骨骼数、面数以及贴图的数量和大小上限。
在制作粒子特效时，粒子数、粒子面积、贴图等都要尽量少和小。
美术上要遵循：用最少的资源做出做好的效果，不能一味的用性能去换效果，最终会得不偿失</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="18-Unity使用IL2CPP打包时，我们应该注意什么？如何避免（可以举例说明）"><a href="#18-Unity使用IL2CPP打包时，我们应该注意什么？如何避免（可以举例说明）" class="headerlink" title="18. Unity使用IL2CPP打包时，我们应该注意什么？如何避免（可以举例说明）"></a>18. Unity使用IL2CPP打包时，我们应该注意什么？如何避免（可以举例说明）</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
使用IL2CPP打包时，最可能出现的问题就是代码裁剪，IL2CPP会自动将它认为不会使用的代码裁剪掉，比如我们在使用Lua开发时，其实会用到很多UnityEngine或者我们自己写的C#代码，但是这些代码并不会在引擎中直接使用，都是在Lua中使用的，此时最容易出现的问题就是代码裁剪，导致打包后出现异常和报错。
---------------------------------------------------------------------------
要避免IL2CPP的裁剪有3种方式，我们可以组合使用
1.设置打包时的裁剪等级
2.通过xml文件配置明确规定哪些内容不裁剪
3.在静态方法中显示调用不想被裁剪的内容</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="19-两个四元数相乘有什么作用？四元数乘以向量有什么作用？"><a href="#19-两个四元数相乘有什么作用？四元数乘以向量有什么作用？" class="headerlink" title="19. 两个四元数相乘有什么作用？四元数乘以向量有什么作用？"></a>19. 两个四元数相乘有什么作用？四元数乘以向量有什么作用？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">四元数相乘：角度叠加
四元数乘以向量：向量旋转</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="20-图中的小球是否被渲染了？是否会产生DrawCall？"><a href="#20-图中的小球是否被渲染了？是否会产生DrawCall？" class="headerlink" title="20. 图中的小球是否被渲染了？是否会产生DrawCall？"></a>20. 图中的小球是否被渲染了？是否会产生DrawCall？</h2><blockquote>
<img src="https://skymirror-1316984539.cos.ap-beijing.myqcloud.com/Typoraimage-20250731223300752.png" alt="image-20250731223300752" style="zoom: 33%;" /></blockquote>
<blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
不会被渲染，不会产生DrawCall
Unity本身有摄像机视锥体剔除，也就是不会显示完全位于视锥体之外的游戏对象
那么小球就不会进行渲染，也不会提交数据给GPU，也就不会产生DrawCall</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="21-在没有使用遮挡剔除的情况下，图中A和B都是默认标准材质。图中的小球最终是否会被渲染，是否会产生DrawCall？"><a href="#21-在没有使用遮挡剔除的情况下，图中A和B都是默认标准材质。图中的小球最终是否会被渲染，是否会产生DrawCall？" class="headerlink" title="21. 在没有使用遮挡剔除的情况下，图中A和B都是默认标准材质。图中的小球最终是否会被渲染，是否会产生DrawCall？"></a>21. 在没有使用遮挡剔除的情况下，图中A和B都是默认标准材质。图中的小球最终是否会被渲染，是否会产生DrawCall？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
最终不会被渲染，标准材质存在深度测试，小球在立方体后方，不会通过深度测试，所以不会被渲染
会产生DrawCall，既然都深度测试了，那么肯定是存在DrawCall的
深度测试发生在片元着色器处理之后，GPU会对每个片元执行深度测试来决定遮挡关系，决定是否被渲染</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="22-如果不考虑IOS平台，只在Windows和Android平台上发布游戏，如何在不使用第三方热更新方案的前提下实现热更新功能"><a href="#22-如果不考虑IOS平台，只在Windows和Android平台上发布游戏，如何在不使用第三方热更新方案的前提下实现热更新功能" class="headerlink" title="22. 如果不考虑IOS平台，只在Windows和Android平台上发布游戏，如何在不使用第三方热更新方案的前提下实现热更新功能"></a>22. 如果不考虑IOS平台，只在Windows和Android平台上发布游戏，如何在不使用第三方热更新方案的前提下实现热更新功能</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
C#的反射
可以通过热更DLL文件的形式，加载程序集（dll）
利用反射执行热更DLL包中的逻辑</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="23-Unity中如何调试排查Android上运行的项目问题"><a href="#23-Unity中如何调试排查Android上运行的项目问题" class="headerlink" title="23. Unity中如何调试排查Android上运行的项目问题"></a>23. Unity中如何调试排查Android上运行的项目问题</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
1.如果需要进行断点调试
通过数据线链接运行项目的Android设备
发布时开启了
Development Build 开发模式构建
Autoconnect Profiler 自动连接分析器
Script Debuggins 脚本调试 
Wait For Managed Debugger 等待托管调试器
等选项
然后只需要Build and Run既可以
利用Unity的Profiler 性能剖析器窗口排查性能问题
并且还可以进行断点调试
-----------------------------------------------------
2.如果只是获取一些打印调试信息
可以利用Unity2019.4及其以上版本提供的Android Logcat工具获取信息
Unity2019.4以下的版本，可以使用Android的ADB（安卓调试桥）工具
---------------------------------------------------------
3.如果需要获取设备输入信息
可以利用Unity Remote来测试移动设备的输入相关逻辑</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="24-Unity引擎中哪些功能使用了C-的反射功能？至少说出一点"><a href="#24-Unity引擎中哪些功能使用了C-的反射功能？至少说出一点" class="headerlink" title="24. Unity引擎中哪些功能使用了C#的反射功能？至少说出一点"></a>24. Unity引擎中哪些功能使用了C#的反射功能？至少说出一点</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
1.Inspector窗口中显示的内容
2.预设体文件
3.场景文件
4.Unity中的各种特性
等等</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="25-Unity中Awake和Start两个生命周期函数，分别在什么时候被调用？"><a href="#25-Unity中Awake和Start两个生命周期函数，分别在什么时候被调用？" class="headerlink" title="25 . Unity中Awake和Start两个生命周期函数，分别在什么时候被调用？"></a>25 . Unity中Awake和Start两个生命周期函数，分别在什么时候被调用？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
Awake：运行时
当脚本被动态添加到对象上时立即被调用。
当对象被实例化时，依附它的脚本会立即调用Awake
它类似构造函数
Start：第一次Update之前被调用</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="26-Unity场景上有多个对象，都分别挂载了n个脚本。我们如何控制不同脚本间生命周期函数Awake的执行先后顺序？"><a href="#26-Unity场景上有多个对象，都分别挂载了n个脚本。我们如何控制不同脚本间生命周期函数Awake的执行先后顺序？" class="headerlink" title="26. Unity场景上有多个对象，都分别挂载了n个脚本。我们如何控制不同脚本间生命周期函数Awake的执行先后顺序？"></a>26. Unity场景上有多个对象，都分别挂载了n个脚本。我们如何控制不同脚本间生命周期函数Awake的执行先后顺序？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
1.可以通过选中脚本文件，点击Inspector窗口右上角的Execution Order（执行顺序）按钮 
2.可以打开Project Setting窗口，选择Script Execution Order选项
通过这两种方式我们可以打开脚本执行顺序窗口
在其中我们可以自己设置自定义脚本的执行顺序</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="27-想要在Unity中使用指针我们需要进行哪些操作？"><a href="#27-想要在Unity中使用指针我们需要进行哪些操作？" class="headerlink" title="27. 想要在Unity中使用指针我们需要进行哪些操作？"></a>27. 想要在Unity中使用指针我们需要进行哪些操作？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
1.需要在PlayerSetting中的OtherSettings中勾选  Allow 'unsafe' code 选项
2.使用指针时必须在unsafe修饰的代码块中</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="28-Unity中的协同程序中yield-return不同的内容，代表的含义不同请说明下面这些yield-return的含义"><a href="#28-Unity中的协同程序中yield-return不同的内容，代表的含义不同请说明下面这些yield-return的含义" class="headerlink" title="28. Unity中的协同程序中yield return不同的内容，代表的含义不同请说明下面这些yield return的含义"></a>28. Unity中的协同程序中yield return不同的内容，代表的含义不同请说明下面这些yield return的含义</h2><blockquote>
<p>1.yield return 数字;<br>2.yield return null;<br>3.yield return new WaitForSeconds(数字);<br>4.yield return new WaitForFixedUpdate();<br>5.yield return new WaitForEndOfFrame();<br>6.yield break;</p>
</blockquote>
<blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
1.yield return 数字; 下一帧执行
2.yield return null;  下一帧执行
3.yield return new WaitForSeconds(数字); 等待指定秒后执行
4.yield return new WaitForFixedUpdate(); 等待下一个固定物理帧更新时执行
5.yield return new WaitForEndOfFrame(); 等待摄像机和GUI渲染完成后执行
6.yield break; 跳出协程</span>
</code></pre>
</details></blockquote>
<hr>
<h2 id="29-使用Unity协同程序进行异步加载时，底层是否会使用多线程？"><a href="#29-使用Unity协同程序进行异步加载时，底层是否会使用多线程？" class="headerlink" title="29.使用Unity协同程序进行异步加载时，底层是否会使用多线程？"></a><code>29</code>.使用Unity协同程序进行异步加载时，底层是否会使用多线程？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
可能会
协同程序的原理是分时分步完成指定逻辑
在其中的某一步骤中，是可以使用多线程来完成某些加载操作的，多线程加载完成后，再进入协同程序的下一步继续执行</span>
</code></pre>
</details></blockquote>
<h1 id="Shader相关"><a href="#Shader相关" class="headerlink" title="Shader相关"></a>Shader相关</h1><hr>
<h1 id="Lua相关"><a href="#Lua相关" class="headerlink" title="Lua相关"></a>Lua相关</h1><hr>
<h2 id="1-Lua如何实现面向对象的三大特性？"><a href="#1-Lua如何实现面向对象的三大特性？" class="headerlink" title="1. Lua如何实现面向对象的三大特性？"></a>1. Lua如何实现面向对象的三大特性？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
面向对象三大特性
封装：利用table进行封装
继承：利用元表和__index模拟继承关系
          设置子类的元表为父类，父类的__index为父类自己
          当子类身上找不到对应属性和方法时
          会查找元表的__index中的内容，也就是会查找父类中的内容
          通过这种方式来模拟继承
多态：子类自己去实现带：的同名方法即可</span>
</code></pre>
</details></blockquote>
<hr>
<h1 id="网络相关"><a href="#网络相关" class="headerlink" title="网络相关"></a>网络相关</h1><hr>
<h2 id="1-网络游戏开发中，网络传输数据的基本流程是什么？"><a href="#1-网络游戏开发中，网络传输数据的基本流程是什么？" class="headerlink" title="1. 网络游戏开发中，网络传输数据的基本流程是什么？"></a>1. 网络游戏开发中，网络传输数据的基本流程是什么？</h2><blockquote>
<details>
<summary>解析查看</summary>
<pre><code>
<span style="color: red;">答案：
客户端将自定义类对象数据序列化为2进制数据发送给服务端
服务端将收到的2进制数据反序列化为对应的类对象进行逻辑处理
如果是服务端发送给客户端的消息也是同理</span>
</code></pre>
</details></blockquote>
<hr>
<h1 id="数学相关"><a href="#数学相关" class="headerlink" title="数学相关"></a>数学相关</h1><hr>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://wqxblog.top">wqx</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://wqxblog.top/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/">http://wqxblog.top/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://wqxblog.top" target="_blank">游戏开发笔记</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a></div><div class="post-share"><div class="social-share" data-image="https://skymirror-1316984539.cos.ap-beijing.myqcloud.com/Typoramimi.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/%E6%B8%B2%E6%9F%93/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E5%9F%BA%E7%A1%80/" title="渲染管线基础"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">渲染管线基础</div></div><div class="info-2"><div class="info-item-1"> 该内容基于Games101课程，内容可能有些杂乱，后续会详细整理。建议学习shader之前要看过一遍101  渲染管线基础 所谓渲染就是把三维空间的物体变成一张图 渲染管线就是将数据分阶段的变为屏幕图像的过程        具体绘制流程如下：  模型空间变换到世界空间 世界空间变换到观察空间 观察空间变换到裁剪空间 裁剪空间变换到屏幕空间 拿到屏幕空间对应映射的位置后，进行光栅化绘制像素       渲染管线分为三个阶段  应用阶段  该阶段中我们将渲染需要的数据传递给GPU用于后续两个阶段的处理  该阶段主导者为CPU  该阶段为渲染做了哪些准备？？  把不可见的物体数据剔除 准备好模型相关数据（顶点、法线、切线、贴图、着色器等等） 将数据加载到显存中 设置渲染状态（设置网格需要使用哪个着色器、材质、光源属性等等） 调用DrawCall（CPU通知GPU使用相关的数据和渲染状态进行渲染）       几何阶段  图元：几何体的最小可绘制单元。就是由顶点数据组合成的点、线、三角形。   ​           ...</div></div></div></a><a class="pagination-related" href="/%E6%A1%88%E4%BE%8B/Lily%E5%A5%A5%E5%BE%B7%E8%B5%9B/%E5%AE%9E%E6%88%98%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98/" title="实战中的问题"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">实战中的问题</div></div><div class="info-2"><div class="info-item-1">实战中的问题一、人物为什么没有动画情况下是张开双臂的状态 答案：建模时要绑定骨骼，四肢要明确反映出来，具体到底是头躯干还是腿，默认使用T字模型。   二、速通新InputSystem1.InputSystem是什么 绑定—》按下—》开始、触发、结束三个事件    2.Action参数   3.输入动作设置    4. 相互作用设置     5.值加工设置    6.按键绑定    7.InputAction类使用（1）启用输入检测 委托变量.Enable()；   （2）操作监听 三个基本事件     监听函数 使用CallbackContext获取信息CallbackContext context参数包含了触发动作的所有信息。你可以使用这个上下文来访问更多细节，例如：  context.ReadValue&lt;float&gt;(): 获取输入值（例如，对于键盘按键或手柄按钮）。 context.control: 获取触发该动作的输入控件。 context.interaction: 获取当前交互类型（例如，是否为按下、释放等）。 context.phase:...</div></div></div></a></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="https://skymirror-1316984539.cos.ap-beijing.myqcloud.com/Typoramimi.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">wqx</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">23</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">19</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">-只用于学习如有版权问题请联系我 484807196@qq.com</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E7%9B%B8%E5%85%B3"><span class="toc-number">1.</span> <span class="toc-text">C#相关</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%A3%85%E7%AE%B1%E5%92%8C%E6%8B%86%E7%AE%B1%E6%98%AF%E6%8C%87%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.1.</span> <span class="toc-text">1. 装箱和拆箱是指什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%80%BC%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%9C%A8%E5%8F%98%E9%87%8F%E8%B5%8B%E5%80%BC%E6%97%B6%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.2.</span> <span class="toc-text">2. 值和引用类型在变量赋值时的区别是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%A7%94%E6%89%98%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%9C%A8%E4%BD%BF%E7%94%A8%E4%B8%8A%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.3.</span> <span class="toc-text">3.  委托和事件在使用上的区别是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%9C%89%E4%B8%A4%E4%B8%AA%E6%8E%A5%E5%8F%A3IA%E5%92%8CIB%EF%BC%8C%E4%BB%96%E4%BB%AC%E4%B8%AD%E6%9C%89%E4%B8%80%E4%B8%AA%E5%90%8C%E5%90%8D%E6%96%B9%E6%B3%95Test-%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%90%8C%E6%97%B6%E7%BB%A7%E6%89%BF%E8%BF%99%E4%B8%A4%E4%B8%AA%E6%8E%A5%E5%8F%A3%EF%BC%8C%E5%BA%94%E8%AF%A5%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E4%BB%96%E4%BB%AC%E7%9A%84%E5%90%8C%E5%90%8D%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">1.4.</span> <span class="toc-text">4. 有两个接口IA和IB，他们中有一个同名方法Test()一个类同时继承这两个接口，应该如何处理他们的同名方法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E8%AF%B7%E8%AF%B4%E6%98%8EC-%E4%B8%AD%E7%9A%84List%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A9%E5%AE%B9%E7%9A%84"><span class="toc-number">1.5.</span> <span class="toc-text">5. 请说明C#中的List是如何扩容的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E8%AF%B7%E8%AF%B4%E8%AF%B4%E4%BD%A0%E8%AE%A4%E4%B8%BAC-%E4%B8%AD-%E5%92%8C-Equals-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.6.</span> <span class="toc-text">6.请说说你认为C#中 &#x3D;&#x3D; 和 Equals 的区别是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.7.</span> <span class="toc-text">7. 浅拷贝和深拷贝的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E4%B8%8A%E9%9D%A2%E4%B8%A4%E7%A7%8D%E8%8E%B710000%E4%B8%AA%E6%95%B0%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%8C%E5%93%AA%E7%A7%8D%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88"><span class="toc-number">1.8.</span> <span class="toc-text">8. 上面两种获10000个数的方式，哪种效率更高？为什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E8%AF%B7%E8%AF%B4%E5%87%BA%E4%BB%A5%E4%B8%8A%E4%BB%A3%E7%A0%81%EF%BC%9A1-A%E5%A4%84%E5%92%8CB%E5%A4%84%E8%B0%81%E5%85%88%E6%89%93%E5%8D%B0%EF%BC%9F-2-A%E3%80%81B%E5%87%BA%E6%89%93%E5%8D%B0%E7%9A%84i%E5%80%BC%E5%88%86%E5%88%AB%E6%98%AF%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="toc-number">1.9.</span> <span class="toc-text">9. 请说出以上代码：1.A处和B处谁先打印？ 2. A、B出打印的i值分别是多少？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E6%B3%9B%E5%9E%8B%E7%9A%84%E7%BA%A6%E6%9D%9F%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%EF%BC%9F"><span class="toc-number">1.10.</span> <span class="toc-text">10.泛型的约束有哪几种？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E4%BB%80%E4%B9%88%E6%98%AF%E9%97%AD%E5%8C%85%EF%BC%9F%E5%8F%AF%E4%BB%A5%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E"><span class="toc-number">1.11.</span> <span class="toc-text">11 . 什么是闭包？可以举例说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%8C%87%E4%BB%80%E4%B9%88%EF%BC%9F%E5%B8%B8%E8%A7%81%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">1.12.</span> <span class="toc-text">12 . 内存泄漏指什么？常见的内存泄漏有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-%E5%BA%8F%E5%88%97%E5%8C%96%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%B8%B8%E8%A7%81%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E6%88%91%E4%BB%AC%E4%BC%9A%E7%94%A8%E5%88%B0%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%9F"><span class="toc-number">1.13.</span> <span class="toc-text">13. 序列化是什么？常见的序列化方式有哪些？什么时候我们会用到序列化？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-%E8%AF%B7%E8%AF%B4%E6%98%8E%E4%BB%A5%E4%B8%8B%E4%B8%89%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.14.</span> <span class="toc-text">14. 请说明以下三者的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-C-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%8C%E9%87%8D%E8%BD%BD-%E5%92%8C-%E4%BB%A5%E5%8F%8A-%E4%B8%87%E7%89%A9%E4%B9%8B%E7%88%B6Object%E5%9F%BA%E7%B1%BB%E4%B8%AD%E7%9A%84%E8%99%9A%E6%96%B9%E6%B3%95-virtual-bool-Equals-Object-obj-%E5%AF%B9%E4%BA%8E%E6%88%91%E4%BB%AC%E7%9A%84%E6%84%8F%E4%B9%89%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.15.</span> <span class="toc-text">15. C#重载运算符，重载 &#x3D;&#x3D; 和 !&#x3D; 以及 万物之父Object基类中的虚方法 virtual bool Equals(Object obj)对于我们的意义是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-%E5%9C%A8%E5%BC%80%E5%8F%91%E6%97%B6%EF%BC%8C%E5%AF%B9string%E5%92%8CStringBuilder%E6%88%91%E4%BB%AC%E5%BA%94%E8%AF%A5%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9"><span class="toc-number">1.16.</span> <span class="toc-text">16.在开发时，对string和StringBuilder我们应该如何选择</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-%E8%AF%B7%E7%AE%80%E8%A6%81%E8%AF%B4%E6%98%8E-Net%E8%B7%A8%E8%AF%AD%E8%A8%80%E5%8E%9F%E7%90%86"><span class="toc-number">1.17.</span> <span class="toc-text">17. 请简要说明.Net跨语言原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-%E8%AF%B7%E7%AE%80%E8%A6%81%E8%AF%B4%E6%98%8E-Net%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%8E%9F%E7%90%86"><span class="toc-number">1.18.</span> <span class="toc-text">18. 请简要说明.Net跨平台原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.19.</span> <span class="toc-text">19. 数组和链表的区别是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-C-%E4%B8%AD%E7%9A%84Action%E5%92%8CFunc%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9FUnity-%E4%B8%AD%E7%9A%84UnityAction%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%BB%96%E4%BB%AC%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.20.</span> <span class="toc-text">20. C# 中的Action和Func是什么？Unity 中的UnityAction是什么？他们有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-%EF%BC%88%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%AD%E7%9A%84%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%EF%BC%89%E8%AF%B7%E9%97%AE%E6%9C%80%E7%BB%88%E5%BE%97%E5%88%B0%E6%89%93%E5%8D%B0%E7%BB%93%E6%9E%9C%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%EF%BC%9F"><span class="toc-number">1.21.</span> <span class="toc-text">21. （结构体中的引用类型）请问最终得到打印结果是什么？？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-C-%E4%B8%AD%E5%A6%82%E4%BD%95%E8%AE%A9%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AE%B9%E5%99%A8%E7%B1%BB%E8%83%BD%E5%A4%9F%E4%BD%BF%E7%94%A8for%E5%BE%AA%E7%8E%AF%E9%81%8D%E5%8E%86%EF%BC%9F%EF%BC%88%E9%80%9A%E8%BF%87-%E7%B1%BB%E5%AF%B9%E8%B1%A1-%E7%B4%A2%E5%BC%95-%E7%9A%84%E5%BD%A2%E5%BC%8F%E9%81%8D%E5%8E%86%EF%BC%89"><span class="toc-number">1.22.</span> <span class="toc-text">22. C#中如何让自定义容器类能够使用for循环遍历？（通过 类对象[索引] 的形式遍历）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-C-%E4%B8%AD%E5%A6%82%E4%BD%95%E8%AE%A9%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AE%B9%E5%99%A8%E7%B1%BB%E8%83%BD%E5%A4%9F%E4%BD%BF%E7%94%A8foreach%E5%BE%AA%E7%8E%AF%E9%81%8D%E5%8E%86%EF%BC%9F"><span class="toc-number">1.23.</span> <span class="toc-text">23. C#中如何让自定义容器类能够使用foreach循环遍历？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-C-%E4%B8%AD%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E8%AF%B4%E8%AF%B4%E4%BD%A0%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">1.24.</span> <span class="toc-text">24. C#中接口的作用是什么？说说你的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25-%E8%AF%B7%E9%97%AE%E4%BB%A5%E4%B8%8A%E8%BF%99%E4%B8%89%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%8C%E8%BF%90%E8%A1%8C%E5%90%8E%EF%BC%8C%E5%9C%A8%E5%A0%86%E4%B8%8A%E4%BC%9A%E5%88%86%E9%85%8D%E5%87%A0%E4%B8%AA%E2%80%9C%E6%88%BF%E9%97%B4%E2%80%9D"><span class="toc-number">1.25.</span> <span class="toc-text">25. 请问以上这三行代码，运行后，在堆上会分配几个“房间”</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Unity%E7%9B%B8%E5%85%B3"><span class="toc-number">2.</span> <span class="toc-text">Unity相关</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Unity%E4%B8%AD%E7%82%B9%E4%B9%98%E5%92%8C%E5%8F%89%E4%B9%98%E5%AF%B9%E4%BA%8E%E6%88%91%E4%BB%AC%E6%9D%A5%E8%AF%B4%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.1.</span> <span class="toc-text">1. Unity中点乘和叉乘对于我们来说的作用是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Unity%E4%B8%AD%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E4%B8%8B%E9%9D%A2%E5%93%AA%E4%BA%9B%E4%BB%A3%E7%A0%81%E4%BC%9A%E6%8A%A5%E9%94%99%EF%BC%9F"><span class="toc-number">2.2.</span> <span class="toc-text">2. Unity中多线程执行下面哪些代码会报错？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Application-streamingAssetsPath-%E5%92%8C-Application-persistentDataPath%E4%B8%A4%E4%B8%AA%E8%B7%AF%E5%BE%84%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB%EF%BC%9F%E5%AF%B9%E4%BA%8E%E6%88%91%E4%BB%AC%E7%9A%84%E6%84%8F%E4%B9%89%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.3.</span> <span class="toc-text">3. Application.streamingAssetsPath 和 Application.persistentDataPath两个路径有何区别？对于我们的意义是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E8%AF%B7%E7%AE%80%E8%BF%B0Unity%E4%B8%AD%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8E%9F%E7%90%86%E3%80%82"><span class="toc-number">2.4.</span> <span class="toc-text">4. 请简述Unity中协程的原理。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Unity%E5%BA%95%E5%B1%82%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86C-%E4%BB%A3%E7%A0%81"><span class="toc-number">2.5.</span> <span class="toc-text">5. Unity底层如何处理C#代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-Unity%E4%B8%AD%E5%BD%93%E4%B8%80%E4%B8%AA%E7%BB%86%E5%B0%8F%E9%AB%98%E9%80%9F%E7%89%A9%E4%BD%93%E6%92%9E%E5%87%BB%E5%8F%A6%E4%B8%80%E4%B8%AA%E8%BE%83%E5%A4%A7%E7%89%A9%E4%BD%93%E6%97%B6%E4%BC%9A%E5%87%BA%E7%8E%B0%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%EF%BC%9F%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%EF%BC%9F"><span class="toc-number">2.6.</span> <span class="toc-text">6. Unity中当一个细小高速物体撞击另一个较大物体时会出现什么情况？如何避免？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E8%AF%B7%E7%AE%80%E8%BF%B0%E4%B8%80%E4%B8%8BPrefab%EF%BC%88%E9%A2%84%E5%88%B6%E4%BD%93%EF%BC%89%E7%9A%84%E6%9C%AC%E8%B4%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.7.</span> <span class="toc-text">7. 请简述一下Prefab（预制体）的本质是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-Unity%E6%98%AF%E5%90%A6%E6%94%AF%E6%8C%81%E5%86%99%E6%88%90%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%A8%8B%E5%BA%8F%EF%BC%9F%E5%A6%82%E6%9E%9C%E6%94%AF%E6%8C%81%E7%9A%84%E8%AF%9D%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.8.</span> <span class="toc-text">8. Unity是否支持写成多线程程序？如果支持的话需要注意什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E8%AF%B7%E7%AE%80%E8%BF%B0%E4%B8%80%E4%B8%8B%E5%AF%B9%E8%B1%A1%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%8C%E5%9C%A8%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD%E6%88%91%E4%BB%AC%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E7%94%A8%E5%88%B0%E5%AE%83%EF%BC%9F"><span class="toc-number">2.9.</span> <span class="toc-text">9. 请简述一下对象池实现原理，在游戏开发中我们什么时候会用到它？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E4%BB%80%E4%B9%88%E6%98%AFDrawCall%EF%BC%9FDrawCall%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%BD%B1%E5%93%8D%E6%B8%B8%E6%88%8F%E8%BF%90%E8%A1%8C%E6%95%88%E7%8E%87%EF%BC%9F"><span class="toc-number">2.10.</span> <span class="toc-text">10 .什么是DrawCall？DrawCall为什么会影响游戏运行效率？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-transform-forward%E5%92%8CVector3-forword%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.11.</span> <span class="toc-text">11. transform.forward和Vector3.forword的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-Unity%E4%B8%AD%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%BF%87%E5%A4%9A%E5%88%9B%E5%BB%BA%E5%92%8C%E5%88%A0%E9%99%A4%E5%AF%B9%E8%B1%A1%E5%B8%A6%E6%9D%A5%E7%9A%84%E5%8D%A1%E9%A1%BF%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">2.12.</span> <span class="toc-text">12. Unity中如何解决过多创建和删除对象带来的卡顿问题？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-%E6%B8%B8%E6%88%8F%E4%B8%AD%E7%9A%84%E6%88%90%E5%B0%B1%E7%B3%BB%E7%BB%9F%EF%BC%8C%E6%88%91%E4%BB%AC%E4%B8%80%E8%88%AC%E4%BC%9A%E4%BD%BF%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%AD%E7%9A%84%E5%93%AA%E7%A7%8D%E6%A8%A1%E5%BC%8F%E6%9D%A5%E5%88%B6%E4%BD%9C%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.13.</span> <span class="toc-text">13. 游戏中的成就系统，我们一般会使用设计模式中的哪种模式来制作？为什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-%E8%AF%B7%E7%AE%80%E8%BF%B0%E7%83%AD%E6%9B%B4%E6%96%B0%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-number">2.14.</span> <span class="toc-text">14. 请简述热更新的流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-%E6%88%91%E4%BB%AC%E5%BA%94%E8%AF%A5%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96UI%EF%BC%88%E5%9F%BA%E4%BA%8EUGUI%EF%BC%89"><span class="toc-number">2.15.</span> <span class="toc-text">15. 我们应该如何优化UI（基于UGUI）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-Unity%E4%B8%AD%E7%9A%84Destroy%E5%92%8CDestroyImmediate%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.16.</span> <span class="toc-text">16. Unity中的Destroy和DestroyImmediate的区别是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%89%A7%E8%A1%8CGameObject-Instantiate%E6%97%B6%E5%8F%AF%E8%83%BD%E5%87%BA%E7%8E%B0%E6%98%8E%E6%98%BE%E7%9A%84%E5%8D%A1%E9%A1%BF%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%AF%A5%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">2.17.</span> <span class="toc-text">17. 第一次执行GameObject.Instantiate时可能出现明显的卡顿如何解决该问题？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-Unity%E4%BD%BF%E7%94%A8IL2CPP%E6%89%93%E5%8C%85%E6%97%B6%EF%BC%8C%E6%88%91%E4%BB%AC%E5%BA%94%E8%AF%A5%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88%EF%BC%9F%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%EF%BC%88%E5%8F%AF%E4%BB%A5%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E%EF%BC%89"><span class="toc-number">2.18.</span> <span class="toc-text">18. Unity使用IL2CPP打包时，我们应该注意什么？如何避免（可以举例说明）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-%E4%B8%A4%E4%B8%AA%E5%9B%9B%E5%85%83%E6%95%B0%E7%9B%B8%E4%B9%98%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F%E5%9B%9B%E5%85%83%E6%95%B0%E4%B9%98%E4%BB%A5%E5%90%91%E9%87%8F%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">2.19.</span> <span class="toc-text">19. 两个四元数相乘有什么作用？四元数乘以向量有什么作用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-%E5%9B%BE%E4%B8%AD%E7%9A%84%E5%B0%8F%E7%90%83%E6%98%AF%E5%90%A6%E8%A2%AB%E6%B8%B2%E6%9F%93%E4%BA%86%EF%BC%9F%E6%98%AF%E5%90%A6%E4%BC%9A%E4%BA%A7%E7%94%9FDrawCall%EF%BC%9F"><span class="toc-number">2.20.</span> <span class="toc-text">20. 图中的小球是否被渲染了？是否会产生DrawCall？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-%E5%9C%A8%E6%B2%A1%E6%9C%89%E4%BD%BF%E7%94%A8%E9%81%AE%E6%8C%A1%E5%89%94%E9%99%A4%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%8C%E5%9B%BE%E4%B8%ADA%E5%92%8CB%E9%83%BD%E6%98%AF%E9%BB%98%E8%AE%A4%E6%A0%87%E5%87%86%E6%9D%90%E8%B4%A8%E3%80%82%E5%9B%BE%E4%B8%AD%E7%9A%84%E5%B0%8F%E7%90%83%E6%9C%80%E7%BB%88%E6%98%AF%E5%90%A6%E4%BC%9A%E8%A2%AB%E6%B8%B2%E6%9F%93%EF%BC%8C%E6%98%AF%E5%90%A6%E4%BC%9A%E4%BA%A7%E7%94%9FDrawCall%EF%BC%9F"><span class="toc-number">2.21.</span> <span class="toc-text">21. 在没有使用遮挡剔除的情况下，图中A和B都是默认标准材质。图中的小球最终是否会被渲染，是否会产生DrawCall？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-%E5%A6%82%E6%9E%9C%E4%B8%8D%E8%80%83%E8%99%91IOS%E5%B9%B3%E5%8F%B0%EF%BC%8C%E5%8F%AA%E5%9C%A8Windows%E5%92%8CAndroid%E5%B9%B3%E5%8F%B0%E4%B8%8A%E5%8F%91%E5%B8%83%E6%B8%B8%E6%88%8F%EF%BC%8C%E5%A6%82%E4%BD%95%E5%9C%A8%E4%B8%8D%E4%BD%BF%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E7%83%AD%E6%9B%B4%E6%96%B0%E6%96%B9%E6%A1%88%E7%9A%84%E5%89%8D%E6%8F%90%E4%B8%8B%E5%AE%9E%E7%8E%B0%E7%83%AD%E6%9B%B4%E6%96%B0%E5%8A%9F%E8%83%BD"><span class="toc-number">2.22.</span> <span class="toc-text">22. 如果不考虑IOS平台，只在Windows和Android平台上发布游戏，如何在不使用第三方热更新方案的前提下实现热更新功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-Unity%E4%B8%AD%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95%E6%8E%92%E6%9F%A5Android%E4%B8%8A%E8%BF%90%E8%A1%8C%E7%9A%84%E9%A1%B9%E7%9B%AE%E9%97%AE%E9%A2%98"><span class="toc-number">2.23.</span> <span class="toc-text">23. Unity中如何调试排查Android上运行的项目问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-Unity%E5%BC%95%E6%93%8E%E4%B8%AD%E5%93%AA%E4%BA%9B%E5%8A%9F%E8%83%BD%E4%BD%BF%E7%94%A8%E4%BA%86C-%E7%9A%84%E5%8F%8D%E5%B0%84%E5%8A%9F%E8%83%BD%EF%BC%9F%E8%87%B3%E5%B0%91%E8%AF%B4%E5%87%BA%E4%B8%80%E7%82%B9"><span class="toc-number">2.24.</span> <span class="toc-text">24. Unity引擎中哪些功能使用了C#的反射功能？至少说出一点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25-Unity%E4%B8%ADAwake%E5%92%8CStart%E4%B8%A4%E4%B8%AA%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0%EF%BC%8C%E5%88%86%E5%88%AB%E5%9C%A8%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%A2%AB%E8%B0%83%E7%94%A8%EF%BC%9F"><span class="toc-number">2.25.</span> <span class="toc-text">25 . Unity中Awake和Start两个生命周期函数，分别在什么时候被调用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26-Unity%E5%9C%BA%E6%99%AF%E4%B8%8A%E6%9C%89%E5%A4%9A%E4%B8%AA%E5%AF%B9%E8%B1%A1%EF%BC%8C%E9%83%BD%E5%88%86%E5%88%AB%E6%8C%82%E8%BD%BD%E4%BA%86n%E4%B8%AA%E8%84%9A%E6%9C%AC%E3%80%82%E6%88%91%E4%BB%AC%E5%A6%82%E4%BD%95%E6%8E%A7%E5%88%B6%E4%B8%8D%E5%90%8C%E8%84%9A%E6%9C%AC%E9%97%B4%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0Awake%E7%9A%84%E6%89%A7%E8%A1%8C%E5%85%88%E5%90%8E%E9%A1%BA%E5%BA%8F%EF%BC%9F"><span class="toc-number">2.26.</span> <span class="toc-text">26. Unity场景上有多个对象，都分别挂载了n个脚本。我们如何控制不同脚本间生命周期函数Awake的执行先后顺序？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27-%E6%83%B3%E8%A6%81%E5%9C%A8Unity%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%8C%87%E9%92%88%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81%E8%BF%9B%E8%A1%8C%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C%EF%BC%9F"><span class="toc-number">2.27.</span> <span class="toc-text">27. 想要在Unity中使用指针我们需要进行哪些操作？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28-Unity%E4%B8%AD%E7%9A%84%E5%8D%8F%E5%90%8C%E7%A8%8B%E5%BA%8F%E4%B8%ADyield-return%E4%B8%8D%E5%90%8C%E7%9A%84%E5%86%85%E5%AE%B9%EF%BC%8C%E4%BB%A3%E8%A1%A8%E7%9A%84%E5%90%AB%E4%B9%89%E4%B8%8D%E5%90%8C%E8%AF%B7%E8%AF%B4%E6%98%8E%E4%B8%8B%E9%9D%A2%E8%BF%99%E4%BA%9Byield-return%E7%9A%84%E5%90%AB%E4%B9%89"><span class="toc-number">2.28.</span> <span class="toc-text">28. Unity中的协同程序中yield return不同的内容，代表的含义不同请说明下面这些yield return的含义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#29-%E4%BD%BF%E7%94%A8Unity%E5%8D%8F%E5%90%8C%E7%A8%8B%E5%BA%8F%E8%BF%9B%E8%A1%8C%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD%E6%97%B6%EF%BC%8C%E5%BA%95%E5%B1%82%E6%98%AF%E5%90%A6%E4%BC%9A%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="toc-number">2.29.</span> <span class="toc-text">29.使用Unity协同程序进行异步加载时，底层是否会使用多线程？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Shader%E7%9B%B8%E5%85%B3"><span class="toc-number">3.</span> <span class="toc-text">Shader相关</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Lua%E7%9B%B8%E5%85%B3"><span class="toc-number">4.</span> <span class="toc-text">Lua相关</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Lua%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%EF%BC%9F"><span class="toc-number">4.1.</span> <span class="toc-text">1. Lua如何实现面向对象的三大特性？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3"><span class="toc-number">5.</span> <span class="toc-text">网络相关</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD%EF%BC%8C%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E6%95%B0%E6%8D%AE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">5.1.</span> <span class="toc-text">1. 网络游戏开发中，网络传输数据的基本流程是什么？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E5%AD%A6%E7%9B%B8%E5%85%B3"><span class="toc-number">6.</span> <span class="toc-text">数学相关</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/Unity%E5%B7%A5%E5%85%B7/Excel%E6%95%B0%E6%8D%AE%E5%B7%A5%E5%85%B7%E5%8C%85/" title="Excel配置表小工具">Excel配置表小工具</a><time datetime="2025-07-27T02:43:33.549Z" title="发表于 2025-07-27 10:43:33">2025-07-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/Shader/UnityShader%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89/" title="UnityShader基础（上）">UnityShader基础（上）</a><time datetime="2025-07-22T07:30:00.000Z" title="发表于 2025-07-22 15:30:00">2025-07-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/Shader/UnityShader%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E7%BA%B9%E7%90%86%E5%92%8C%E9%80%8F%E6%98%8E/" title="UnityShader入门——纹理和透明">UnityShader入门——纹理和透明</a><time datetime="2025-07-22T06:14:08.876Z" title="发表于 2025-07-22 14:14:08">2025-07-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/Shader/UnityShader%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E5%85%89%E7%85%A7/" title="UnityShader入门——光照">UnityShader入门——光照</a><time datetime="2025-07-20T15:12:23.650Z" title="发表于 2025-07-20 23:12:23">2025-07-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/Shader/Shader%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/" title="UnityShader前置知识">UnityShader前置知识</a><time datetime="2025-07-19T11:17:23.633Z" title="发表于 2025-07-19 19:17:23">2025-07-19</time></div></div></div></div></div></div></main><footer id="footer" style="background: linear-gradient(135deg,#1a1a1a 0%,#2c3e50 40%,#34495e 60%,#2980b9 80%,#1a1a1a 100%);"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By wqx</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const initValine = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyValine = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const valineConfig = {
      el: '#vcomment',
      appId: 'pjJwWJWtXHLRCDLec3YJwOKJ-gzGzoHsz',
      appKey: 'iQtqxeQmZAFwQ0VtxYgke25D',
      avatar: 'monsterid',
      serverURLs: 'https://pjjwwjwt.lc-cn-n1-shared.com',
      emojiMaps: "",
      visitor: false,
      ...option,
      path: isShuoshuo ? path : (option && option.path) || window.location.pathname
    }

    new Valine(valineConfig)
  }

  const loadValine = async (el, path) => {
    if (typeof Valine === 'function') {
      initValine(el, path)
    } else {
      await btf.getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js')
      initValine(el, path)
    }
  }

  if (isShuoshuo) {
    'Valine' === 'Valine'
      ? window.shuoshuoComment = { loadComment: loadValine }
      : window.loadOtherComment = loadValine
    return
  }

  if ('Valine' === 'Valine' || !false) {
    if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>